<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>树状数组学习笔记</title>
    <url>/binary-index-trees-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>树状数组是一种维护线性数组前缀和的特殊方法，使用了类似于快速幂等的二进制分组的优势，对数组进行分段，从而可以快速求出该数组的前缀和的树形数据结构。</p>
<p>这一点与线段树类似。树状数组能干的事情线段树都能干，线段树能干的事情树状数组不一定能干。但树状数组相对线段树代码更短更好写，故在只涉及单点修改的时候树状数组更常用。</p>
<span id="more"></span>
<p>树状数组的工作原理如下图（图片引用自 OI Wiki）：</p>
<p><img src="https://oi-wiki.org/ds/images/fenwick.svg" /></p>
<p>将 <span class="math inline">\(a\)</span> 数组分为图示若干段，其中
<span class="math inline">\(c\)</span> 数组存的是区间和。</p>
<h1 id="前置知识">前置知识</h1>
<a href="/bitwise-operator-notes/" title="详见之前《位运算学习笔记》博客">详见之前《位运算学习笔记》博客</a>
<p>这里想补充一点，就是 lowbit 计算。</p>
<p>lowbit 计算的目的是求出一个数在二进制下最后一位 1 和之后的所有 0
所组成的数。</p>
<p>具体求法为 <code>x = x &amp; -x</code>，接下我将会利用数字 20
解释其原理。</p>
<p>首先将 20 的二进制表示出来，为 010100。</p>
<p>然后将 20 的负数表示出来，在补码的表示方法为将 20 按位取反，再
+1，即为 101100。</p>
<p>再将两个数进行与运算，得到二进制数 000100，十进制数为 4。该数即为 20
在二进制下的最后一个 1 和之后的 0 所组成的数。</p>
<p>lowbit 计算为树状数组的基础运算。</p>
<h1 id="实现方法">实现方法</h1>
<p>那么怎么实现对数组的分段？这里就需要使用之前介绍的 <span
class="math inline">\(\text{lowbit}\)</span> 计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>树状数组支持两种操作：单点修改，前缀求和。</p>
<h2 id="初始化">初始化</h2>
<p>首先在使用树状数组之间，我们需要将其初始化。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> c[MAXN + <span class="number">1</span>];    <span class="comment">//存储区间和</span></span><br><span class="line"><span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br></pre></td></tr></table></figure>
<h2 id="单点修改">单点修改</h2>
<p>树状数组可以将单点单独加一个值，例如修改 <span
class="math inline">\(a_5\)</span>
工作原理如下（对应上图序号）（画图丑请见谅）：</p>
<pre class="mermaid">
graph LR
a5 --&gt; c6 --&gt; c8
</pre>
<p>即为逐级上升，在经过的结点都加上这个值即可。</p>
<p>关于如何求上升后的坐标，使用 <span
class="math inline">\(\text{lowbit}\)</span> 即可。</p>
<p><span class="math display">\[
\begin{cases}
5 + \text{lowbit}(5) = 6 &amp; a_5 \rightarrow c_6 \\
6 + \text{lowbit}(6) = 8 &amp; c_6 \rightarrow c_8
\end{cases}
\]</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;    <span class="comment">// 防止数组越界</span></span><br><span class="line">        c[x] = c[x] + k;</span><br><span class="line">        x = x + <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="前缀查询">前缀查询</h2>
<p>树状数组最主要的功能就是求前缀和，例如查询 <span
class="math inline">\(a_7\)</span> 工作原理如下：</p>
<pre class="mermaid">
graph LR
a7 --&gt; c6 --&gt; c4
</pre>
<p>即为不停地查询上一层的前一个，同时将值加入最终结果即可。</p>
<p>求前一层的前一个也可以使用前缀和：</p>
<p><span class="math display">\[
\begin{cases}
7 - \text{lowbit}(7) = 6 &amp; a_7 \rightarrow c_6 \\
6 - \text{lowbit}(6) = 4 &amp; c_6 \rightarrow c_4
\end{cases}
\]</span></p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ans = ans + c[x];</span><br><span class="line">        x = x - <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上为树状数组最基础的操作</p>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3374">洛谷 P3374
【模板】树状数组 1</a></p>
<p>简单的模板题，结合上面的知识即可 AC。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> c[MAXN + <span class="number">1</span>], n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">lowbit</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (x &lt;= n) &#123;</span><br><span class="line">        c[x] = c[x] + k;</span><br><span class="line">        x = x + <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getsum</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (x &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        ans = ans + c[x];</span><br><span class="line">        x = x - <span class="built_in">lowbit</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="built_in">memset</span>(c, <span class="number">0</span>, <span class="built_in">sizeof</span>(c));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x);</span><br><span class="line">        <span class="built_in">add</span>(i, x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> m, x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;m, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">1</span>) <span class="built_in">add</span>(x, y);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">getsum</span>(y) - <span class="built_in">getsum</span>(x - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>树状数组</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ 3029」守卫者的挑战 - 概率与期望</title>
    <url>/bzoj-3029/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://hydro.ac/d/bzoj/p/3029">HydroOJ 链接</a></p>
<p>打开了黑魔法师 Vani 的大门，队员们在迷宫般的路上漫无目的地搜寻着关押
applepi
的监狱的所在地。突然，眼前一道亮光闪过。“我，Nizem，是黑魔法圣殿的守卫者。如果你能通过我的挑战，那么你可以带走黑魔法圣殿的地图……”瞬间，队员们被传送到了一个擂台上，最初身边有一个容量为
<span class="math inline">\(k\)</span> 的包包。</p>
<p>擂台赛一共有 <span class="math inline">\(n\)</span>
项挑战，各项挑战依次进行。第 <span class="math inline">\(i\)</span>
项挑战有一个属性 <span class="math inline">\(a_i\)</span>，如果 <span
class="math inline">\(a_i \ge
0\)</span>，表示这次挑战成功后可以再获得一个容量为 <span
class="math inline">\(a_i\)</span> 的包包；如果 <span
class="math inline">\(a_i=-1\)</span>，则表示这次挑战成功后可以得到一个大小为
<span class="math inline">\(1\)</span>
的地图残片。地图残片必须装在包包里才能带出擂台，包包没有必要全部装满，但是队员们必须把获得的所有的地图残片都带走（没有得到的不用考虑，只需要完成所有
<span class="math inline">\(n\)</span>
项挑战后背包容量足够容纳地图残片即可），才能拼出完整的地图。并且他们至少要挑战成功
<span class="math inline">\(l\)</span> 次才能离开擂台。</p>
<p>队员们一筹莫展之时，善良的守卫者 Nizem
帮忙预估出了每项挑战成功的概率，其中第 <span
class="math inline">\(i\)</span> 项挑战成功的概率为 <span
class="math inline">\(p_i\%\)</span>。现在，请你帮忙预测一下，队员们能够带上他们获得的地图残片离开擂台的概率。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题可 DP 解决。我们设 <span class="math inline">\(f_{i, j,
m}\)</span> 为遍历到第 <span class="math inline">\(i\)</span>
次挑战时，成功了 <span class="math inline">\(j\)</span> 次，剩余背包为
<span class="math inline">\(m\)</span> 时的概率。<span
class="math inline">\(m\)</span>
可以为负，可从计入答案的后面成功的挑战中补回来。</p>
<p>最终答案为 <span class="math inline">\(\sum\limits_{i =
l}^n{\sum\limits_{j \ge 0}{f_{n, i, j}}}\)</span>。</p>
<p>显然状态转移方程如下：</p>
<p><span class="math display">\[
f_{i, j + 1, m + a_i} = f_{i, j + 1, m + a_i} + f_{i - 1, j, m} \times
p_i \\
f_{i, j, m} = f_{i, j, m} + f_{i - 1, j, m} \times (1 - p_i)
\]</span></p>
<p>在写代码的时候可以优化两点：</p>
<ul>
<li>为避免下标为负，可将所有下标 <span class="math inline">\(m\)</span>
增加一个常值 <span class="math inline">\(\text{MAXN}\)</span>。</li>
<li>为避免越界，可将背包边界限定为 <span
class="math inline">\(\text{MAXN} +
n\)</span>，限定为该值可在不越界的情况下统计答案时将所有的合法背包容量统计纳入统计。</li>
</ul>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, l, k;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> p[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;l, &amp;k);</span><br><span class="line">    k += MAXN;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;p[i]);</span><br><span class="line">        p[i] /= <span class="number">100.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> f[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>][<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][k] = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> left = k, right = k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> m = left; m &lt;= right; m++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i - <span class="number">1</span>][j][m] != <span class="number">0</span>) &#123;</span><br><span class="line">                    f[i][j + <span class="number">1</span>][std::<span class="built_in">min</span>(MAXN + n, m + a[i])] += f[i - <span class="number">1</span>][j][m] * p[i];</span><br><span class="line">                    f[i][j][m] += f[i - <span class="number">1</span>][j][m] * (<span class="number">1.0</span> - p[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">-1</span>) left--;</span><br><span class="line">        <span class="keyword">else</span> right += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">double</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = MAXN; j &lt;= right; j++) &#123;</span><br><span class="line">            ans += f[n][i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.6f\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>Tyvj</tag>
        <tag>BZOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>位运算学习笔记</title>
    <url>/bitwise-operator-notes/</url>
    <content><![CDATA[<blockquote>
<p>《<算法竞赛进阶指南> 0x01 位运算》读后感</p>
</blockquote>
<h1 id="补码">补码</h1>
<p>计算机中的整数均使用补码存储，位运算时也不例外。</p>
<p>故十六进制中大于 0x7FFFFFFF 时就为负数。</p>
<p>在 <code>memset(src, val, len)</code> 中是将 <code>val</code>
不停循环地填入 <code>src</code>，且 0x00 &lt; <code>val</code> &lt;
0xFF。</p>
<p>故可以将 0x3F 定义为一个很大的数，即为 <code>INF</code>。</p>
<span id="more"></span>
<h1 id="位运算的妙用">位运算的妙用</h1>
<h2 id="快速幂">快速幂</h2>
<p>当计算 <span class="math inline">\(a^b\)</span> 时 <span
class="math inline">\(b\)</span> 可以被分成 <span
class="math inline">\(b = x_0 \times 2^0 + x_1 \times 2^1 + x_2 \times
2^2 + \cdots + x_n \times 2^n\)</span>，故可以用位运算剥离 <span
class="math inline">\(b\)</span> 在二进制下的位数，代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">power</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b,<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span> % p;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ((<span class="type">long</span> <span class="type">long</span>)ans * a) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        a = ((<span class="type">long</span> <span class="type">long</span>)a * a) % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二进制状态压缩">二进制状态压缩</h1>
<p>一个集合中的元素可以使用 <code>1</code> 表示选择，用 <code>0</code>
表示不选择。</p>
<p>故当拥有一个 <span class="math inline">\(n\)</span>
个元素的集合时，可使用一个位数为 <span class="math inline">\(n\)</span>
的二进制数来枚举全部的子集，即为 <span
class="math inline">\(2^n\)</span> 的十进制数。</p>
<p>此时可以用一个整型数代替布尔数组，也可以使用一个整型数枚举全排列。</p>
<p>下面的列表列举了常用操作。</p>
<table>
<colgroup>
<col style="width: 75%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th>操作</th>
<th>运算（运算符为 C++）</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>取出整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位</td>
<td><code>（n &gt;&gt; k） &amp; 1</code></td>
</tr>
<tr class="even">
<td>取出整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(0 \sim k - 1\)</span> 位（后 <span
class="math inline">\(k\)</span> 位）</td>
<td><code>n &amp; ((1 &lt;&lt; k) - 1)</code></td>
</tr>
<tr class="odd">
<td>把整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位取反</td>
<td><code>n ^ (1 &lt;&lt; k)</code></td>
</tr>
<tr class="even">
<td>对整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位赋值 <span
class="math inline">\(1\)</span></td>
<td><code>n \| (1 &lt;&lt; k)</code></td>
</tr>
<tr class="odd">
<td>对整数 <span class="math inline">\(n\)</span> 在二进制表示下的第
<span class="math inline">\(k\)</span> 位赋值 <span
class="math inline">\(0\)</span></td>
<td><code>n &amp; (~(1 &lt;&lt; k))</code></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1738C」Even Number Addicts - 博弈论</title>
    <url>/cf-1738c/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1738/C">Codeforces
链接</a></p>
<p>Alice 和 Bob 玩一个游戏，这个游戏中有一个有 <span
class="math inline">\(n\)</span> 项的序列 <span
class="math inline">\(a\)</span>，Alice 先手，两人轮流在 <span
class="math inline">\(a\)</span> 中取走一个数。若最终取完后 Alice
取走的数的和为偶数则 Alice 获胜，否则 Bob
获胜。若两人均按最优策略决策，求出最终的获胜方。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>目前问题过于复杂，我们可以先考虑一个简单问题：若序列 <span
class="math inline">\(n\)</span> 中只有奇数，谁会赢？</p>
<p>这个问题答案显然。若 <span class="math inline">\(n \bmod 4 =
1\)</span> 或 <span class="math inline">\(n \bmod 4 = 2\)</span> 时 Bob
赢，否则 Alice 赢。</p>
<p>接下来我们把偶数加进来，我们设奇数个数为 <span
class="math inline">\(\text{cnt1}\)</span>，偶数个数为 <span
class="math inline">\(\text{cnt0}\)</span>。对于 <span
class="math inline">\(\text{cnt0} \bmod 2 = 0\)</span> 的情况与 <span
class="math inline">\(n\)</span>
全为奇数的情况相同。因为只要其中有一个人选了偶数，则下一个人立即选偶数，相当于转化为
<span class="math inline">\(\text{cnt0} - 2\)</span>
的局面，这样周而复始可将 <span
class="math inline">\(\text{cnt0}\)</span> 消为 <span
class="math inline">\(0\)</span>。且后手跟着先手选偶数的抉择对于 Alice
和 Bob 均是最优策略。</p>
<p>接下来我们考虑 <span class="math inline">\(\text{cnt0} \bmod 2 =
1\)</span> 的情况。我们依然可以将 <span
class="math inline">\(\text{cnt1} \bmod 4\)</span> 的情况分类讨论：当
<span class="math inline">\(\text{cnt1} \bmod 4 = 1\)</span> 时，Alice
最优策略是取走“唯一的”偶数，然后 Alice 必胜；当 <span
class="math inline">\(\text{cnt1} \bmod 4 = 0\)</span> 或 <span
class="math inline">\(\text{cnt1} \bmod 4 = 3\)</span> 时，Alice
最优策略是无论如何都不取“唯一的”偶数，然后 Alice 必胜；当 <span
class="math inline">\(\text{cnt1} \bmod 4 = 2\)</span> 时，无论 Alice
取不取“唯一的”偶数，Bob 都必胜。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">int</span> cnt0 = <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        <span class="keyword">if</span> (a % <span class="number">2</span>)</span><br><span class="line">            cnt1++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cnt0++;</span><br><span class="line">        cnt0 &amp;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt0 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cnt1 % <span class="number">4</span> == <span class="number">1</span> || cnt1 % <span class="number">4</span> == <span class="number">2</span>))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cnt1 % <span class="number">4</span> == <span class="number">1</span> || cnt1 % <span class="number">4</span> == <span class="number">3</span> || cnt1 % <span class="number">4</span> == <span class="number">0</span>))</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ 2259」新型计算机 - 最短路</title>
    <url>/bzoj-2259/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://hydro.ac/d/bzoj/p/2259">HydroOJ 链接</a></p>
<p>Tim
正在摆弄着他设计的“计算机”，他认为这台计算机原理很独特，因此利用它可以解决许多难题。
但是，有一个难题他却解决不了，是这台计算机的输入问题。新型计算机的输入也很独特，假设输入序列中有一些数字（都是自然数——自然数包括
<span class="math inline">\(0\)</span> ），计算机先读取第一个数字 <span
class="math inline">\(s_1\)</span> ，然后顺序向后读入 <span
class="math inline">\(s_1\)</span> 个数字。接着再读一个数字 <span
class="math inline">\(s_2\)</span> ，顺序向后读入 <span
class="math inline">\(s_2\)</span>
个数字……依此类推。不过只有计算机正好将输入序列中的数字读完，它才能正确处理数据，否则计算机就会进行自毁性操作！</p>
<p>Tim
现在有一串输入序列。但可能不是合法的，也就是可能会对计算机造成破坏。于是他想对序列中的每一个数字做一些更改，加上一个数或者减去一个数，当然，仍然保持其为自然数。使得更改后的序列为一个新型计算机可以接受的合法序列。</p>
<p>不过 Tim
还希望更改的总代价最小，所谓总代价，就是对序列中每一个数操作的参数的绝对值之和。</p>
<p>写一个程序：</p>
<ol type="1">
<li>从文件中读入原始的输入序列；</li>
<li>计算将输入序列改变为合法序列需要的最小代价；</li>
<li>向输出文件打印结果。</li>
</ol>
<p><span class="math inline">\(100\%\)</span> 的数据满足：<span
class="math inline">\(n &lt; 1 \times 10^6 + 1\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这是图论问题。我们可以抽象成对于一个序列 <span
class="math inline">\(\{a_n\}\)</span>，可从 <span
class="math inline">\(i\)</span> 跳到 <span class="math inline">\(i +
a_i + 1\)</span>，要求跳到 <span class="math inline">\(n +
1\)</span>。可以对 <span class="math inline">\(a_i\)</span>
修改，代价为修改的绝对值，问最小代价。</p>
<p>我们可以连边 <span class="math inline">\(i
\stackrel{0}{\longrightarrow} i + a_i + 1\)</span>，即从 <span
class="math inline">\(i\)</span> 到 <span class="math inline">\(i + a_i
+ 1\)</span> 的权值为 <span class="math inline">\(0\)</span>
的边。对于修改，我们可以对于 <span class="math inline">\(\forall i \in
(1, n]\)</span>，连边 <span class="math inline">\(i
\stackrel{1}{\longrightarrow} i + 1\)</span>、<span
class="math inline">\(i \stackrel{1}{\longrightarrow} i - 1\)</span>
即可模拟修改过程。而对于修改超出 <span class="math inline">\(n\)</span>
的，即 <span class="math inline">\(i + a_i + 1 &gt;
n\)</span>，我们可以连边 <span class="math inline">\(i \stackrel{i + a_i
- n}{\longrightarrow} n + 1\)</span>。</p>
<p>最后求最短路即可，可以用堆优化的
Dijkstra。本题略卡常，加个快读快写可过。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e6</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> d;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">&#125; N[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, t;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(s, t, w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">const</span> <span class="type">int</span> s, <span class="type">const</span> <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) N[i].d = INT_MAX;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::priority_queue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, std::greater&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; q;</span><br><span class="line">    N[s].d = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, s));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> v = p.second;</span><br><span class="line">        <span class="keyword">if</span> (N[v].v) <span class="keyword">continue</span>;</span><br><span class="line">        N[v].v = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Edge &amp;e : N[v].e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N[e.t].d &gt; N[v].d + e.w) &#123;</span><br><span class="line">                N[e.t].d = N[v].d + e.w;</span><br><span class="line">                q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(N[e.t].d, e.t));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> N[t].d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">IO</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE (1 &lt;&lt; 20)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> isdigit(x) (x &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; x &lt;= <span class="string">&#x27;9&#x27;</span>)</span></span><br><span class="line">    <span class="type">char</span> buf[MAXSIZE], *p1, *p2;</span><br><span class="line">    <span class="type">char</span> pbuf[MAXSIZE], *pp;</span><br><span class="line">    <span class="built_in">IO</span>() : <span class="built_in">p1</span>(buf), <span class="built_in">p2</span>(buf), <span class="built_in">pp</span>(pbuf) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">IO</span>() &#123; <span class="built_in">fwrite</span>(pbuf, <span class="number">1</span>, pp - pbuf, stdout); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">gc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p1 == p2) p2 = (p1 = buf) + <span class="built_in">fread</span>(buf, <span class="number">1</span>, MAXSIZE, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2 ? <span class="string">&#x27; &#x27;</span> : *p1++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">blank</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch == <span class="string">&#x27; &#x27;</span> || ch == <span class="string">&#x27;\n&#x27;</span> || ch == <span class="string">&#x27;\r&#x27;</span> || ch == <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> tmp = <span class="number">1</span>;</span><br><span class="line">        <span class="type">bool</span> sign = <span class="number">0</span>;</span><br><span class="line">        x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">        <span class="keyword">for</span> (; !<span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>())</span><br><span class="line">            <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>()) x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">            <span class="keyword">for</span> (ch = <span class="built_in">gc</span>(); <span class="built_in">isdigit</span>(ch); ch = <span class="built_in">gc</span>())</span><br><span class="line">                tmp /= <span class="number">10.0</span>, x += tmp * (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (sign) x = -x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> ch = <span class="built_in">gc</span>();</span><br><span class="line">        <span class="keyword">for</span> (; <span class="built_in">blank</span>(ch); ch = <span class="built_in">gc</span>()) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (; !<span class="built_in">blank</span>(ch); ch = <span class="built_in">gc</span>()) *s++ = ch;</span><br><span class="line">        *s = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">read</span><span class="params">(<span class="type">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (c = <span class="built_in">gc</span>(); <span class="built_in">blank</span>(c); c = <span class="built_in">gc</span>()) <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> <span class="type">char</span> &amp;c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pp - pbuf == MAXSIZE) <span class="built_in">fwrite</span>(pbuf, <span class="number">1</span>, MAXSIZE, stdout), pp = pbuf;</span><br><span class="line">        *pp++ = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) x = -x, <span class="built_in">push</span>(<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="type">static</span> T sta[<span class="number">35</span>];</span><br><span class="line">        T top = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sta[top++] = x % <span class="number">10</span>, x /= <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x);</span><br><span class="line">        <span class="keyword">while</span> (top) <span class="built_in">push</span>(sta[--top] + <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">write</span><span class="params">(T x, <span class="type">char</span> lastChar)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">write</span>(x), <span class="built_in">push</span>(lastChar);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; io;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    io.<span class="built_in">read</span>(n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        io.<span class="built_in">read</span>(a);</span><br><span class="line">        <span class="keyword">if</span> (i + a &lt;= n) <span class="built_in">addEdge</span>(i, i + a + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">addEdge</span>(i, n + <span class="number">1</span>, i + a - n);</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">addEdge</span>(i, i + <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">addEdge</span>(i, i - <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    io.<span class="built_in">write</span>(<span class="built_in">dijkstra</span>(<span class="number">1</span>, n + <span class="number">1</span>), <span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>「BZOJ 3687」简单题 - 位运算</title>
    <url>/bzoj-3687/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://hydro.ac/d/bzoj/p/3687">HydroOJ 链接</a></p>
<p>求一个有 <span class="math inline">\(n\)</span> 的元素的可重数集
<span class="math inline">\(\{a_i\}\)</span>
的子集的算术和的异或和。</p>
<p>数据范围：<span class="math inline">\(a_i &gt; 0\)</span>，<span
class="math inline">\(1 &lt; n &lt; 1000\)</span>，<span
class="math inline">\(\sum a_i \le 2000000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题有一种位运算的妙解。</p>
<p>首先对于 <span class="math inline">\(\sum a_i \le
2000000\)</span>，我们可以直接开一个大小为 <span
class="math inline">\(2000000\)</span> 的 <code>bitset</code>
来存储算术和的情况。</p>
<p>定义 <span class="math inline">\(f_i\)</span> 表示算术和 <span
class="math inline">\(i\)</span> 是否对答案有效。由于最终为异或和，当
<span class="math inline">\(i\)</span> 出现次数为偶数时，我们就可忽略
<span class="math inline">\(i\)</span>，即 <span
class="math inline">\(f_i = \text{false}\)</span>。</p>
<p>每对于一个新增的数 <span
class="math inline">\(a\)</span>，我们有两种情况：</p>
<ul>
<li>算术和没有 <span class="math inline">\(a\)</span>，则 <span
class="math inline">\(f\)</span> 保持原样。</li>
<li>算数和有 <span class="math inline">\(a\)</span>，则对于 <span
class="math inline">\(f\)</span> 中所有为 <code>true</code> 的情况加上
<code>a</code>。反应在 <code>bitset</code> 上为
<code>f &lt;&lt; a</code>。</li>
</ul>
<p>将两者异或就可得出 <code>f</code> 中的反映到 <code>a</code>
的所有算术和情况。最后将 <code>f</code> 中所有为 <code>true</code>
的情况求异或和即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXS = <span class="number">2000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::bitset&lt;MAXS + 1&gt; f;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line">        sum += a;</span><br><span class="line">        f ^= (f &lt;&lt; a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= sum; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (f[i]) &#123;</span><br><span class="line">            ans ^= i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>BZOJ</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1739C」Card Game - 组合数学 + 博弈论</title>
    <url>/cf-1739c/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1739/C">Codeforces
链接</a></p>
<p>Alice 和 Bob 玩游戏，游戏中有 <span class="math inline">\(n\)</span>
张标有 <span class="math inline">\(1 \sim n\)</span> 数字卡牌（<span
class="math inline">\(n\)</span> 为偶数），开局时 Alice 和 Bob 均有
<span class="math inline">\(\frac{n}{2}\)</span>
张。在每一轮中，其中一人先打出自己一张卡牌，然后另一人再打出自己的一张卡牌。若后手无法打出比前一人打出卡牌数字大的卡牌，则后手输；否则进入下一轮。该轮的后手为下一轮的先手。若卡牌打完则平局。在这个游戏中，Alice
为第一轮的先手。假设双方均按最优策略出牌，求 Alice 赢、Bob
赢和平局的情况数。答案对 <span class="math inline">\(998244353\)</span>
取模。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于每一轮，我们显然可以得出：若先手有目前双方未打出的最大的牌，则先手打出这张牌必胜，否则后手可打出更大的牌结束该轮。于是我们只考虑最大的牌和次大的牌，分别分情况讨论：</p>
<ol type="1">
<li>先手拥有最大的牌，则先手必胜；</li>
<li>后手同时拥有最大的牌和次大的牌，则先手必输；</li>
<li>先手拥有次大的牌，后手拥有最大的牌，此时的最优策略是先手打掉次大的牌，后手打掉最大的牌，进入下一轮。</li>
</ol>
<p>对于每一种情况，我们用组合数学求出即可。我们存储 Alice 和 Bob
赢的情况，将 <span class="math inline">\(n\)</span>
从大到小两两一组讨论，假设最大牌为 <span
class="math inline">\(i\)</span>：</p>
<ol type="1">
<li>对于情况 <span class="math inline">\(1\)</span>，先手获胜情况数加
<span class="math inline">\({i - 1 \choose \frac{n}{2} - 1 - \frac{n -
i}{2}}\)</span>，即先手的剩下的卡牌为在 <span class="math inline">\(i -
1\)</span> 个数中选择的情况数；</li>
<li>对于情况 <span class="math inline">\(2\)</span>，后手获胜情况数加
<span class="math inline">\({i - 2 \choose \frac{n}{2} - \frac{n -
i}{2}}\)</span>，即后手的剩下的卡牌在 <span class="math inline">\(i -
2\)</span> 个数中选择的情况数。</li>
</ol>
<p>每讨论完一组就换先手继续讨论。平局的情况数显然为 <span
class="math inline">\(1\)</span>，这样我们就可以得出获胜的情况数了。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">60</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> fac[MAXN + <span class="number">1</span>], inv[MAXN + <span class="number">1</span>], facInv[MAXN + <span class="number">1</span>], f[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">C</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || k &gt; n) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> fac[n] * facInv[k] % MOD * facInv[n - k] % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">lucas</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!k) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">C</span>(n % MOD, k % MOD) * <span class="built_in">lucas</span>(n / MOD, k / MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) fac[i] = fac[i - <span class="number">1</span>] * i % MOD;</span><br><span class="line"></span><br><span class="line">    inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) inv[i] = ((-(MOD / i) * inv[MOD % i]) % MOD + MOD) % MOD;</span><br><span class="line"></span><br><span class="line">    facInv[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) facInv[i] = facInv[i - <span class="number">1</span>] * inv[i] % MOD;</span><br><span class="line"></span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>, f[<span class="number">1</span>] = <span class="number">0</span>, f[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">3</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        f[i] = (i - <span class="number">1</span>) * (f[i - <span class="number">1</span>] + f[i - <span class="number">2</span>]) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans1 = <span class="number">0</span>, ans2 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; i -= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            ans1 = (ans1 + <span class="built_in">lucas</span>(i - <span class="number">1</span>, n / <span class="number">2</span> - <span class="number">1</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">            ans2 = (ans2 + <span class="built_in">lucas</span>(i - <span class="number">2</span>, n / <span class="number">2</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans2 = (ans2 + <span class="built_in">lucas</span>(i - <span class="number">1</span>, n / <span class="number">2</span> - <span class="number">1</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">            ans1 = (ans1 + <span class="built_in">lucas</span>(i - <span class="number">2</span>, n / <span class="number">2</span> - (n - i) / <span class="number">2</span>)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        flag ^= <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld 1\n&quot;</span>, ans1, ans2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>博弈论</tag>
        <tag>Codeforces</tag>
        <tag>组合数学</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1753C」Wish I Knew How to Sort - 概率与期望</title>
    <url>/cf-1753c/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1753/C">Codeforces
链接</a></p>
<p>你有一个只含 <span class="math inline">\(0\)</span> 和 <span
class="math inline">\(1\)</span> 的 <span
class="math inline">\(n\)</span>
位序列，你需要将这个序列排序。对于这个序列，你每次可以随机地选择两个数进行交换，求将这个序列排好序所交换次数的期望
<span class="math inline">\(\mod 998244353\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题求的是期望步数，可考虑使用 DP 解决。我们统计这个序列中有 <span
class="math inline">\(\text{cnt}\)</span> 个 <span
class="math inline">\(0\)</span>，于是这个问题可以转化为将所有的 <span
class="math inline">\(0\)</span> 移动到前 <span
class="math inline">\(\text{cnt}\)</span> 位需要的步数的期望。我们设
<span class="math inline">\(f_i\)</span> 表示前 <span
class="math inline">\(\text{cnt}\)</span> 位有 <span
class="math inline">\(i\)</span> 个 <span
class="math inline">\(0\)</span> 的情况下排好序所需要的期望步数，显然
<span class="math inline">\(f_\text{cnt} = 0\)</span>。如果我们将 <span
class="math inline">\(f_i\)</span> 状态变化为 <span
class="math inline">\(f_{i + 1}\)</span> 状态，我们需要将前 <span
class="math inline">\(\text{cnt}\)</span> 位中的一个 <span
class="math inline">\(1\)</span> 和后 <span
class="math inline">\(\text{n - cnt}\)</span> 位的一个 <span
class="math inline">\(0\)</span> 进行交换。选出这对的概率为 <span
class="math inline">\(p = \frac{(\text{cnt} - i) \times (\text{cnt} -
i)}{ \frac{n \times (n - 1)}{2} } = \frac{2 \times (\text{cnt} - i)^2}{n
\times (n -
1)}\)</span>。于是我们可以通过期望的线性性质得到以下的状态转移方程：</p>
<p><span class="math display">\[
\begin{align*}
f_i &amp;= p \times f_{i + 1} + (1 - p) \times f_i + 1 \\
f_i &amp;= f_{i + 1} + \frac{n \times (n - 1)}{2 \times (\text{cnt} -
i)^2}
\end{align*}
\]</span></p>
<p>状态转移方程的除法可以用快速幂求逆元解决。最后我们统计原序列中前
<span class="math inline">\(\text{cnt}\)</span> 项中有 <span
class="math inline">\(\text{now}\)</span> 个 <span
class="math inline">\(0\)</span>，答案即为 <span
class="math inline">\(f_\text{now}\)</span>。时间复杂度为 <span
class="math inline">\(O(kn), k = \log 998244353\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">pow</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n, <span class="type">const</span> <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> num = n, t = k; t; num = num * num % MOD, t &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans = ans * num % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>, now = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="keyword">if</span> (a[i] == <span class="number">0</span>) cnt++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; cnt; i++) <span class="keyword">if</span> (a[i] == <span class="number">0</span>) now++;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">f</span><span class="params">(cnt + <span class="number">1</span>)</span></span>;</span><br><span class="line">    f[cnt] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = cnt - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        f[i] = (f[i + <span class="number">1</span>] + (<span class="number">1ll</span> * n * (n - <span class="number">1</span>) % MOD * <span class="built_in">pow</span>(<span class="number">2</span>, MOD - <span class="number">2</span>) % MOD * <span class="built_in">pow</span>(cnt - i, MOD - <span class="number">2</span>) % MOD * <span class="built_in">pow</span>(cnt - i, MOD - <span class="number">2</span>) % MOD)) % MOD;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, f[now]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>数学</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1746D」Paths on the Tree - 贪心</title>
    <url>/cf-1746d/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/1746/D">Codeforces
链接</a></p>
<p>给定一个 <span class="math inline">\(n\)</span>
个节点的树，其节点被标记为 <span class="math inline">\(1\)</span> 到
<span class="math inline">\(n\)</span>，而且该树的根为 <span
class="math inline">\(1\)</span>，另外也给定一个积分序列 <span
class="math inline">\(s\)</span></p>
<p>如果下列两个条件都满足，则我们称路径集合k可用：</p>
<ul>
<li><p>该集合内所有路径从 <span class="math inline">\(1\)</span>
开始</p></li>
<li><p><span class="math inline">\(c_i\)</span> 为覆盖节点 <span
class="math inline">\(i\)</span>
的路径数量，对于每对拥有同个父节点的节点 <span
class="math inline">\((u,v)\)</span>，要求<span
class="math inline">\(|c_u-c_v|\)</span> 小于等于1</p></li>
</ul>
<p>对于每个路径集合，其权值被定义为 <span
class="math inline">\(\sum\limits_{i=1}^n{c_i s_i}\)</span></p>
<p>显而易见，每组数据至少有一个可用的路径集合，找出所有可用路径集合中的最大权值</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然为了让答案最大，每条路径都会走到叶子节点。于是我们可以考虑每条路径对每一层的影响。显然对于度为
<span class="math inline">\(a\)</span> 的节点 <span
class="math inline">\(u\)</span> 被覆盖 <span
class="math inline">\(k\)</span> 次，每个节点要么被覆盖 <span
class="math inline">\(\lfloor \frac{k}{a} \rfloor\)</span>
次，要么被覆盖 <span class="math inline">\(\lfloor \frac{k}{a} \rfloor +
1\)</span> 次，且被被覆盖 <span class="math inline">\(\lfloor
\frac{k}{a} \rfloor + 1\)</span> 次的节点有 <span
class="math inline">\(k \bmod a\)</span> 个。于是我们可以先将每个点覆盖
<span class="math inline">\(\lfloor \frac{k}{a} \rfloor\)</span>
次。接下来再处理被覆盖 <span class="math inline">\(\lfloor \frac{k}{a}
\rfloor + 1\)</span> 次的情况。</p>
<p>处理被覆盖 <span class="math inline">\(\lfloor \frac{k}{a} \rfloor +
1\)</span> 次的情况时，我们可以从从叶子到根的方向考虑。我们直接进行 DFS
寻找剩余路径。显然对于边 <span class="math inline">\(u \rightarrow
v\)</span>，到达 <span class="math inline">\(v\)</span>
的路径中只有一条对 <span class="math inline">\(u\)</span>
有效，为使答案最大，我们取权值最大的一条路径，其余的路径到 <span
class="math inline">\(u\)</span> 就截止了，记录进答案即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;Node *&gt; adj;</span><br><span class="line">    <span class="type">int</span> deg, remain;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> s;</span><br><span class="line">    std::priority_queue&lt;<span class="type">long</span> <span class="type">long</span>&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;adj.<span class="built_in">push_back</span>(v);</span><br><span class="line">    u-&gt;deg++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *u, <span class="type">long</span> <span class="type">long</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!u-&gt;adj.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> size = u-&gt;adj.<span class="built_in">size</span>();</span><br><span class="line">        ans += k / size * size * u-&gt;s;</span><br><span class="line">        <span class="keyword">for</span> (Node *v : u-&gt;adj) <span class="built_in">dfs1</span>(v, k / size);</span><br><span class="line">        u-&gt;remain = k % size;</span><br><span class="line">    &#125; <span class="keyword">else</span> ans += k * u-&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;deg == <span class="number">0</span>) u-&gt;q.<span class="built_in">push</span>(u-&gt;s);</span><br><span class="line">    <span class="keyword">for</span> (Node *v : u-&gt;adj) &#123;</span><br><span class="line">        <span class="built_in">dfs2</span>(v);</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;q.<span class="built_in">empty</span>()) u-&gt;q.<span class="built_in">push</span>(v-&gt;q.<span class="built_in">top</span>() + u-&gt;s);</span><br><span class="line">        <span class="keyword">while</span> (!v-&gt;q.<span class="built_in">empty</span>()) v-&gt;q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;remain--) &#123;</span><br><span class="line">        ans += u-&gt;q.<span class="built_in">top</span>();</span><br><span class="line">        u-&gt;q.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[--p], &amp;nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;nodes[i].s);</span><br><span class="line"></span><br><span class="line">    ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(&amp;nodes[<span class="number">0</span>], k);</span><br><span class="line">    <span class="built_in">dfs2</span>(&amp;nodes[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 1738D」Permutation Addicts - 图论 + DFS</title>
    <url>/cf-1738d/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/contest/1738/problem/D">Codeforces
链接</a></p>
<p>有一个 <span class="math inline">\(n\)</span> 个数的排列 <span
class="math inline">\(a\)</span> 和一个数 <span class="math inline">\(k
(0 \le k \le n)\)</span>，你计算出了一个有 <span
class="math inline">\(n\)</span> 个数的序列 <span
class="math inline">\(b\)</span>，计算方法如下：</p>
<ul>
<li>当 <span class="math inline">\(a_i \le k\)</span> 时，若存在 <span
class="math inline">\(a_j &gt; k (1 \le j &lt; i)\)</span> 且 <span
class="math inline">\(i - j\)</span> 最小，则 <span
class="math inline">\(b_{a_i} = a_j\)</span>，否则 <span
class="math inline">\(b_{a_i} = n + 1\)</span>；</li>
<li>当 <span class="math inline">\(a_i &gt; k\)</span> 时，若存在 <span
class="math inline">\(a_j \le k (1 \le j &lt; i)\)</span> 且 <span
class="math inline">\(i - j\)</span> 最小，则 <span
class="math inline">\(b_{a_i} = a_j\)</span>，否则 <span
class="math inline">\(b_{a_i} = 0\)</span>。</li>
</ul>
<p>目前你知道 <span class="math inline">\(b\)</span> 与 <span
class="math inline">\(n\)</span>，请求出任意一种 <span
class="math inline">\(a\)</span> 及对应的 <span
class="math inline">\(k\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>分析可得对于 <span class="math inline">\(i \le k\)</span>，满足 <span
class="math inline">\(b_i &gt; i\)</span>；对于 <span
class="math inline">\(i &gt; k\)</span>，满足 <span
class="math inline">\(b_i &lt; i\)</span>。证明显然。这样我们可求出
<span class="math inline">\(k\)</span>。</p>
<p>对于每个 <span class="math inline">\(b_i\)</span>，若 <span
class="math inline">\(i \neq n + 1\)</span> 且 <span
class="math inline">\(i \neq 0\)</span>，显然 <span
class="math inline">\(b_i\)</span> 在 <span
class="math inline">\(i\)</span> 的后面，若有 <span
class="math inline">\(m\)</span> 个 <span class="math inline">\(b_i =
0\)</span> 或 <span class="math inline">\(b_i = n + 1\)</span>，则这
<span class="math inline">\(m\)</span> 个数必定在前 <span
class="math inline">\(m\)</span> 位，且 <span class="math inline">\(b_i
= 0\)</span> 和 <span class="math inline">\(b_i = n + 1\)</span>
两者必定有且只有一者出现。于是我们可以直接建树，连边 <span
class="math inline">\(i \rightarrow b_i\)</span>，然后对 <span
class="math inline">\(0\)</span> 或 <span class="math inline">\(n +
1\)</span> 进行 DFS 即可。对于一个节点 <span
class="math inline">\(u\)</span>，它的子节点中若有以节点 <span
class="math inline">\(v\)</span> 为根的子树大于 <span
class="math inline">\(1\)</span>，就最后遍历 <span
class="math inline">\(v\)</span>
即可。显然对于每个节点至多只有一个子节点为根的子树大小大于 <span
class="math inline">\(1\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, p;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> p) : <span class="built_in">p</span>(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::pair&lt;<span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;&gt; e[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    e[p].first = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (e[p].second.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) e[p].first += <span class="built_in">dfs1</span>(each);</span><br><span class="line">    <span class="keyword">return</span> e[p].first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="number">0</span> &amp;&amp; p != n + <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, p);</span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) max = std::<span class="built_in">max</span>(max, e[each].first);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[each].first != max) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(each);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[p].second) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e[each].first == max) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(each);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> b[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        <span class="keyword">if</span> (b[i] &gt; i) k = i;</span><br><span class="line">        <span class="keyword">if</span> (b[i] == <span class="number">0</span>) flag = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n + <span class="number">1</span>; i++) e[i].second.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[b[i]].second.<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(n + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">dfs1</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">dfs2</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>图论</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 219D」Choosing Capital for Treeland - 树形 DP</title>
    <url>/cf-219d/</url>
    <content><![CDATA[<h1 id="题目描述">题目描述</h1>
<p><a href="https://codeforces.com/problemset/problem/219/D">Codeforces
链接</a></p>
<p>Treeland 国有 <span class="math inline">\(n\)</span> 个城市，这 <span
class="math inline">\(n\)</span> 个城市连成了一颗树，有 <span
class="math inline">\(n - 1\)</span>
条道路连接了所有城市。每条道路只能单向通行。现在政府需要决定选择哪个城市为首都。假如城市
i
成为了首都，那么为了使首都能到达任意一个城市，不得不将一些道路翻转方向，记翻转道路的条数为
<span class="math inline">\(k\)</span>。你的任务是找到所有满足 <span
class="math inline">\(k\)</span> 最小的首都。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题我们可以考虑使用树形 DP 解决。</p>
<h2 id="dp-求解">DP 求解</h2>
<p>首先我们选定任意一个节点为这棵树的根，这里我们以 <span
class="math inline">\(1\)</span> 节点为例。</p>
<p>接着跑一遍 DP，此时 DP
存储的是从这个节点出发，到达该节点为根的子树中的所有节点所需要最少翻转道路的次数。</p>
<p>显然我们可以推出下列状态转移方程（<span
class="math inline">\(f_i\)</span> 中 <span
class="math inline">\(i\)</span> 表示节点，<span
class="math inline">\(e\)</span> 表示子以 <span
class="math inline">\(i\)</span> 为根的子树中从 <span
class="math inline">\(i\)</span> 出发的边的集合，<span
class="math inline">\(eRev\)</span> 表示子以 <span
class="math inline">\(i\)</span> 为根的子树中指向 <span
class="math inline">\(i\)</span> 的边的集合）：</p>
<p><span class="math display">\[
f_i =
\begin{cases}
f_j &amp; j \in e \\
f_j + 1 &amp; j \in eRev
\end{cases}
\]</span></p>
<p>此时 <span class="math inline">\(f_1\)</span> 则为以 <span
class="math inline">\(1\)</span> 为首都的答案。</p>
<h2 id="换根">换根</h2>
<p>虽然我们可以以每一个点为首都，分别 DP
一次得解，但这种方法的时间复杂度是 <span
class="math inline">\(O(n^2)\)</span>，并不理想。故我们可考虑用其他方法求解。</p>
<p>基于上面以 <span class="math inline">\(1\)</span> 为首都的
DP，我们可以在此数据上 <strong>换根</strong>
以求出以其他节点为首都的答案。</p>
<p>对于换根，我们可以从 <span class="math inline">\(1\)</span>
节点开始跑第二遍 DP。</p>
<p>仍然以 <span class="math inline">\(1\)</span> 为根，我们初始化 <span
class="math inline">\(g_1 = f_1\)</span>，其中 <span
class="math inline">\(g_i\)</span> 表示以 <span
class="math inline">\(i\)</span> 为首都至少需要翻转多少条道路。</p>
<p>对于节点 <span class="math inline">\(i\)</span>，若 <span
class="math inline">\(j\)</span> 是 <span
class="math inline">\(i\)</span> 为根的子树中从 <span
class="math inline">\(i\)</span> 出发的边所到达的节点，说明从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 路是反的，从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 比从 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 需要多翻转一条边，答案则为 <span
class="math inline">\(g_i + 1\)</span>；</p>
<p>同理，若 <span class="math inline">\(j\)</span> 是 <span
class="math inline">\(i\)</span> 为根的子树中指向 <span
class="math inline">\(i\)</span> 的边中出发的节点，说明从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 路是正的，从 <span
class="math inline">\(j\)</span> 到 <span
class="math inline">\(i\)</span> 比从 <span
class="math inline">\(i\)</span> 到 <span
class="math inline">\(j\)</span> 需要少翻转一条边，答案则为 <span
class="math inline">\(g_i - 1\)</span>；</p>
<p>换句话说，我们有下列转移方程：</p>
<p><span class="math display">\[
g_i =
\begin{cases}
g_j + 1 &amp; j \in e \\
g_j - 1 &amp; j \in eRev
\end{cases}
\]</span></p>
<p>对于求 <span class="math inline">\(g_j\)</span>
的过程，我们可以形象地想象成这棵树的根从 <span
class="math inline">\(i\)</span> 换到了 <span
class="math inline">\(j\)</span>。我们把这种操作称作
<strong>换根</strong>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">200000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>], eRev[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN + <span class="number">1</span>], ch[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (vis[p]) <span class="keyword">return</span> f[p];</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : e[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            f[p] += <span class="built_in">dp</span>(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : eRev[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            f[p] += <span class="built_in">dp</span>(nodes) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    vis[p] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : e[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            ch[nodes] = ch[p] + <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> nodes : eRev[p]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!vis[nodes]) &#123;</span><br><span class="line">            ch[nodes] = ch[p] - <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(nodes);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">        eRev[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">dp</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(ch, <span class="number">0</span>, <span class="built_in">sizeof</span>(ch));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    ch[<span class="number">1</span>] = f[<span class="number">1</span>];</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ans = std::<span class="built_in">min</span>(ans, ch[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)  &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch[i] == ans) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>Codeforces</tag>
        <tag>树形 DP</tag>
        <tag>换根</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2021 第一轮 行记</title>
    <url>/csp2021-1/</url>
    <content><![CDATA[<p>总觉得应该写些什么……</p>
<h1 id="day-0">Day 0</h1>
<p>今天周六，中午日常去机房，该复习的都复习过了，已经无心复习初赛，只是看了一下图论。</p>
<p>考场设在石室文庙，又勾起了中考考砸的不美好的回忆 QWQ</p>
<p>早上老师正常讲了一下课，中午竞赛来时强调了一些重要事项，下午又上了一些课。</p>
<p>晚上回家已经很晚，最后上床前复习了一下图论和卡特兰数。</p>
<span id="more"></span>
<h1 id="day-1">Day 1</h1>
<p>上午进考场，准备考试（话说洛谷签到签出来大凶是什么意思喂？！）。</p>
<p>考试开始快速浏览了一下卷子，12 页（今年怎么还不用机读卡啊）。</p>
<p>选择题？简单，30 分钟写完。</p>
<p>阅读程序第一个懒得看，直接手动模拟。</p>
<p>？？？</p>
<p>这怎么考了立体几何了啊喂？</p>
<p>高一还没学啊！！！</p>
<p>阅读程序第二题稍微看了一下，两种方法二分求连续子序列的最大和，还算简单。</p>
<p>第三题？手算 base64，不想说了……</p>
<p>最后看了一下填程序，第一题看了一下看得懂，但又不完全懂……</p>
<p>第二题……</p>
<p>什么是卡特兰树？什么是 RMQ 算法？LCA 忘了……</p>
<p>算了算了直接蒙。</p>
<p>最后做完卷子还有 15 分钟，这张卷子实在不想检查了。</p>
<h1 id="day">Day ???</h1>
<p>分数线 50 分，52 分滚粗。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>CSP</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 第二轮 行记</title>
    <url>/csp2022-2/</url>
    <content><![CDATA[<p>寄</p>
<h1 id="省流"><del>省流</del></h1>
<blockquote>
<p>代码</p>
</blockquote>
<img src="/csp2022-2/sb.png" class="">
<blockquote>
<p>题面</p>
</blockquote>
<img src="/csp2022-2/statement.png" class="">
<h1 id="day--3">Day -3</h1>
<p>考点出来了，在七高考试 <del>总算在成都了</del>。</p>
<p>下午练手写了一道 <a
href="https://www.luogu.com.cn/problem/P7506">大模拟</a> <del>然后被 C++
的除法向 0 取整坑了几个小时 QWQ</del></p>
<p>打算明天复习一下模板，避免考试写挂。</p>
<span id="more"></span>
<h1 id="day--2--1-0">Day -2 &amp; -1 &amp; 0</h1>
<p>复习了一下板子，简单刷了几道水题，也把之前的真题看了一下。顺带二刷了《命运石之门0》<del>真的好看</del>。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起床后最后复习了一下板子，不想复习也不想颓废。下午就去考试了。</p>
<p>这次考试全员七高，开车几分钟就到了。然而当时进学校时离考试开始只有
20min 了，就直接进了考场。</p>
<p>进了考场，座位坐在最边上，旁边是 huaruoji。看了一下电脑配置 CPU 是 10
代 i7，配置挺高的。</p>
<p>考试开始前试题发下来了，密码是
<code>belief2022</code>，但愿自己可以和密码想的一样吧。</p>
<hr />
<p>看了一下题，四道题中三道图论，T2 还出现了 CSP/NOIP 万年不出现的博弈题
<del>CCF 没活了可以咬打火机</del>。感觉这次考试不简单。</p>
<p>考试开始后准备做 T1，首先想到的是把图连边，然后跑一遍限制层数的 DFS
即可。连边直接算出两点间距离即可。但这样做需要用
Folyd，预处理的时间复杂度已经达到了 <span
class="math inline">\(O(n^3)\)</span>（考场上脑抽了没想到不带边权的图可直接跑
<span class="math inline">\(n\)</span> 次 BFS 的复杂度可达 <span
class="math inline">\(O(n^2)\)</span>
QAQ），于是这种做法就毙掉了。看数据范围发现 <span
class="math inline">\(k\)</span> 较小，考虑先枚举可行的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点，这样一遍 DFS 即可。然后通过两两枚举可行的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点再计算出 <span class="math inline">\(B\)</span>、<span
class="math inline">\(C\)</span>
两点。然而这种做法随便出个菊花图就被卡掉了。又想了各种做法，但都发现不够优。此时已经过了
1.5h，代码还一笔没动，有点慌就去开 T2 了。</p>
<p>接下来看了一下 T2，反而发现此题极水。只需要开线段树或 ST 表维护 <span
class="math inline">\(a\)</span>
的最大值、最小值、负数最大值、正数最小值、<span
class="math inline">\(0\)</span> 的个数和 <span
class="math inline">\(b\)</span>
的最大值、最小值即可。然后询问的时候先查询 <span
class="math inline">\(b\)</span> 的最大值 <span
class="math inline">\(\text{maxB}\)</span> 和最小值 <span
class="math inline">\(\text{minB}\)</span>，两者同号则在 <span
class="math inline">\(a\)</span>
中尽量取异号绝对值最大，没有异号则取同号绝对值最小。若 <span
class="math inline">\(\text{maxB}\)</span> 和 <span
class="math inline">\(\text{minB}\)</span> 两者异号则取 <span
class="math inline">\(a\)</span> 中绝对值最小即可。于是考场上直接开了
<span class="math inline">\(6\)</span> 颗线段树用了 40min
把这道题大样例过了。预估 100 pts。</p>
<p>然后看 T3，花了 10min
理解了一下题意。简单分析了一下发现只要每个点的出度为 <span
class="math inline">\(1\)</span>
就可进行反攻。于是开了邻接矩阵，直接存边和边是否可用。然后暴力加边删边，写了个
<span class="math inline">\(O(n^2)\)</span> 的程序。预估
40pts。此时距离考试结束还有 1.5h。接下来就开始了这场考试的崩坏。。。</p>
<p>看了一下 T4，感觉不太可做就去看 T1 了，没看部分分就没想到 <span
class="math inline">\(k = 1\)</span> 时直接写个 LCA 就行了
QAQ。然后想了一会儿 T1 仍然想不出正解就打暴力。然而开始写 T1
的时候没看到输入“第二行包含 <span class="math inline">\(n - 1\)</span>
个正整数”于是考试时写的是输入 <span class="math inline">\(n\)</span>
个数，考试时又一直用文件输入输出，于是暴力就写挂了 <del>70pts 没了
QAQ</del>。</p>
<h1 id="day-2">Day 2</h1>
<p>心态挺爆炸的，测了一下民间数据 0 + 100 + 40 + 0 =
140pts，身边的人都是 200+ 和 300+，铁省二了，按照自己的能力至少可以拿到
70 + 100 + 40 + 16 = 226pts 的 /kk</p>
<p>看来读题和写暴力的能力还是要好好注意一下，写完程序后和题面逐字对照一下可能会好一点。</p>
<p>最后看了一下，T3 考的是万年不考的哈希，T4
DDP，在联赛中全是不常见的知识点，得好好拓展一下知识面了。</p>
<h1 id="day">Day ???</h1>
<p>0 + 95 + 40 + 0 = 135pts，今年这 CCF 出的数据不是一般的烂，T3 全输出
NO 有 45pts <del>然而我并没有这样干</del>。。。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>CSP</tag>
        <tag>2022</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2021 第二轮 行记</title>
    <url>/csp2021-2/</url>
    <content><![CDATA[<p><del>爆零了？</del></p>
<p>没爆零！</p>
<h1 id="day-0">Day 0</h1>
<p>简单的准备了一下，下午在机房摸了一小会儿鱼，看了一下考试技巧，在洛谷上写了一下单源最短路找一下手感，顺便再和
"Isoheptane" "huaruoji" 聊一下天。</p>
<h1 id="day-1">Day 1</h1>
<p><del>CCF 迷惑操作，把考点设置在了绵阳</del></p>
<p>开了一个上午的车，终于到了绵阳东辰国际学校。来到考场后，发现考场环境比想象中的要好，九代标压
i7 加上 8G 内存完全够用。</p>
<span id="more"></span>
<h2 id="t1">T1</h2>
<p>看了一眼题，感觉不难，就开始做了。</p>
<p>这道题先把飞进来的飞机按照飞机的起飞顺序排序，然后再模拟有无限个廊道，维护一个数组，其中存储了每个廊道可容下的最大飞机数和最晚飞机起飞的时间。分别模拟国内场和国际场的廊道情况。最后把
n 拆成两个数，求最大值即可。时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。考场上以为可以 AC。</p>
<p>最后和 "huaruoji" 交流了一下，发现 <span
class="math inline">\(O(n^2)\)</span> 会被卡，正解的复杂度是 <span
class="math inline">\(O(n \log n)\)</span>。</p>
<h2 id="t2">T2</h2>
<p><del>看到这道题我吐血了，小 c 会做的题我完全不会做。</del></p>
<p>以为这题可做，就花了一个半小时做了这一道题
<del>（然而并没有做出来）</del> 。</p>
<p>先是想的数学方法，如果 ? 可以被替换成 ) 或 *，那就
<code>ans = 2 * ans + 1</code>，然后搜索 ? 替换成 ( 的情况。</p>
<p>然后发现这个方法无法判重，就全部改成了深搜剪枝，但始终第二个样例要少两个数，心态很爆炸。</p>
<p><del>然而并没有关系，毕竟洛谷上此时全部 TLE 了。</del></p>
<h2 id="t3">T3</h2>
<p>最后做的，花了半个小时想思路。</p>
<p>先是将相同的数在上面连线，如 a b c d a 这个数列中 a 包围了 b c
d。若在包围的数中有几根线无论如何都会交叉就无解，否则就优先输出
L。可以先解决包围的数，如前面数列中的 a，最后解决被包围的数，直接输出 L
完事，最后回文简单处理即可。</p>
<p>虽然证明出来了算法的正确性，但是没时间写，于是又爆零了。</p>
<h2 id="t4">T4</h2>
<p>看不懂题，不会，输出 0，跳过。</p>
<h1 id="day-2">Day 2</h1>
<p>没停课，赶作业 ing。</p>
<h1 id="day-3">Day 3</h1>
<p>代码发出来了，测了一下。</p>
<p>T1 只有 5 分？？？</p>
<p>重新看了一下代码，</p>
<p>真！的！爆！零！了！</p>
<p>我是伞兵！</p>
<img src="/csp2021-2/sb.png" class="">
<p>回头全部测了一下数据，分数 5+0+0+0=5pts，炸了。</p>
<p><del>"huaruoji" 128pts 省一预定 %%%</del></p>
<p><del>"iqx37f" 360pts 省队预定 %%%</del></p>
<h1 id="day">Day ???</h1>
<p>分数出来了。</p>
<p>感谢 CCF 的数据，给了我第一题很多分！（不过如果没写错可以有 95
QWQ）</p>
<p>最终成绩：60 + 0 + 12 + 0 = 72，省二滚粗。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>CSP</tag>
        <tag>2021</tag>
      </tags>
  </entry>
  <entry>
    <title>「Codeforces 618F」Double Knapsack - 构造 + 鸽巢原理</title>
    <url>/cf-618f/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://codeforces.com/problemset/problem/618/F">Codeforces
链接</a></p>
<p>给你两个可重集 <span class="math inline">\(A, B\)</span>，<span
class="math inline">\(A, B\)</span> 的元素个数都为 <span
class="math inline">\(n\)</span>，它们中每个元素的大小 <span
class="math inline">\(x\in [1,n]\)</span>。请你分别找出 <span
class="math inline">\(A, B\)</span>
的子集，使得它们中的元素之和相等。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 10^6\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><del>我甚至菜到这是我做的第一道紫题</del></p>
<h2 id="构造方法">构造方法</h2>
<p>本题显然需要构造。</p>
<p>首先我们维护 <span class="math inline">\(A\)</span> 的前缀和 <span
class="math inline">\(\text{sA}\)</span>，<span
class="math inline">\(B\)</span> 的前缀和 <span
class="math inline">\(\text{sB}\)</span>。然后维护双指针指向两前缀和的第一个元素。这时我们将指向
<span class="math inline">\(\text{sA}\)</span> 的指针不停加 <span
class="math inline">\(1\)</span>，同时指向 <span
class="math inline">\(\text{sB}\)</span>
的指针在满足下一个位置指的数小于等于 <span
class="math inline">\(\text{sA}\)</span>
的指针所指的数时不停向前移动，最后记录下 <span
class="math inline">\(\text{sA}\)</span> 的指针指向的值和 <span
class="math inline">\(\text{sB}\)</span>
指针指向的值的差及下标。若差已经存在，将存在的差的下标的前面的数删去后后面的差即可变为
<span class="math inline">\(0\)</span>，故两差坐标之间的数即为答案。</p>
<h2 id="正确性证明">正确性证明</h2>
<p>接下来我们需要证明本题绝对有解，且所有解中至少有一种解所取的子集在原集合中是相邻的。</p>
<p>设指针下标为 <span class="math inline">\(p\)</span>，<span
class="math inline">\(q\)</span>。该题始终满足 <span
class="math inline">\(\text{sA}_p - \text{sB}_q &lt;
n\)</span>，若两差大于 <span class="math inline">\(n\)</span>，则 <span
class="math inline">\(q\)</span>
必定可以后移，不为最优。因为集合中的所有数都小于等于 <span
class="math inline">\(n\)</span>。</p>
<p>所以我们目前有 <span class="math inline">\(sA_0 - sB_q, sA_1 - sB_q,
sA_3 - sB_q, \cdots, sA_n - sB_q\)</span> 总共 <span
class="math inline">\(n + 1\)</span> 个差。但所有差只有 <span
class="math inline">\(0, 1, 2, \cdots, n - 1\)</span> 总共 <span
class="math inline">\(n\)</span>
种。根据鸽巢原理可知至少有一种差出现了不止一次。故用该方法本题保证有解。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>], b[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> sa[MAXN + <span class="number">1</span>], sb[MAXN + <span class="number">1</span>];</span><br><span class="line">    sa[<span class="number">0</span>] = sb[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">        sa[i] = sa[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[i]);</span><br><span class="line">        sb[i] = sb[i - <span class="number">1</span>] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pos[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>, q = <span class="number">0</span>;</span><br><span class="line">    vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">bool</span> find = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; p &lt;= n; p++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (q &lt; n &amp;&amp; sb[q + <span class="number">1</span>] &lt;= sa[p]) q++;</span><br><span class="line">        <span class="keyword">if</span> (vis[sa[p] - sb[q]]) &#123;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            vis[sa[p] - sb[q]] = <span class="literal">true</span>;</span><br><span class="line">            pos[sa[p] - sb[q]] = std::<span class="built_in">make_pair</span>(p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (find) &#123;</span><br><span class="line">        std::cout &lt;&lt; p - pos[sa[p] - sb[q]].first &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos[sa[p] - sb[q]].first + <span class="number">1</span>; i &lt;= p; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; q - pos[sa[p] - sb[q]].second &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = pos[sa[p] - sb[q]].second + <span class="number">1</span>; i &lt;= q; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Codeforces</tag>
        <tag>贪心</tag>
        <tag>构造</tag>
        <tag>前缀和</tag>
        <tag>鸽巢原理</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-S 2022 第一轮 行记</title>
    <url>/csp2022-1/</url>
    <content><![CDATA[<p><del>又来记流水账了 QWQ</del></p>
<h1 id="day-0">Day 0</h1>
<p>由于成都疫情一直在家，复习了一下初赛，然后继续刷题。由于现在基本等于停课状态准备算比较充分。</p>
<p>今年是线上考，事先试了一下设备。刷了一套初赛题之后就在洛谷上刷其它题去了（逃
<del>还是复赛题有意思</del></p>
<p>补了几集《四月是你的谎言》就睡觉了。</p>
<span id="more"></span>
<h1 id="day-1">Day 1</h1>
<p>毕竟是最后一场 CSP-S 了，还是有点紧张。</p>
<p>实在无心复习，上午就更新了一下
Blog，写了一下最近刷的部分题目的题解。</p>
<p>中午提前一个小时就进考场（实际上是腾讯会议），就在那里干瞪着瞪了一个小时。想着是最后一次参加
CSP-S 了依然挺紧张 QWQ</p>
<p>提前十分钟登了系统，没过多久就开考了。</p>
<p>前面的题都还算友好，但到了 T10 答案死活算出来都是 <span
class="math inline">\(\frac{ {8 \choose 2} {6 \choose 2} {4 \choose 2}
{2 \choose 2} }{4!} = 105\)</span> 卡了 10 多分钟，实在没法了就蒙了
C（考完后才发现 CCF 语文不过关），然后发现选择题做完已经过去 40min
了，有点慌。</p>
<p>然后做到读程序题，T1 看了一会儿带了样例算了算，发现是一个 <span
class="math inline">\(\text{next}\)</span> 数组写得不太好的像 KMP
的算法。时间复杂度最劣是 <span
class="math inline">\(\Theta(nm)\)</span>（CCF 不分 <span
class="math inline">\(O\)</span> 和 <span
class="math inline">\(\Theta\)</span> 扣钱！），模拟几下就过掉了。</p>
<p>阅读程序 T2
没看懂，然后看了一下第一问才知道这是个排序。回头仔细研究了一下发现是
<span class="math inline">\(k\)</span>
个关键字的基数排序，题目答案就水落石出了。</p>
<p>阅读程序 T3 一看就知道是进制转化，做了一半发现 <span
class="math inline">\(n\)</span>
可能是负数。自造了一些样例带进去算了一下发现是求 <span
class="math inline">\(n\)</span> 的 <span
class="math inline">\(k\)</span>
进制补码。后面的事情就自然而然的解决了。然后看了一下时间还有不到半个小时。。。</p>
<p>然后做了完善程序。第一题感觉是二分后处理尾部，没怎么看懂。就先做第二题，发现第二题考的是用记忆化搜索写的
DP，且考得非常简单，就把第二题秒了。回头再看第一题，看了一会儿把确定的写了，最后两个空不确定的大致二选一猜了一下。写完整张卷子的时候距离考试结束只剩
10min。。。</p>
<p>最后检查了一遍答题卡和答案，检查的时候突然知道了阅读程序第一题最后两个空怎么做，飞速改完。在最后
1min 提交这两个空的修改后又检查了一遍该题，真 TM 刺激。</p>
<p>接着考完试之后在 JKFOI 聊了一会儿天，刷了一下洛谷
<del>然后发现这套题骂声连篇</del>，以及发现字自己 T10 被坑了。</p>
<p>最后还是估了一下分，洛谷数据 81.5pts，有道小图灵数据
89pts，稳过。</p>
<p>最后在 JKFOI 打了一局雀魂，上传了考试录像，这一天就结束了。</p>
<h1 id="day">Day ???</h1>
<p>出成绩。上午 10:00 的时候就开始查成绩，一直查到了晚上
7:30，期间网站一直 502 或 504 <del>感谢 CCF 的优秀服务器，让所有 SC OIer
都可以享受 502pts 和 504pts 的全国首位的超高分。SC 或许成为首个人均 AK
初赛的省份（大雾</del></p>
<p>最后终于查到了。87.5pts，稳过。</p>
<img src="/csp2022-1/score.png" class="">
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>CSP</tag>
        <tag>2022</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2022」假期计划 - 最短路 + BFS + 贪心</title>
    <url>/csp2022-holiday/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://www.bilibili.com/video/BV1GJ411x7h7">题目链接之后再加</a></p>
<p>小熊的地图上有 <span class="math inline">\(n\)</span>
个点，其中编号为 <span class="math inline">\(1\)</span>
的是它的家、编号为 <span class="math inline">\(2, 3, \ldots, n\)</span>
的都是景点。部分点对之间有双向直达的公交线路。如果点 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(z_1\)</span>、<span
class="math inline">\(z_1\)</span> 与 <span
class="math inline">\(z_2\)</span>、……、<span class="math inline">\(z_{k
- 1}\)</span> 与 <span class="math inline">\(z_k\)</span>、<span
class="math inline">\(z_k\)</span> 与 <span
class="math inline">\(y\)</span> 之间均有直达的线路，那么我们称 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间的行程可转车 <span
class="math inline">\(k\)</span> 次通达；特别地，如果点 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 之间有直达的线路，则称可转车 <span
class="math inline">\(0\)</span> 次通达。</p>
<p>很快就要放假了，小熊计划从家出发去 <span
class="math inline">\(4\)</span> 个<strong>不同</strong>的景点游玩，完成
<span class="math inline">\(5\)</span> 段行程后回家：家 <span
class="math inline">\(\to\)</span> 景点 A <span
class="math inline">\(\to\)</span> 景点 B <span
class="math inline">\(\to\)</span> 景点 C <span
class="math inline">\(\to\)</span> 景点 D <span
class="math inline">\(\to\)</span> 家且每段行程最多转车 <span
class="math inline">\(k\)</span>
次。转车时经过的点没有任何限制，既可以是家、也可以是景点，还可以重复经过相同的点。例如，在景点
A <span class="math inline">\(\to\)</span> 景点 B
的这段行程中，转车时经过的点可以是家、也可以是景点 C，还可以是景点 D
<span class="math inline">\(\to\)</span> 家这段行程转车时经过的点。</p>
<p>假设每个景点都有一个分数，请帮小熊规划一个行程，使得小熊访问的四个<strong>不同</strong>景点的分数之和最大。</p>
<p>对于所有数据，保证 <span class="math inline">\(5 \le n \le
2500\)</span>，<span class="math inline">\(1 \le m \le
10000\)</span>，<span class="math inline">\(0 \le k \le
100\)</span>，所有景点的分数 <span class="math inline">\(1 \le s_i \le
{10}^{18}\)</span>。保证至少存在一组符合要求的行程。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们可以先在预处理，每个点跑一遍 BFS 求出从 <span
class="math inline">\(u\)</span> 到 <span
class="math inline">\(v\)</span> 的最小步数 <span
class="math inline">\(\text{step}_{u, v}\)</span>。</p>
<p>对于一中部分分写法，我们可以把 <span
class="math inline">\(\text{step}_{u, v} \le k + 1\)</span>
的边连起来，然后跑一遍深度为 <span class="math inline">\(4\)</span> 的
DFS。但这样如果数据构造出菊花图或点数多后很容易爆炸，实际得分
70pts。</p>
<p>接下来我们可以想优化，由于只需经过 <span
class="math inline">\(4\)</span>
个点，我们可以考虑枚举经过的点。根据数据范围和题目信息，很容易推出我们需要枚举
<span class="math inline">\(2\)</span>
个点，然后计算出最优的另外两个点即可。为了让可选点的限制尽量多，我们可选择枚举
<span class="math inline">\(B\)</span> 和 <span
class="math inline">\(C\)</span> 两点。这样我们只需要算出 <span
class="math inline">\(B/C \rightarrow 1\)</span>
所经过的唯一最优点即可。</p>
<p>在枚举的时候寻找可行的点显然不可行，于是我们可以想到对每个点 <span
class="math inline">\(u\)</span>，预处理满足 <span
class="math inline">\(\text{step}_{1, v} \le k + 1 \wedge
\text{step}_{v, i} \le k + 1\)</span> 的所有 <span
class="math inline">\(v\)</span> 点。将所有 <span
class="math inline">\(v\)</span> 点存入 <span
class="math inline">\(\text{att}_u\)</span>
数组，然后根据每个点的分数从大到小将 <span
class="math inline">\(\text{att}_u\)</span> 排序。时间复杂度 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>最后我们枚举 <span class="math inline">\(B\)</span>、<span
class="math inline">\(C\)</span> 两点，然后分别从 <span
class="math inline">\(\text{att}_B\)</span> 和 <span
class="math inline">\(\text{att}_C\)</span> 中选择不重复的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点即可。使用贪心可以证明最优的 <span
class="math inline">\(A\)</span>、<span class="math inline">\(D\)</span>
点始终为 <span class="math inline">\(\text{att}_B\)</span> 和 <span
class="math inline">\(\text{att}_D\)</span> 的前 <span
class="math inline">\(3\)</span> 项，于是对于每组 <span
class="math inline">\(B\)</span>、<span class="math inline">\(D\)</span>
仅需枚举 <span class="math inline">\(9\)</span>
次。得出所有情况的最大值即为答案。时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> s;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *s, Node *t)</span> </span>&#123;</span><br><span class="line">    s-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(s, t));</span><br><span class="line">    t-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(t, s));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;k);</span><br><span class="line">    k++;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nodes[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;nodes[i].s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[x], &amp;nodes[y]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">steps</span>(n + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n + <span class="number">1</span>, INT_MAX));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> bfs = [&amp;](Node *u) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nodes[i].v = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        std::queue&lt;std::pair&lt;<span class="type">int</span>, Node *&gt;&gt; q;</span><br><span class="line">        u-&gt;v = <span class="literal">true</span>, steps[u-&gt;id][u-&gt;id] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, u));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">const</span> std::pair&lt;<span class="type">int</span>, Node *&gt; p = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="type">int</span> step = p.first;</span><br><span class="line">            Node *v = p.second;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!e.t-&gt;v) &#123;</span><br><span class="line">                    steps[u-&gt;id][e.t-&gt;id] = step + <span class="number">1</span>;</span><br><span class="line">                    e.t-&gt;v = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(step + <span class="number">1</span>, e.t));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">bfs</span>(&amp;nodes[i]);</span><br><span class="line"></span><br><span class="line">    std::vector&lt;std::vector&lt;Node *&gt;&gt; <span class="built_in">att</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (steps[i][j] &lt;= k &amp;&amp; steps[j][<span class="number">1</span>] &lt;= k) &#123;</span><br><span class="line">                att[i].<span class="built_in">push_back</span>(&amp;nodes[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) std::<span class="built_in">sort</span>(att[i].<span class="built_in">begin</span>(), att[i].<span class="built_in">end</span>(), [](Node *a, Node *b)&#123; <span class="keyword">return</span> a-&gt;s &gt; b-&gt;s; &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">2</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == j || steps[i][j] &gt; k || att[i].<span class="built_in">empty</span>() || att[j].<span class="built_in">empty</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            std::vector&lt;Node *&gt;::iterator itB = att[i].<span class="built_in">begin</span>(), itC = att[j].<span class="built_in">begin</span>();</span><br><span class="line">            <span class="keyword">if</span> (*itB == &amp;nodes[j]) itB++;</span><br><span class="line">            <span class="keyword">if</span> (*itC == &amp;nodes[i]) itC++;</span><br><span class="line">            <span class="keyword">if</span> (itB == att[i].<span class="built_in">end</span>() || itC == att[j].<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (*itB == *itC) &#123;</span><br><span class="line">                <span class="keyword">if</span> (itB + <span class="number">1</span> != att[i].<span class="built_in">end</span>() &amp;&amp; *(itB + <span class="number">1</span>) != &amp;nodes[j] &amp;&amp; *(itB + <span class="number">1</span>) != *itC) ans = std::<span class="built_in">max</span>(ans, nodes[i].s + nodes[j].s + (*(itB + <span class="number">1</span>))-&gt;s + (*itC)-&gt;s);</span><br><span class="line">                <span class="keyword">if</span> (itC + <span class="number">1</span> != att[j].<span class="built_in">end</span>() &amp;&amp; *(itC + <span class="number">1</span>) != &amp;nodes[i] &amp;&amp; *(itC + <span class="number">1</span>) != *itB) ans = std::<span class="built_in">max</span>(ans, nodes[i].s + nodes[j].s + (*itB)-&gt;s + (*(itC + <span class="number">1</span>))-&gt;s);</span><br><span class="line">            &#125; <span class="keyword">else</span> ans = std::<span class="built_in">max</span>(ans, nodes[i].s + nodes[j].s + (*itB)-&gt;s + (*itC)-&gt;s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>贪心</tag>
        <tag>CSP</tag>
        <tag>2022</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2022」星战 - 图论 + Hash</title>
    <url>/csp2022-galaxy/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://www.bilibili.com/video/BV1GJ411x7h7">题目链接之后再加</a></p>
<p>在这一轮的星际战争中，我方在宇宙中建立了 <span
class="math inline">\(n\)</span> 个据点，以 <span
class="math inline">\(m\)</span> 个单向虫洞连接。我们把终点为据点 <span
class="math inline">\(u\)</span> 的所有虫洞归为据点 <span
class="math inline">\(u\)</span> 的虫洞。</p>
<p>战火纷飞之中这些虫洞很难长久存在，敌人的打击随时可能到来。这些打击中的有效打击可以分为两类：</p>
<ol type="1">
<li>敌人会摧毁某个虫洞，这会使它连接的两个据点无法再通过这个虫洞直接到达，但这样的打击无法摧毁它连接的两个据点。</li>
<li>敌人会摧毁某个据点，由于虫洞的主要技术集中在出口处，这会导致该据点的所有还未被摧毁的虫洞被一同摧毁。而从这个据点出发的虫洞则<strong>不会摧毁</strong>。</li>
</ol>
<p>注意：摧毁只会导致虫洞不可用，而不会消除它的存在。</p>
<p>为了抗击敌人并维护各部队和各据点之间的联系，我方发展出了两种特种部队负责修复虫洞：</p>
<ul>
<li>A 型特种部队则可以将某个特定的虫洞修复。</li>
<li>B 型特种部队可以将某据点的所有损坏的虫洞修复。</li>
</ul>
<p>考虑到敌人打击的特点，我方并未在据点上储备过多的战略物资。因此只要这个据点的某一条虫洞被修复，处于可用状态，那么这个据点也是可用的。</p>
<p>我方掌握了一种苛刻的空间特性，利用这一特性我方战舰可以沿着虫洞瞬移到敌方阵营，实现精确打击。</p>
<p>为了把握发动反攻的最佳时机，指挥部必须关注战场上的所有变化，为了寻找一个能够进行反攻的时刻。总指挥认为：</p>
<ul>
<li>如果从我方的任何据点出发，在选择了合适的路线的前提下，可以进行无限次的虫洞穿梭（可以多次经过同一据点或同一虫洞），那么这个据点就可以<strong>实现反击</strong>。</li>
<li>为了使虫洞穿梭的过程连续，尽量减少战舰在据点切换虫洞时的质能损耗，当且仅当<strong>只有一个从该据点出发的虫洞可用</strong>时，这个据点可以<strong>实现连续穿梭</strong>。</li>
<li>如果我方所有据点都可以<strong>实现反击</strong>，也都可以<strong>实现连续穿梭</strong>，那么这个时刻就是一个绝佳的<strong>反攻</strong>时刻。</li>
</ul>
<p>总司令为你下达命令，要求你根据战场上实时反馈的信息，迅速告诉他当前的时刻是否能够进行一次<strong>反攻</strong>。</p>
<p>对于所有数据保证：<span class="math inline">\(1 \le n \le 5 \times
{10}^5\)</span>，<span class="math inline">\(1 \le m \le 5 \times
{10}^5\)</span>，<span class="math inline">\(1 \le q \le 5 \times
{10}^5\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题实质是有一张有向图，有若干次加边删边操作，问每次操作完后从每个点出发均可进入一个强连通分量，且每个点的出度为
<span class="math inline">\(1\)</span>。</p>
<p>由图论知识可推出，只要每个点的出度为 <span
class="math inline">\(1\)</span>，则从任意点出发必定可进入一个强连通分量。因为只要有
<span class="math inline">\(2\)</span>
点则必有环，只要出现另外的点，由于出度为 <span
class="math inline">\(1\)</span>
则必定连向环或连向连向环的点。于是只要判断出每个点的出度为 <span
class="math inline">\(1\)</span> 则说明该图满足条件。</p>
<p>由于数据范围过大，我们肯定需要在小于 <span
class="math inline">\(O(n)\)</span>
的情况下判断这张图是否满足情况。这时我们可以用 Hash
解决。设每个点对应一个 Hash 值 <span
class="math inline">\(a_i\)</span>（<span
class="math inline">\(a_i\)</span>
可使用随机数生成，且需要是大数以减少冲突概率）和出度 <span
class="math inline">\(d_i\)</span>，我们可以定义这张图的 Hash 值 <span
class="math inline">\(\text{res}\)</span> 为 <span
class="math inline">\(\sum_{i = 1}^n{a_i d_i}\)</span>。只要满足 <span
class="math inline">\(\text{res} = \sum_{i = 1}^n{a_i}\)</span>
即可说明这张图满足条件。对于加边 <span class="math inline">\(u
\rightarrow v\)</span> 操作，我们只需更新 <span
class="math inline">\(\text{res} = \text{res} + a_u\)</span>
即可；同理对于删边 <span class="math inline">\(u \rightarrow v\)</span>
操作，我们只需更新 <span class="math inline">\(\text{res} = \text{res} -
a_u\)</span> 即可。这样就可实现 <span
class="math inline">\(O(1)\)</span> 处理，<span
class="math inline">\(O(1)\)</span> 查询。</p>
<p>同时我们也需要实现对于据点的加边和删边操作。我们可以对每个点再开一个
Hash 值 <span class="math inline">\(\text{in}_i\)</span>，表示删除 <span
class="math inline">\(i\)</span> 号点对 <span
class="math inline">\(\text{res}\)</span>
的变化值。每次进行加边和删边操作时，同时在 <span
class="math inline">\(\text{in}_i\)</span> 中操作。即进行加边 <span
class="math inline">\(u \rightarrow v\)</span> 时，更新 <span
class="math inline">\(\text{in}_v = \text{in}_v + a_u\)</span>，进行删边
<span class="math inline">\(u \rightarrow v\)</span> 时，更新 <span
class="math inline">\(\text{in}_v = \text{in}_v -
a_u\)</span>。这样即可在删除 <span class="math inline">\(v\)</span>
点时，直接更新 <span class="math inline">\(\text{res} = \text{res} -
\text{in}_u\)</span> 并将 <span
class="math inline">\(\text{in}_u\)</span>
清空即可。对于加点操作，我们可以直接在询问前处理出 <span
class="math inline">\(\text{init}_i\)</span> 表示 <span
class="math inline">\(\text{in}_i\)</span>
的最初状态，然后加点时直接恢复至最初状态，即更新 <span
class="math inline">\(\text{res} = \text{res} + \text{init}_i -
\text{in}_i\)</span>，<span class="math inline">\(\text{in}_i =
\text{init}_i\)</span> 即可。时间复杂度为 <span
class="math inline">\(O(n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> target = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i] = ((<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>)<span class="built_in">rng</span>() &lt;&lt; <span class="number">31</span>) ^ <span class="built_in">rng</span>();</span><br><span class="line">        target += a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">init</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        init[v] += a[u];</span><br><span class="line">        res += a[u];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">in</span><span class="params">(init)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            in[v] -= a[u];</span><br><span class="line">            res -= a[u];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            res -= in[u];</span><br><span class="line">            in[u] = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            in[v] += a[u];</span><br><span class="line">            res += a[u];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;u);</span><br><span class="line">            res += init[u] - in[u];</span><br><span class="line">            in[u] = init[u];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res == target) <span class="built_in">puts</span>(<span class="string">&quot;YES&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>CSP</tag>
        <tag>2022</tag>
        <tag>Hash</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2021」廊桥分配 - 技巧</title>
    <url>/csp2021-airport/</url>
    <content><![CDATA[<p><del>论正解 <span class="math inline">\(O(n \log n)\)</span> 我用
<span class="math inline">\(O(n^2)\)</span>
的算法怎么卡过的。。。</del></p>
<p>这道题我不打算写正解。。。</p>
<h1 id="题目描述">题目描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P7913">洛谷链接</a></p>
<p>一个机场有国内场和国际场两种航班，每种航班中有多个廊桥，飞机可停在廊桥边，一个廊桥对应一个飞机。若在该场的廊桥已全部停完，则飞机则无法停靠。给定廊桥数量，所有国内航班和国际航班的降落时间和起飞时间，飞机到达时从前到后依次停靠，问国内廊桥和国际廊桥分别分配几个才可使可停靠飞机数最大。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<blockquote>
<p>注意该思路不是正解，相对正解不够优，本文只是介绍该方法的卡常 AC
方法！（基于 €€ ￡给的数据比较水的基础上）</p>
</blockquote>
<h2 id="分思路">40 分思路</h2>
<p>复杂度为 <span class="math inline">\(O(n^2)\)</span>。</p>
<p>首先通过进场时间排序。</p>
<p>可分别计算国内场和国际场。假设有无限个廊桥，分别用 <span
class="math inline">\(O(n^2)\)</span>
的算法模拟廊桥的情况，若廊桥不够则多加入一个廊桥。</p>
<p>记录廊桥仅需记录此时的廊桥最后飞机的出发时间和在此廊桥停靠的个数即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; chFl[MAXN];</span><br><span class="line"><span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; abFl[MAXN];</span><br><span class="line"><span class="type">int</span> chTop = <span class="number">1</span>, abTop = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(chFl, <span class="number">0</span>, <span class="built_in">sizeof</span>(chFl));</span><br><span class="line"><span class="built_in">memset</span>(abFl, <span class="number">0</span>, <span class="built_in">sizeof</span>(abFl));</span><br><span class="line">chFl[<span class="number">0</span>] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ch[<span class="number">0</span>].second);</span><br><span class="line">abFl[<span class="number">0</span>] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ab[<span class="number">0</span>].second);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m1; i++) &#123;</span><br><span class="line">    <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; chTop; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chFl[j].second &lt;= ch[i].first) &#123;</span><br><span class="line">            con = <span class="literal">false</span>;</span><br><span class="line">            chFl[j] = std::<span class="built_in">make_pair</span>(chFl[j].first + <span class="number">1</span>, ch[i].second);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (con) &#123;</span><br><span class="line">        chFl[chTop++] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ch[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m2; i++) &#123;</span><br><span class="line">    <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; abTop; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (abFl[j].second &lt;= ab[i].first) &#123;</span><br><span class="line">            con = <span class="literal">false</span>;</span><br><span class="line">            abFl[j] = std::<span class="built_in">make_pair</span>(abFl[j].first + <span class="number">1</span>, ab[i].second);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (con) &#123;</span><br><span class="line">        abFl[abTop++] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ab[i].second);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后将 <code>n</code> 分解成
<code>(0, n), (1, n - 1), (2, n - 2) ... (n, 0)</code> 共
<code>n + 1</code>
种情况，在这些情况的处理下，将各个情况的飞机数相加，取最大值即为答案。</p>
<p>不过显然这种做法不够优，最终数据会超时。</p>
<h2 id="前缀和优化">前缀和优化</h2>
<p>此时已经有 40 分了，在加上前缀和的 <del>玄学</del> 优化即可达到 95
分的分数。</p>
<p>在最后计算答案之前（即为将 <code>n</code> 分解成
<code>(0, n), (1, n - 1), (2, n - 2) ... (n, 0)</code> 共
<code>n + 1</code>
种情况时）可将国内场的飞机数和国际场的飞机数分别做一个前缀和，以便计算。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> chSum[MAXN], abSum[MAXN];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    chSum[i] = chSum[i - <span class="number">1</span>] + chFl[i - <span class="number">1</span>].first;</span><br><span class="line">    abSum[i] = abSum[i - <span class="number">1</span>] + abFl[i - <span class="number">1</span>].first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着即可在 <span class="math inline">\(O(n)\)</span>
的复杂度中计算出最终答案。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (chSum[i] + abSum[n - i] &gt; ans) &#123;</span><br><span class="line">        ans = chSum[i] + abSum[n - i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>利用前缀和，就可把整个计算最终答案的过程从 <span
class="math inline">\(O(n^2)\)</span> 优化到 <span
class="math inline">\(O(n)\)</span>。最终答案就可多 45 分。</p>
<h2 id="快读优化">快读优化</h2>
<p>在这 95 分的基础上，只需写一下快读，即可 AC。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m1, m2;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ch[MAXN];</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ab[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m1; i++) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>();</span><br><span class="line">        ch[i] = std::<span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m2; i++) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>();</span><br><span class="line">        ab[i] = std::<span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正解">正解</h2>
<p>这里在 huaruoji 的博客中已经讲得很清楚了，这里就不在赘述。</p>
<p><a href="https://www.cnblogs.com/huaruoji/p/15450554.html">CSP2021
游记 - huaruoji</a></p>
<h1 id="代码演示">代码演示</h1>
<h2 id="本文介绍的代码">本文介绍的代码</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100007</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m1, m2;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ch[MAXN];</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ab[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m1; i++) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>();</span><br><span class="line">        ch[i] = std::<span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m2; i++) &#123;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>();</span><br><span class="line">        ab[i] = std::<span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(ch, ch + m1);</span><br><span class="line">    std::<span class="built_in">sort</span>(ab, ab + m2);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; chFl[MAXN];</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; abFl[MAXN];</span><br><span class="line">    <span class="type">int</span> chTop = <span class="number">1</span>, abTop = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">memset</span>(chFl, <span class="number">0</span>, <span class="built_in">sizeof</span>(chFl));</span><br><span class="line">    <span class="built_in">memset</span>(abFl, <span class="number">0</span>, <span class="built_in">sizeof</span>(abFl));</span><br><span class="line">    chFl[<span class="number">0</span>] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ch[<span class="number">0</span>].second);</span><br><span class="line">    abFl[<span class="number">0</span>] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ab[<span class="number">0</span>].second);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m1; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; chTop; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (chFl[j].second &lt;= ch[i].first) &#123;</span><br><span class="line">                con = <span class="literal">false</span>;</span><br><span class="line">                chFl[j] = std::<span class="built_in">make_pair</span>(chFl[j].first + <span class="number">1</span>, ch[i].second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (con) &#123;</span><br><span class="line">            chFl[chTop++] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ch[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m2; i++) &#123;</span><br><span class="line">        <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; abTop; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (abFl[j].second &lt;= ab[i].first) &#123;</span><br><span class="line">                con = <span class="literal">false</span>;</span><br><span class="line">                abFl[j] = std::<span class="built_in">make_pair</span>(abFl[j].first + <span class="number">1</span>, ab[i].second);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (con) &#123;</span><br><span class="line">            abFl[abTop++] = std::<span class="built_in">make_pair</span>(<span class="number">1</span>, ab[i].second);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> chSum[MAXN], abSum[MAXN];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        chSum[i] = chSum[i - <span class="number">1</span>] + chFl[i - <span class="number">1</span>].first;</span><br><span class="line">        abSum[i] = abSum[i - <span class="number">1</span>] + abFl[i - <span class="number">1</span>].first;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chSum[i] + abSum[n - i] &gt; ans) &#123;</span><br><span class="line">            ans = chSum[i] + abSum[n - i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="正解若想看思路请移步-huaruoji-的博客">正解（若想看思路请移步
huaruoji 的博客）</h2>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// P7913 [CSP-S 2021] 廊桥分配</span></span><br><span class="line"><span class="comment">// WzhDnwzWzh</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100007</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m1, m2;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m1 &gt;&gt; m2;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ch[MAXN];</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ab[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m1; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ch[i] = std::<span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; m2; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">        ab[i] = std::<span class="built_in">make_pair</span>(x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::<span class="built_in">sort</span>(ch, ch + m1);</span><br><span class="line">    std::<span class="built_in">sort</span>(ab, ab + m2);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::priority_queue&lt; <span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; chN;</span><br><span class="line">    <span class="type">static</span> std::priority_queue&lt; <span class="type">int</span>, std::vector&lt;<span class="type">int</span>&gt;, std::greater&lt;<span class="type">int</span>&gt; &gt; abN;</span><br><span class="line">    <span class="type">static</span> std::priority_queue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, std::greater&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; chU;</span><br><span class="line">    <span class="type">static</span> std::priority_queue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;, std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;, std::greater&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; &gt; abU;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> chH[MAXN];</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> abH[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(chH, <span class="number">0</span>, <span class="built_in">sizeof</span>(chH));</span><br><span class="line">    <span class="built_in">memset</span>(abH, <span class="number">0</span>, <span class="built_in">sizeof</span>(abH));</span><br><span class="line">    chH[<span class="number">0</span>] = abH[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        chN.<span class="built_in">push</span>(i);</span><br><span class="line">        abN.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    chU.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(ch[<span class="number">0</span>].second, <span class="number">0</span>) );</span><br><span class="line">    abU.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(ab[<span class="number">0</span>].second, <span class="number">0</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m1; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!chU.<span class="built_in">empty</span>() &amp;&amp; chU.<span class="built_in">top</span>().first &lt;= ch[i].first) &#123;</span><br><span class="line">            chN.<span class="built_in">push</span>( chU.<span class="built_in">top</span>().second );</span><br><span class="line">            chU.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!chN.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            chH[chN.<span class="built_in">top</span>()]++;</span><br><span class="line">            chU.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>( ch[i].second, chN.<span class="built_in">top</span>() ) );</span><br><span class="line">            chN.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m2; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (!abU.<span class="built_in">empty</span>() &amp;&amp; abU.<span class="built_in">top</span>().first &lt;= ab[i].first) &#123;</span><br><span class="line">            abN.<span class="built_in">push</span>( abU.<span class="built_in">top</span>().second );</span><br><span class="line">            abU.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!abN.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            abH[abN.<span class="built_in">top</span>()]++;</span><br><span class="line">            abU.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>( ab[i].second, abN.<span class="built_in">top</span>() ) );</span><br><span class="line">            abN.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> chS[MAXN], abS[MAXN];</span><br><span class="line">    chS[<span class="number">0</span>] = abS[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        chS[i] = chS[i - <span class="number">1</span>] + chH[i - <span class="number">1</span>];</span><br><span class="line">        abS[i] = abS[i - <span class="number">1</span>] + abH[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (chS[i] + abS[n - i] &gt; ans) &#123;</span><br><span class="line">            ans = chS[i] + abS[n - i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>CSP</tag>
        <tag>2021</tag>
        <tag>前缀和</tag>
        <tag>模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>「CSP-S 2022」策略游戏 - 贪心 + 线段树</title>
    <url>/csp2022-game/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://www.bilibili.com/video/BV1GJ411x7h7">题目链接之后再加</a></p>
<p>小 L 和小 Q 在玩一个策略游戏。</p>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(A\)</span> 和一个长度为 <span
class="math inline">\(m\)</span> 的数组 <span
class="math inline">\(B\)</span>，在此基础上定义一个大小为 <span
class="math inline">\(n \times m\)</span> 的矩阵 <span
class="math inline">\(C\)</span>，满足 <span class="math inline">\(C_{i
j} = A_i \times B_j\)</span>。所有下标均从 <span
class="math inline">\(1\)</span> 开始。</p>
<p>游戏一共会进行 <span class="math inline">\(q\)</span>
轮，在每一轮游戏中，会事先给出 <span class="math inline">\(4\)</span>
个参数 <span class="math inline">\(l_1, r_1, l_2, r_2\)</span>，满足
<span class="math inline">\(1 \le l_1 \le r_1 \le n\)</span>、<span
class="math inline">\(1 \le l_2 \le r_2 \le m\)</span>。</p>
<p>游戏中，小 L 先选择一个 <span class="math inline">\(l_1 \sim
r_1\)</span> 之间的下标 <span class="math inline">\(x\)</span>，然后小 Q
选择一个 <span class="math inline">\(l_2 \sim r_2\)</span> 之间的下标
<span class="math inline">\(y\)</span>。定义这一轮游戏中二人的得分是
<span class="math inline">\(C_{x y}\)</span>。</p>
<p>小 L 的目标是使得这个得分尽可能大，小 Q
的目标是使得这个得分尽可能小。同时两人都是足够聪明的玩家，每次都会采用最优的策略。</p>
<p>请问：按照二人的最优策略，每轮游戏的得分分别是多少？</p>
<p>对于所有数据，<span class="math inline">\(1 \le n, m, q \le
{10}^5\)</span>，<span class="math inline">\(-{10}^9 \le A_i, B_i \le
{10}^9\)</span>。对于每轮游戏而言，<span class="math inline">\(1 \le l_1
\le r_1 \le n\)</span>，<span class="math inline">\(1 \le l_2 \le r_2
\le m\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然可贪心解决。</p>
<p>由于小 L 先抽，小 Q 后抽，由于小 L 先抽时必须考虑小 Q
可选的情况，于是我们可以先看小 Q 可以抽什么。假设小 L 选了 <span
class="math inline">\(x\)</span>，若 <span class="math inline">\(x &gt;
0\)</span>，则小 Q 选得尽量小；若 <span class="math inline">\(x \le
0\)</span>，则小 Q 选得尽量大即可。</p>
<p>接下来考虑小 L 的情况。设小 Q 可选的最小数为 <span
class="math inline">\(\text{minB}\)</span>，最大数为 <span
class="math inline">\(\text{maxB}\)</span>：</p>
<ul>
<li>若 <span class="math inline">\(\text{minB}\)</span>、<span
class="math inline">\(\text{maxB}\)</span> 异号：则只要不选 <span
class="math inline">\(0\)</span>，得到的数始终为负数。这种情况能选 <span
class="math inline">\(0\)</span> 就选 <span
class="math inline">\(0\)</span>；如果没有 <span
class="math inline">\(0\)</span>
就在选择正数最小值或负数最大值两种情况中取最优情况即可。</li>
<li>若 <span class="math inline">\(\text{minB}\)</span>、<span
class="math inline">\(\text{maxB}\)</span>
同号：尽量选同号且绝对值最大的数。若没有同号，则选择 <span
class="math inline">\(0\)</span>
以及异号中绝对值最小的数。证明显然。</li>
<li>若 <span class="math inline">\(\text{minB}\)</span>、<span
class="math inline">\(\text{maxB}\)</span> 中至少有一个为 <span
class="math inline">\(0\)</span>：同上。</li>
</ul>
<p>于是我们可以开线段树维护 <span class="math inline">\(A\)</span>
的最大值、最小值、正数最小值、负数最大值和 <span
class="math inline">\(0\)</span> 的个数以及维护 <span
class="math inline">\(B\)</span>
的最大值和最小值。对于每次询问查询后分类讨论即可。</p>
<p>最后注意一下 <span class="math inline">\(l1 = r1\)</span> 或 <span
class="math inline">\(l2 = r2\)</span> 时特判一下即可。时间复杂度 <span
class="math inline">\(O(n \log n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTMin</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegTMin *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegTMin</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMin *lc, SegTMin *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegTMin</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMin *lc, SegTMin *rc, <span class="type">long</span> <span class="type">long</span> val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> std::<span class="built_in">min</span>(lc-&gt;<span class="built_in">query</span>(l, r), rc-&gt;<span class="built_in">query</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegTMin *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegTMin</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, a[l]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            SegTMin *segt = <span class="keyword">new</span> <span class="built_in">SegTMin</span>(l, r, <span class="built_in">build</span>(l, mid, a), <span class="built_in">build</span>(mid + <span class="number">1</span>, r, a));</span><br><span class="line">            segt-&gt;val = std::<span class="built_in">min</span>(segt-&gt;lc-&gt;val, segt-&gt;rc-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> segt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segMinA, *segMinB, *segMinPA, *segMinMA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegTMax</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegTMax *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegTMax</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMax *lc, SegTMax *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegTMax</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegTMax *lc, SegTMax *rc, <span class="type">long</span> <span class="type">long</span> val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> INT_MIN;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> std::<span class="built_in">max</span>(lc-&gt;<span class="built_in">query</span>(l, r), rc-&gt;<span class="built_in">query</span>(l, r));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegTMax *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">long</span> <span class="type">long</span> *a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegTMax</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>, a[l]);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            SegTMax *segt = <span class="keyword">new</span> <span class="built_in">SegTMax</span>(l, r, <span class="built_in">build</span>(l, mid, a), <span class="built_in">build</span>(mid + <span class="number">1</span>, r, a));</span><br><span class="line">            segt-&gt;val = std::<span class="built_in">max</span>(segt-&gt;lc-&gt;val, segt-&gt;rc-&gt;val);</span><br><span class="line">            <span class="keyword">return</span> segt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segMaxA, *segMaxB;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">1</span>], b[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> zero[MAXN + <span class="number">1</span>], pa[MAXN + <span class="number">1</span>], ma[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) pa[i] = a[i], ma[i] = INT_MAX;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; <span class="number">0</span>) ma[i] = -a[i], pa[i] = INT_MAX;</span><br><span class="line">        zero[i] = zero[i - <span class="number">1</span>] + (a[i] == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    segMinA = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, n, a);</span><br><span class="line">    segMaxA = SegTMax::<span class="built_in">build</span>(<span class="number">1</span>, n, a);</span><br><span class="line">    segMinB = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, m, b);</span><br><span class="line">    segMaxB = SegTMax::<span class="built_in">build</span>(<span class="number">1</span>, m, b);</span><br><span class="line">    segMinPA = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, n, pa);</span><br><span class="line">    segMinMA = SegTMin::<span class="built_in">build</span>(<span class="number">1</span>, n, ma);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l1, r1, l2, r2;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;l1, &amp;r1, &amp;l2, &amp;r2);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> minA = segMinA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> maxA = segMaxA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> minB = segMinB-&gt;<span class="built_in">query</span>(l2, r2);</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> maxB = segMaxB-&gt;<span class="built_in">query</span>(l2, r2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l1 == r1) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[l1] &gt; <span class="number">0</span>) ans = minB * a[l1];</span><br><span class="line">            <span class="keyword">else</span> ans = maxB * a[l1];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (l2 == r2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (b[l2] &gt; <span class="number">0</span>) ans = maxA * b[l2];</span><br><span class="line">            <span class="keyword">else</span> ans = minA * b[l2];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (minB * maxB &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minB &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxA &lt; <span class="number">0</span>) ans = maxA * maxB;</span><br><span class="line">                    <span class="keyword">else</span> ans = maxA * minB;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (minA &lt; <span class="number">0</span>) ans = minA * maxB;</span><br><span class="line">                    <span class="keyword">else</span> ans = minA * minB;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minB * maxB == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (minB == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (maxA &lt; <span class="number">0</span>) ans = maxA * maxB;</span><br><span class="line">                    <span class="keyword">else</span> ans = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (minA &lt; <span class="number">0</span>) ans = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">else</span> ans = minA * minB;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (minB * maxB &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (zero[r1] - zero[l1 - <span class="number">1</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    ans = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> npa = segMinPA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">                    <span class="type">long</span> <span class="type">long</span> nma = segMinMA-&gt;<span class="built_in">query</span>(l1, r1);</span><br><span class="line">                    ans = std::<span class="built_in">max</span>(npa * minB, -nma * maxB);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>CSP</tag>
        <tag>2022</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title>「HNOI2006」公路修建问题 - 二分答案 + 最小生成树</title>
    <url>/hnoi2006-road/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2323">洛谷链接</a></p>
<p>OI island
是一个非常漂亮的岛屿，自开发以来，到这儿来旅游的人很多。然而，由于该岛屿刚刚开发不久，所以那里的交通情况还是很糟糕。所以，OIER
Association 组织成立了，旨在建立 OI island 的交通系统。</p>
<p>OI island 有 <span class="math inline">\(n\)</span>
个旅游景点，不妨将它们从 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 标号。现在，OIER Association
需要修公路将这些景点连接起来。一条公路连接两个景点。公路有，不妨称它们为一级公路和二级公路。一级公路上的车速快，但是修路的花费要大一些。</p>
<p>OIER Association 打算修 <span class="math inline">\(n-1\)</span>
条公路将这些景点连接起来（使得任意两个景点之间都会有一条路径）。为了保证公路系统的效率，
OIER Association 希望在这 <span class="math inline">\(n-1\)</span>
条公路之中，至少有 <span class="math inline">\(k\)</span> 条 <span
class="math inline">\((0 \le k \le n-1)\)</span> 一级公路。OIER
Association
也不希望为一条公路花费的钱。所以，他们希望在满足上述条件的情况下，花费最多的一条公路的花费尽可能的少。</p>
<p>而你的任务就是，在给定一些可能修建的公路的情况下，选择 <span
class="math inline">\(n-1\)</span> 条公路，满足上面的条件。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题求的是满足条件的最大公路花费的最小值。显然我们可以二分答案最长边的权值。</p>
<p>而对于本题中对一级公路的限制，我们可以在最长边权值限制下尽量多地选择一级公路构成生成树。在一级公路选完后再选二级公路。</p>
<p>最后通过调整二分，找出其中一级公路满足条件且所选边足够构成一棵树地最大边权的最小值即为答案。</p>
<p>本题同时要求输出方案，可在求生成树的时候同时把所选边存下来即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">2e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXC = <span class="number">3e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    <span class="type">int</span> c1, c2;</span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> c1 &lt; other.c1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[MAXM + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UFS</span> &#123;</span><br><span class="line">    <span class="type">int</span> f[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        f[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, m;</span><br><span class="line">std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; id[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; ids[MAXN];</span><br><span class="line">    ufs.<span class="built_in">init</span>(n);</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        Edge &amp;e = E[i];</span><br><span class="line">        <span class="keyword">if</span> (e.c1 &gt; limit) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(e.a) == ufs.<span class="built_in">find</span>(e.b)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ufs.<span class="built_in">merge</span>(e.a, e.b);</span><br><span class="line">        ids[++cnt] = std::<span class="built_in">make_pair</span>(e.id, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cnt &lt; k) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) id[i] = ids[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Edge &amp;e = E[i];</span><br><span class="line">        <span class="keyword">if</span> (e.c2 &gt; limit) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(e.a) == ufs.<span class="built_in">find</span>(e.b)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        ufs.<span class="built_in">merge</span>(e.a, e.b);</span><br><span class="line">        ids[++cnt] = std::<span class="built_in">make_pair</span>(e.id, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) id[i] = ids[i];</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;k, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = MAXC, r = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;E[i].a, &amp;E[i].b, &amp;E[i].c1, &amp;E[i].c2);</span><br><span class="line">        E[i].id = i;</span><br><span class="line">        l = std::<span class="built_in">min</span>(l, std::<span class="built_in">min</span>(E[i].c1, E[i].c2));</span><br><span class="line">        r = std::<span class="built_in">max</span>(r, std::<span class="built_in">max</span>(E[i].c1, E[i].c2));</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">sort</span>(E + <span class="number">1</span>, E + m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">solve</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">    std::<span class="built_in">sort</span>(id + <span class="number">1</span>, id + n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d %d\n&quot;</span>, id[i].first, id[i].second);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>最小生成树</tag>
        <tag>省选</tag>
        <tag>HNOI</tag>
        <tag>2006</tag>
      </tags>
  </entry>
  <entry>
    <title>GCC 使用及技巧</title>
    <url>/gcc-compiler/</url>
    <content><![CDATA[<blockquote>
<p>本文仅介绍 GCC 的使用以及在 OI 中使用的技巧，不涉及任何工程项目！</p>
</blockquote>
<h1 id="介绍">介绍</h1>
<p>GCC 不用多说，是指的 GNU 编写的 C  C++ 编译器。包含 gcc、g++、gdb
等软件。</p>
<span id="more"></span>
<h1 id="安装">安装</h1>
<p>大多数 C++ 的 IDE 都集成了 GCC（除了 Visual Studio 使用的 MSVC 和
Xcode 默认使用的是 Clang）（Visual Studio Code 和 Vim
等属于编辑器，不含有 GCC），若要安装 GCC 也很简单。</p>
<p>Windows 上可选择 <a
href="https://www.mingw-w64.org/">MinGW-w64</a>，macOS 可在安装 Homebrew
的基础上在终端输入 <code>brew install gcc</code> 安装。</p>
<p>Linux 上可使用 <code>sudo apt-get install build-essentia</code>
命令（对于 Debian 及其衍生发行版），对于其他发行版则使用
<code>sudo pacman -S gcc g++</code>（使用 Arch Linux 举例）。</p>
<p>如果你是 Windows 10 或 Windows 11 用户，强烈推荐使用 <a
href="https://docs.microsoft.com/zh-cn/windows/wsl/install">WSL2</a>
安装 Ubuntu，在 Ubuntu 中使用
GCC。这样可以避免本地与评测的环境差异。</p>
<p>安装成功后可用 <code>gcc -v</code> 或 <code>g++ -v</code>
检查安装。若安装成功应为下列输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Surface:~$ gcc -v</span><br><span class="line">Using built-in specs.</span><br><span class="line">COLLECT_GCC=gcc</span><br><span class="line">COLLECT_LTO_WRAPPER=/usr/lib/gcc/x86_64-linux-gnu/9/lto-wrapper</span><br><span class="line">OFFLOAD_TARGET_NAMES=nvptx-none:hsa</span><br><span class="line">OFFLOAD_TARGET_DEFAULT=1</span><br><span class="line">Target: x86_64-linux-gnu</span><br><span class="line">Configured with: ../src/configure -v --with-pkgversion=&#x27;Ubuntu 9.4.0-1ubuntu1~20.04.1&#x27; --with-bugurl=file:///usr/share/doc/gcc-9/README.Bugs --enable-languages=c,ada,c++,go,brig,d,fortran,objc,obj-c++,gm2 --prefix=/usr --with-gcc-major-version-only --program-suffix=-9 --program-prefix=x86_64-linux-gnu- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-vtable-verify --enable-plugin --enable-default-pie --with-system-zlib --with-target-system-zlib=auto --enable-objc-gc=auto --enable-multiarch --disable-werror --with-arch-32=i686 --with-abi=m64 --with-multilib-list=m32,m64,mx32 --enable-multilib --with-tune=generic --enable-offload-targets=nvptx-none=/build/gcc-9-Av3uEd/gcc-9-9.4.0/debian/tmp-nvptx/usr,hsa --without-cuda-driver --enable-checking=release --build=x86_64-linux-gnu --host=x86_64-linux-gnu --target=x86_64-linux-gnu</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04.1)</span><br></pre></td></tr></table></figure>
<h1 id="部分-ide-与编辑器下-gcc-的设置">部分 IDE 与编辑器下 GCC
的设置</h1>
<h2 id="dev-c">Dev-C++</h2>
<p>Dev-C++ 可在菜单栏中选择 工具，编译选项。之后会弹出下列窗口。</p>
<img src="/gcc-compiler/gcc-devcpp.png" class="">
<p>在窗口中“编译时加入一下命令”打勾，可在里面输入 GCC 参数（不含
<code>-o test</code>）。</p>
<h2 id="visual-studio-code">Visual Studio Code</h2>
<h3 id="code-runner">Code Runner</h3>
<p>在 Visual Studio Code 设置中点击“打开设置（json）”，在该 json
文件最外层大括号末尾添加下列语句：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;code-runner.executorMap&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;cpp&quot;</span><span class="punctuation">:</span> <span class="string">&quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>即可在 <code>"cpp"</code> 对应的字符串中修改 <code>g++</code>
参数。</p>
<h3 id="c-c-官方扩展">C / C++ 官方扩展</h3>
<p>在 Visual Studio Code 中打开编写程序的文件夹，打开一个 C++
文件，在菜单栏中点击 终端、配置默认生成任务。之后在弹出的 json 文件中
修改 <code>"args"</code> 参数即可。</p>
<h3 id="clangd">clangd</h3>
<p>打开文件夹，在文件夹下新建 <code>compile_flags.txt</code>
文件，在该文件中添加 GCC 编译选项即可（同样不含
<code>-o test</code>）</p>
<h1 id="编译">编译</h1>
<p>下文将以 <code>g++</code> 举例，<code>gcc</code> 同理。</p>
<p>GCC 可编译单文件，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp</span><br></pre></td></tr></table></figure>
<p>此时可生成一个文件 <code>a.out</code>（Windows 下为
<code>a.exe</code>）。</p>
<p>若想让生成的程序变成指定文件名，可使用下列语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -o test</span><br></pre></td></tr></table></figure>
<p>此时会生成名为 <code>test</code> 的文件（Windows 下为
<code>test.exe</code>）</p>
<p>若想使用新版本的特性，可使用下列指令（以 ISO C++ 14 为例）（目前的
NOI 系列比赛使用的 GCC 已默认开启 ISO C++ 14）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -std=c++14</span><br></pre></td></tr></table></figure>
<p>若想开启 O2 优化，可使用下列指令目前的 NOI 系列比赛使用的 GCC
<strong>未</strong> 默认开启 O2）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -O2</span><br></pre></td></tr></table></figure>
<p>若想使用 GDB 调试，则可以使用下列语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -g</span><br><span class="line">gdb a.out</span><br></pre></td></tr></table></figure>
<p>以上如
<code>-o</code>、<code>-std=c++14</code>、<code>-O2</code>、<code>-g</code>
以及下列将介绍的参数均可叠加使用。</p>
<h2 id="与-oi-无关的知识点">与 OI 无关的知识点</h2>
<p>众所周知宏观的编译操作分为编译、链接两大操作，GCC
也支持编译以及链接操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -c  # 编译，生成对象文件 test.o</span><br><span class="line">g++ test.o       # 链接，生成可执行文件 a.out</span><br></pre></td></tr></table></figure>
<h1 id="警告">警告</h1>
<p>GCC 编译会产生警告乃至报错，例如在 A + B Problem
中的输出语句忘加分号就会产生下列情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Laptop:~$ g++ test.cpp -O2 -o test</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:6:36: error: expected ‘;’ before ‘return’</span><br><span class="line">    6 |     std::cout &lt;&lt; a + b &lt;&lt; std::endl</span><br><span class="line">      |                                    ^</span><br><span class="line">      |                                    ;</span><br><span class="line">    7 |     return 0;</span><br><span class="line">      |     ~~~~~~</span><br></pre></td></tr></table></figure>
<p>该情况为报错，导致程序无法通过编译。</p>
<p>又例如在程序中定义了一个变量但始终未使用，编译将出现下列情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xenonwzh@XenonWZH-Laptop:~$ g++ test.cpp -O2 -Wall -o test</span><br><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:4:15: warning: unused variable ‘c’ [-Wunused-variable]</span><br><span class="line">    4 |     int a, b, c;</span><br><span class="line">      |</span><br></pre></td></tr></table></figure>
<p>该情况为警告，程序可以通过编译，但可能在运行中得不到想要的答案，若你对自己的程序很有把握可以忽略警告。</p>
<h2 id="产生更多的警告">产生更多的警告</h2>
<p>由于 GCC 能产生的警告少之又少，同时如 <code>=</code> 与
<code>==</code> 不分等常见错误在 GCC
的默认设置下不会警告，所以我们一般会在编译中添加参数以生成更多的警告，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -Wall</span><br></pre></td></tr></table></figure>
<p>利用该命令就可以产生如上一个例子的警告。</p>
<h2 id="忽略特定的警告">忽略特定的警告</h2>
<p>由于开启了 <code>-Wall</code>
容易误伤，所以我们可以利用参数忽略特定的警告。</p>
<p>例如我们使用了 <code>scanf</code> 函数，但是 GCC
警告我们没有使用该函数的返回值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test.cpp: In function ‘int main()’:</span><br><span class="line">test.cpp:18:14: warning: ignoring return value of ‘int scanf(const char*, ...)’, declared with attribute warn_unused_result [-Wunused-result]</span><br><span class="line">   18 |         scanf(&quot;%d%d%d&quot;, &amp;x, &amp;y, &amp;z);</span><br><span class="line">      |         ~~~~~^~~~~~~~~~~~~~~~~~~~~~</span><br></pre></td></tr></table></figure>
<p>我们可以在其中提取警告的类型。我们看到了
<code>[-Wunused-result]</code>，说明该类型为
<code>unused-result</code>。</p>
<p>我们可以使用 <code>-Wno</code> 参数来忽略警告，使用时应在
<code>-Wno</code> 后紧跟警告类型，例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -Wall -Wno-unused-result</span><br></pre></td></tr></table></figure>
<p>接下来就没有烦人的未使用 <code>scanf</code> 返回值的警告了。</p>
<h1 id="宏定义">宏定义</h1>
<p>我们可以利用 GCC 编译来代替 C++ 中简单的宏定义。</p>
<p>参数为 <code>-D</code>，使用时应紧跟定义宏。例子如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">g++ test.cpp -DDEBUG</span><br></pre></td></tr></table></figure>
<p>其中 <code>-DDEBUG</code> 相当于在 <code>test.cpp</code>
中添加下列语句：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DEBUG</span></span><br></pre></td></tr></table></figure>
<p>该参数可在调试或其他场合中使用，非常方便。</p>
<p>例如把调试的语句在定义 DEBUG 宏时才执行，文件输入输出在没定义 DEBUG
时执行，在考场上可有效避免非知识原因的爆 0。</p>
<p>同时注意在绝大多数 OJ 编译代码时参数都含有
<code>-DONLINE_JUDGE</code>，可以利用该特性提升刷题体验。</p>
]]></content>
      <categories>
        <category>OI</category>
        <category>其他</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>差分约束学习笔记</title>
    <url>/differential-constraints-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>差分约束指的是一种 <span class="math inline">\(n\)</span>
元一次不等式组。令有 <span class="math inline">\(n\)</span> 个未知数
<span class="math inline">\(x_1, x_2, \cdots, x_n\)</span>，<span
class="math inline">\(m\)</span> 个形如 <span class="math inline">\(x_i
- x_j \leq c_k\)</span>
不等式，利用差分约束我们可以求出满足条件的解，或判断无解。</p>
<span id="more"></span>
<h1 id="实现方法">实现方法</h1>
<h2 id="模型转化">模型转化</h2>
<p>我们先观察 Bellman-Ford
最短路算法。该算法有松弛操作（<code>w(u, v)</code> 指的是边 <span
class="math inline">\(&lt;u, v&gt;\)</span> 的权值）
<code>dis[v] = std::min(dis[v], dis[u] + w(u, v))</code>，故在最短路种必定满足
<span class="math inline">\(dis[v] \leq dis[u] + w(u,
v)\)</span>，转化一下即为 <span class="math inline">\(dis[v] - dis[u]
\leq w(u, v)\)</span>。</p>
<p>观察该不等式与差分约束的关系，可把差分约束中 <span
class="math inline">\(x_i - x_j \leq c_k\)</span> 转化为边权为 <span
class="math inline">\(c_k\)</span>，连通 <span
class="math inline">\(&lt;j, i&gt;\)</span>
的有向边。利用此方法可将差分约束转化为图上单源最短路问题。</p>
<h2 id="求解">求解</h2>
<p>由于通过转化权值可能为负，我们可使用 Bellman-Ford 或 SPFA 算法。</p>
<p>首先对于不等式 <span class="math inline">\(x_i - x_j \leq
c_k\)</span>，在点 <span class="math inline">\(i\)</span> 与点 <span
class="math inline">\(j\)</span> 中连一条权值为 <span
class="math inline">\(c_k\)</span> 的边。</p>
<p>由于没有确定的起始点，我们需要再新建一个超级源点，且使超级源点和所有点相连，相连的边的权值均设为
<span class="math inline">\(0\)</span>。</p>
<p>最后通过 Bellman-Ford 或
SPFA，求出超级源点的单源最短路。最后求出的单源最短路 <span
class="math inline">\(\left \{ dis_1, dis_2, \cdots, dis_n \right
\}\)</span> 即为所求解。若图中出现负环，则无解。</p>
<p>注意对于任意常数 <span class="math inline">\(r\)</span>，<span
class="math inline">\(\left \{ dis_1 + r, dis_2 + r, \cdots, dis_n + r
\right \}\)</span> 由于在差分约束中 <span
class="math inline">\(r\)</span> 在运算中会被抵消，故也为所求解。</p>
<h1 id="常见转化">常见转化</h1>
<p>摘自 OI-wiki</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 43%" />
<col style="width: 34%" />
</colgroup>
<thead>
<tr class="header">
<th>公式</th>
<th>转化</th>
<th>连边</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(x_a - x_b \geq c\)</span></td>
<td><span class="math inline">\(x_b - x_a \leq -c\)</span></td>
<td><code>add(a, b, -c)</code></td>
</tr>
<tr class="even">
<td><span class="math inline">\(x_a - x_b \leq c\)</span></td>
<td><span class="math inline">\(x_a - x_b \leq c\)</span></td>
<td><code>add(b, a, c)</code></td>
</tr>
<tr class="odd">
<td><span class="math inline">\(x_a = x_b\)</span></td>
<td><span class="math inline">\(x_a - x_b \leq 0, x_b - x_a \leq
0\)</span></td>
<td><code>add(b, a, 0), add(a, b, 0)</code></td>
</tr>
</tbody>
</table>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P1993">洛谷 P1993 小 K
的农场</a></p>
<p>显然这是道差分约束的题，同时对输入的三种情况简单地用上述方法转换一下即可。</p>
<p>代码如下（注意开 O2）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dis[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">bf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> con;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        con = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> each : e[j]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dis[each.first] &gt; dis[j] + each.second) &#123;</span><br><span class="line">                    dis[each.first] = dis[j] + each.second;</span><br><span class="line">                    con = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!con) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> con;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, op, a, b, c; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, -c) );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;a, &amp;b, &amp;c);</span><br><span class="line">            e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, c) );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">            e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">0</span>) );</span><br><span class="line">            e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">0</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将0作为超级源点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[<span class="number">0</span>].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(i, <span class="number">0</span>) );</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (<span class="built_in">bf</span>() ? <span class="string">&quot;No&quot;</span> : <span class="string">&quot;Yes&quot;</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>「HAOI2007」反素数 - 数论 + DFS</title>
    <url>/haoi2007-ant/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1463">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10203">LOJ 链接</a></p>
<p>对于任何正整数 <span
class="math inline">\(x\)</span>，其约数的个数记作 <span
class="math inline">\(g(x)\)</span>。例如 <span
class="math inline">\(g(1) = 1\)</span>，<span
class="math inline">\(g(6) = 4\)</span>。</p>
<p>如果某个正整数 <span class="math inline">\(x\)</span> 满足：<span
class="math inline">\(\forall 0 &lt; i &lt; x\)</span>，都有 <span
class="math inline">\(g(x) &lt; g(i)\)</span>，则称 <span
class="math inline">\(x\)</span> 为反质数。例如，整数 <span
class="math inline">\(1, 2, 4, 6\)</span> 等都是反质数。</p>
<p>现在给定一个数 <span class="math inline">\(N\)</span>，你能求出不超过
<span class="math inline">\(N\)</span> 的最大的反质数么？</p>
<p>数据范围：<span class="math inline">\(1 \leq N \leq 2 \times
10^9\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="数学证明">数学证明</h2>
<p>首先我们有如下结论：</p>
<ol type="1">
<li><p>小于等于 <span class="math inline">\(N\)</span>
的最大反质数为约数个数中多的数中最小的一个。</p></li>
<li><p>小于等于 <span class="math inline">\(N\)</span>
的不同的质因数个数都不会超过 <span
class="math inline">\(10\)</span>，且所有质因数个数的和不超过 <span
class="math inline">\(30\)</span>。</p></li>
<li><p>若 <span class="math inline">\(x\)</span> 为反质数，则 <span
class="math inline">\(x\)</span> 必定满足： <span
class="math display">\[
\begin{cases}
x = 2^{p_1} \times 3^{p_2} \times 5^{p_3} \times 7^{p_4} \times 11^{p_5}
\times 13^{p_6} \times 17^{p_7} \times 19^{p_8} \times 23^{p_9} \times
29^{p_{10}} \\
p_1 \geq p_2 \geq p_3 \geq \cdots \geq p_{10} \geq 0
\end{cases}
\]</span></p></li>
</ol>
<p>接下来为证明：</p>
<ol type="1">
<li><p>对于结论 <span class="math inline">\(1\)</span>，我们设 <span
class="math inline">\(x\)</span>
为约数最多的数中最小的一个。则有以下结论：</p>
<ol type="1">
<li><p><span class="math inline">\(\forall y &lt; x \Rightarrow g(y)
&lt; g(x)\)</span>，即 <span class="math inline">\(x\)</span>
为反质数。</p></li>
<li><p><span class="math inline">\(\forall y &gt; x \Rightarrow g(y)
\leq g(x)\)</span>，即大于 <span class="math inline">\(x\)</span>
的数都不为反质数。</p></li>
</ol></li>
<li><p>对于结论 <span class="math inline">\(2\)</span>，显然 <span
class="math inline">\(2 \times 3 \times 5 \times 7 \times 11 \times 13
\times 17 \times 19 \times 23 \times 29 \times 31&gt; 2 \times
10^9\)</span>， 故不可能会有拥有超过 <span
class="math inline">\(10\)</span> 个不同的质因数的数小于等于 <span
class="math inline">\(2 \times 10^9\)</span>。且 <span
class="math inline">\(2 ^ {31} &gt; 2 \times 10^9\)</span>，故小于 <span
class="math inline">\(2 \times 10^9\)</span> 的数的质因数个数不可能大于
<span class="math inline">\(30\)</span>。</p></li>
<li><p>对于结论 <span
class="math inline">\(3\)</span>，我们可以使用反证法。设 <span
class="math inline">\(x\)</span> 为反质数且满足 <span
class="math inline">\(i &lt; j\)</span> 且 <span
class="math inline">\(p_i &gt; p_j\)</span>，则令 <span
class="math inline">\(y\)</span> 的 <span
class="math inline">\(p_i\)</span> 项比 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(p_i\)</span> 多 <span
class="math inline">\(1\)</span>，<span class="math inline">\(y\)</span>
的 <span class="math inline">\(p_j\)</span> 项比 <span
class="math inline">\(x\)</span> 的 <span
class="math inline">\(p_j\)</span> 少 <span
class="math inline">\(1\)</span>，<span class="math inline">\(p\)</span>
的其余项相等。显然 <span class="math inline">\(x &lt; y\)</span> 且
<span class="math inline">\(g(x) = g(y)\)</span>，<span
class="math inline">\(x\)</span>
不为反质数，故矛盾，原结论成立。</p></li>
</ol>
<h2 id="dfs">DFS</h2>
<p>接下来我们可以设最大反质数为:</p>
<p><span class="math display">\[
x = 2^{p_1} \times 3^{p_2} \times 5^{p_3} \times 7^{p_4} \times 11^{p_5}
\times 13^{p_6} \times 17^{p_7} \times 19^{p_8} \times 23^{p_9} \times
29^{p_{10}}
\]</span></p>
<p>通过 DFS 枚举 <span class="math inline">\(p\)</span>
数组的所有情况。时间复杂度小于 <span
class="math inline">\(O(n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n;</span><br><span class="line"><span class="type">int</span> p[<span class="number">10</span>], pAns[<span class="number">10</span>], m[<span class="number">10</span>] = &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">17</span>, <span class="number">19</span>, <span class="number">23</span>, <span class="number">29</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((b &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans *= a;</span><br><span class="line">        &#125;</span><br><span class="line">        a *= a;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calcP</span><span class="params">(<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++) ans *= <span class="built_in">power</span>(m[i], p[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sumP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) ans *= p[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">calcAns</span><span class="params">(<span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; end; i++) ans *= <span class="built_in">power</span>(m[i], pAns[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">sumAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) ans *= pAns[i] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sumP</span>() &gt;= <span class="built_in">sumAns</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">sumP</span>() &gt; <span class="built_in">sumAns</span>()) <span class="built_in">memcpy</span>(pAns, p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">calcP</span>(<span class="number">10</span>) &lt; <span class="built_in">calcAns</span>(<span class="number">10</span>)) <span class="built_in">memcpy</span>(pAns, p, <span class="built_in">sizeof</span>(p));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxn = <span class="built_in">calcP</span>(step), before = step == <span class="number">0</span> ? (<span class="type">long</span> <span class="type">long</span>) <span class="number">2e9</span> : p[step - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">0</span>; <span class="built_in">power</span>(m[step], i) * maxn &lt;= n &amp;&amp; i &lt;= before; i++) &#123;</span><br><span class="line">        p[step] = i;</span><br><span class="line">        <span class="built_in">dfs</span>(step + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, <span class="built_in">sizeof</span>(p));</span><br><span class="line">    <span class="built_in">memset</span>(pAns, <span class="number">0</span>, <span class="built_in">sizeof</span>(pAns));</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">calcAns</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>DFS</tag>
        <tag>省选</tag>
        <tag>数论</tag>
        <tag>HAOI</tag>
        <tag>2007</tag>
        <tag>POI</tag>
        <tag>2001</tag>
      </tags>
  </entry>
  <entry>
    <title>「HAOI2011」Problem b - 莫比乌斯反演</title>
    <url>/haoi2011-problemb/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2522">洛谷链接</a></p>
<p>对于给出的 <span class="math inline">\(n\)</span>
个询问，每次求有多少个数对 <span
class="math inline">\((x,y)\)</span>，满足 <span class="math inline">\(a
\le x \le b\)</span>，<span class="math inline">\(c \le y \le
d\)</span>，且 <span class="math inline">\(\gcd(x,y) = k\)</span>，<span
class="math inline">\(\gcd(x,y)\)</span> 函数为 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span> 的最大公约数。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据满足：<span
class="math inline">\(1 \le n,k \le 5 \times 10^4\)</span>，<span
class="math inline">\(1 \le a \le b \le 5 \times 10^4\)</span>，<span
class="math inline">\(1 \le c \le d \le 5 \times 10^4\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题要求以下式子的值：</p>
<p><span class="math display">\[
\sum_{x = a}^b{ \sum_{y = c}^d{ [\gcd(x, y) = k] } }
\]</span></p>
<p>看到单元函数我们可以想到尝试用莫比乌斯反演化简。</p>
<p>首先我们设函数 <span class="math inline">\(A(n, m, k) = \sum_{i =
1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) = k] }
}\)</span>，由容斥原理易得答案为 <span class="math inline">\(A(b, d, k)
- A(a - 1, d, k) - A(b, c - 1, k) + A(a - 1, c - 1, k)\)</span>。</p>
<p>于是我们只需求出 <span class="math inline">\(A(n, m, k)\)</span>
的值即可。设以下函数：</p>
<p><span class="math display">\[
f(k) = \sum_{i = 1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) = k] } }
\]</span></p>
<p><span class="math display">\[
F(d) = \sum_{d | k}{f(k)}
\]</span></p>
<p>我们可以将函数 <span class="math inline">\(F(d)\)</span>
进行化简：</p>
<p><span class="math display">\[
\begin{align*}
F(d) &amp;= \sum_{d | k}{f(k)} \\
&amp;= \sum_{d | k}{ \sum_{i = 1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) = k] }
} } \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{d} \rfloor , \lfloor
\frac{m}{d} \rfloor \} }{ \sum_{i = 1}^n{ \sum_{j = 1}^m{ [\gcd(i, j) =
td] } } } \\
&amp;= \sum_{i = 1}^n{ \sum_{j = 1}^m{ [d | \gcd(i, j)] } } \\
&amp;= \sum_{i = 1}^n{ \sum_{j = 1}^m{ [d | i][d | j] } } \\
&amp;= \lfloor \frac{n}{d} \rfloor \lfloor \frac{m}{d} \rfloor
\end{align*}
\]</span></p>
<p>又由于 <span class="math inline">\(F(d) = \sum_{d |
k}{f(k)}\)</span>，我们可以进行莫比乌斯反演：</p>
<p><span class="math display">\[
f(k) = \sum_{k | d}{\mu(\frac{d}{k})F(d)}
\]</span></p>
<p>然后接着进行化简：</p>
<p><span class="math display">\[
\begin{align*}
f(k) &amp;= \sum_{k | d}{\mu(\frac{d}{k})F(d)} \\
&amp;= \sum_{k | d}{\mu(\frac{d}{k}) \lfloor \frac{n}{d} \rfloor \lfloor
\frac{m}{d} \rfloor } \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{\mu(t) \lfloor \frac{n}{tk} \rfloor \lfloor
\frac{m}{tk} \rfloor }
\end{align*}
\]</span></p>
<p>于是我们可以得出：</p>
<p><span class="math display">\[
A(n, m, k) = \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{\mu(t) \lfloor \frac{n}{tk} \rfloor \lfloor
\frac{m}{tk} \rfloor }
\]</span></p>
<p>此时对于单词询问的时间复杂度为 <span
class="math inline">\(O(n)\)</span>，直接运行 <span
class="math inline">\(A(n, m, k)\)</span> 会
TLE，故我们还要进行进一步的优化。</p>
<p>我们可以发现在 <span class="math inline">\(A(n, m, k)\)</span>
中大量出现 <span class="math inline">\(\lfloor \frac{n}{k}
\rfloor\)</span> 与 <span class="math inline">\(\lfloor \frac{m}{k}
\rfloor\)</span>，于是我们可以考虑将其提前计算。</p>
<p>我们定义以下函数：</p>
<p><span class="math display">\[
n&#39; = \lfloor \frac{n}{k} \rfloor, m&#39; = \lfloor \frac{m}{k}
\rfloor
\]</span></p>
<p><span class="math display">\[
A&#39;(n&#39;, m&#39;) = A(n, m, k) = \sum_{t = 1}^{ \min\{n&#39;,
m&#39;\} }{\mu(t) \lfloor \frac{n&#39;}{t} \rfloor \lfloor
\frac{m&#39;}{t} \rfloor }
\]</span></p>
<p>对于 <span class="math inline">\(A&#39;(n&#39;,
m&#39;)\)</span>，我们可以先统计出 <span
class="math inline">\(\mu(t)\)</span>
的前缀和，再用数论分块求解。这时候的单词询问时间复杂度优化到了 <span
class="math inline">\(O(\sqrt{n})\)</span>，可过此题。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="type">int</span> sumMu[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sumMu[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    n /= k, m /= k;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r; l &lt;= std::<span class="built_in">min</span>(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (sumMu[r] - sumMu[l - <span class="number">1</span>]) * ((n / l) * (m / l));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getPrimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, c, d, k;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d, &amp;k);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">f</span>(b, d, k) - <span class="built_in">f</span>(a - <span class="number">1</span>, d, k) - <span class="built_in">f</span>(b, c - <span class="number">1</span>, k) + <span class="built_in">f</span>(a - <span class="number">1</span>, c - <span class="number">1</span>, k));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>省选</tag>
        <tag>数论</tag>
        <tag>HAOI</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>2011</tag>
      </tags>
  </entry>
  <entry>
    <title>最近公共祖先学习笔记</title>
    <url>/lca-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>最近公共祖先（英文 Lowest Common Ancestor，简称
LCA）定义为树种两个点的公共祖先里面，离根最远的一个。</p>
<span id="more"></span>
<h1 id="实现方法">实现方法</h1>
<h2 id="朴素算法">朴素算法</h2>
<p>先算出两点的深度，取深度最小值，不停寻找父结点直到该深度。之后两点同时找父结点，直到两者的父结点相同，该父结点即为最近公共祖先。易得时间复杂度为
<span class="math inline">\(O(n)\)</span>。</p>
<h2 id="倍增算法">倍增算法</h2>
<h3 id="预处理">预处理</h3>
<p>记录一个数组 <code>fa[u][i]</code>，记录的是结点 <span
class="math inline">\(u\)</span> 向上寻找 <span
class="math inline">\(2^i\)</span> 次父结点所达到的结点，如果不存在则为
<span class="math inline">\(0\)</span>。</p>
<p>可通过二进制拆分 <span class="math inline">\(u\)</span>
的深度（<a href="/bitwise-operator-notes/" title="拆分过程详见之前《位运算学习笔记》博客中的“快速幂”章节">拆分过程详见之前《位运算学习笔记》博客中的“快速幂”章节</a> ），在 <span class="math inline">\(O(\log
n)\)</span> 的时间复杂度下算出
<code>fa[u][i]</code>。利用该方法可以利用递归在 <span
class="math inline">\(O(n \log n)\)</span> 的时间复杂度内预处理完
<code>fa</code> 数组。</p>
<p>下列为预处理 <code>fa</code> 的代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFa</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) fa[u][i] = fa[ fa[u][i - <span class="number">1</span>] ][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getFa</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="寻找-lca">寻找 LCA</h3>
<p>与朴素算法类似，不同之处是利用二进制和 <code>fa</code> 数组将复杂度从
<span class="math inline">\(O(n)\)</span> 优化到 <span
class="math inline">\(O(\log n)\)</span>。</p>
<p>原理是从远及近遍历 <code>fa</code>
数组，直到两结点同深度的祖先不相同，此时 <span
class="math inline">\(LCA\)</span>
必定在两祖先之上，然后在祖先之上再次使用 <code>fa</code> 数组遍历，直到
<code>fa[u][0] == fa[v][0]</code> 时，<span
class="math inline">\(LCA\)</span> 为 <span
class="math inline">\(u\)</span> 或 <span
class="math inline">\(v\)</span> 的父结点。该过程相当于将 <span
class="math inline">\(LCA\)</span> 与 <span
class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>
的深度差拆分成若干个 <span class="math inline">\(2\)</span>
的幂，减少了运算次数，加快运行效率。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[ fa[u][i] ] &gt;= dep[v] ) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="算法复杂度统计">算法复杂度统计</h2>
<table>
<thead>
<tr class="header">
<th>算法</th>
<th>预处理</th>
<th>q 次查询</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>朴素算法</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(qn)\)</span></td>
</tr>
<tr class="even">
<td>倍增算法</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(q \log n)\)</span></td>
</tr>
<tr class="odd">
<td>欧拉序转 RMQ</td>
<td><span class="math inline">\(O(n \log n)\)</span></td>
<td><span class="math inline">\(O(q)\)</span></td>
</tr>
<tr class="even">
<td>Tarjan</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(n + q)\)</span></td>
</tr>
<tr class="odd">
<td>树链剖分</td>
<td><span class="math inline">\(O(n)\)</span></td>
<td><span class="math inline">\(O(q \log n)\)</span></td>
</tr>
</tbody>
</table>
<h1 id="例题">例题</h1>
<p><a href="https://loj.ac/p/10130">LOJ #10130. 「一本通 4.4 例
1」点的距离</a></p>
<p>本题由于是树，可利用树的特性做题。</p>
<p>这里可以使用 <span class="math inline">\(LCA\)</span>。因 <span
class="math inline">\(x\)</span>、<span class="math inline">\(y\)</span>
的最短路径种必定会经过 <span
class="math inline">\(LCA\)</span>，故可以将该题转化为求 <span
class="math inline">\(LCA\)</span> 分别与点 <span
class="math inline">\(x\)</span> 和点 <span
class="math inline">\(y\)</span> 的距离。</p>
<p>先求出点 <span class="math inline">\(x\)</span> 与点 <span
class="math inline">\(y\)</span> 的 <span
class="math inline">\(LCA\)</span>，再将 <span
class="math inline">\(LCA\)</span> 与点 <span
class="math inline">\(x\)</span>、点 <span
class="math inline">\(y\)</span> 的深度差相加即为答案。</p>
<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> fa[MAXN + <span class="number">1</span>][<span class="number">25</span>], dep[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getFa</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> f)</span> </span>&#123;</span><br><span class="line">    fa[u][<span class="number">0</span>] = f;</span><br><span class="line">    dep[u] = dep[f] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) fa[u][i] = fa[ fa[u][i - <span class="number">1</span>] ][i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : e[u]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">getFa</span>(v, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lca</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dep[ fa[u][i] ] &gt;= dep[v] ) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">20</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fa[u][i] != fa[v][i]) &#123;</span><br><span class="line">            u = fa[u][i];</span><br><span class="line">            v = fa[v][i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fa[u][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line">        e[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        e[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">getFa</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    std::cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> root = <span class="built_in">lca</span>(x, y);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, dep[x] + dep[y] - <span class="number">2</span> * dep[root]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1182」数列分段 Section II - 二分答案</title>
    <url>/luogu-1182/</url>
    <content><![CDATA[<p><del>学完 wxk 的康复训练</del></p>
<blockquote>
<p>学 wxk 学久了感觉 wxk 有意思，学 OI 学久了感觉 OI 有意思。
——huaruoji</p>
</blockquote>
<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1182">洛谷链接</a></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的整形数列
<span class="math inline">\(A_{1 \sim n}\)</span>，先将其分为 <span
class="math inline">\(m\)</span>
段，并要求每段连续，目前需要一种分法，使得分出的每段和的最大值最小。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="整体框架">整体框架</h2>
<p>求最大值最小，显然是一道二分答案题，可以尝试使用二分答案解决问题。</p>
<p>这道题二分答案的方法是二分每段和的最大值，从答案的最大值 <span
class="math inline">\(10^9\)</span>
开始二分。注意二分的最小值为整个数列的单个元素最大值，否则可能会出现最后答案小于数列中的某个数，导致无法分割数列的情况（例如洛谷数据中的第四个测试点）。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> l = <span class="number">1</span>, r = MAXN * MAXA;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    std::cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">if</span> (a[i] &gt; l) l = a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 二分处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h2 id="细节处理">细节处理</h2>
<p>现在我们已经处理完了，现在的问题是二分出答案后如何检验。</p>
<p>这块可以使用类似均分纸牌的思路，使用贪心解决。</p>
<p>在数列的开头开始扫，不停的加数列中的数，若和大于答案，则把和清空为最后加入的一个数，段数
+1。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum += a[i];</span><br><span class="line">    <span class="keyword">if</span> (sum &gt; mid) &#123;</span><br><span class="line">        sum = a[i];</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后如果段数大于 <span
class="math inline">\(m\)</span>，则说明答案过小，答案在 <span
class="math inline">\(mid\)</span> 之上。</p>
<p>如果段数小于 <span
class="math inline">\(m\)</span>，则说明答案过大，答案在 <span
class="math inline">\(mid\)</span> 之下。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cnt &lt;= m) r = mid;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt; m) l = mid + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>, MAXA = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = MAXN * MAXA;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] &gt; l) l = a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            sum += a[i];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; mid) &#123;</span><br><span class="line">                sum = a[i];</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cnt &lt;= m) r = mid;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt; m) l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; l &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「JSOI2010」满汉全席 - 2-SAT</title>
    <url>/jsoi2010-banquet/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4171">洛谷链接</a></p>
<p>大会的规则如下：每位参赛的选手可以得到 <span
class="math inline">\(n\)</span>
种材料，选手可以自由选择用满式或是汉式料理将材料当成菜肴。</p>
<p>大会的评审制度是：共有 <span class="math inline">\(m\)</span>
位评审员分别把关。只要参赛者能在这两种材料的做法中，其中一个符合评审的喜好即可通过该评审的审查。</p>
<p>但大会后来发现，在这样的制度下如果材料选择跟派出的评审员没有特别安排好的话，所有的参赛者最多只能通过部分评审员的审查而不是全部，所以可能会发生没有人通过考核的情形。</p>
<p>所以大会希望有人能写一个程序来判断，所选出的 <span
class="math inline">\(m\)</span>
位评审，会不会发生没有人能通过考核的窘境，以便协会组织合适的评审团。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这是一个 2-SAT 问题。</p>
<p>把 <span class="math inline">\(\text{h}x\)</span> 对应为 <span
class="math inline">\(x\)</span> 节点，把 <span
class="math inline">\(\text{m}x\)</span> 对应为 <span
class="math inline">\(n + x\)</span> 节点。对于一组限制 <span
class="math inline">\(x\)</span>，<span
class="math inline">\(y\)</span>，则说明若选了 <span
class="math inline">\(x \pm n\)</span> 则必选 <span
class="math inline">\(y\)</span>，或若选了 <span class="math inline">\(y
\pm n\)</span> 则必选 <span
class="math inline">\(x\)</span>（前者若为汉式则取加号，若为满式则取减号）。然后跑一遍
2-SAT 就可得出答案。</p>
<p>每组数据前注意要把图清空。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> dfn, low;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Connected</span> *connected;</span><br><span class="line">&#125; N[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Connected</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, id;</span><br><span class="line">&#125; connecteds[<span class="number">2</span> * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>, counts = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::stack&lt;Node *&gt; stk;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++num;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    x-&gt;v = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;x-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;x-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e-&gt;t-&gt;dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e-&gt;t);</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;t-&gt;v) &#123;</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;dfn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;dfn == x-&gt;low) &#123;</span><br><span class="line">        counts++;</span><br><span class="line">        connecteds[counts].id = counts;</span><br><span class="line">        Node *y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            y-&gt;v = <span class="literal">false</span>;</span><br><span class="line">            y-&gt;connected = &amp;connecteds[counts];</span><br><span class="line">            connecteds[counts].size++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * MAXN; i++) &#123;</span><br><span class="line">        N[i].e.<span class="built_in">clear</span>();</span><br><span class="line">        N[i].dfn = N[i].low = <span class="number">0</span>;</span><br><span class="line">        N[i].v = <span class="literal">false</span>;</span><br><span class="line">        N[i].connected = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * MAXN; i++) &#123;</span><br><span class="line">        connecteds[i].size = connecteds[i].id = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">prepare</span>(n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">            <span class="type">int</span> i, j;</span><br><span class="line">            <span class="type">char</span> a = <span class="string">&#x27; &#x27;</span>, b = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isspace</span>(a)) a = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;i);</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">isspace</span>(b)) b = <span class="built_in">getchar</span>();</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;j);</span><br><span class="line">            a = a == <span class="string">&#x27;h&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            b = b == <span class="string">&#x27;h&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (a &amp;&amp; b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i + n, j);</span><br><span class="line">                <span class="built_in">addEdge</span>(j + n, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!a &amp;&amp; b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i, j);</span><br><span class="line">                <span class="built_in">addEdge</span>(j + n, i + n);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a &amp;&amp; !b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i + n, j + n);</span><br><span class="line">                <span class="built_in">addEdge</span>(j, i);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!a &amp;&amp; !b) &#123;</span><br><span class="line">                <span class="built_in">addEdge</span>(i, j + n);</span><br><span class="line">                <span class="built_in">addEdge</span>(j, i + n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!N[i].dfn) &#123;</span><br><span class="line">                <span class="built_in">tarjan</span>(&amp;N[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N[i].connected == N[n + i].connected) &#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) <span class="built_in">puts</span>(<span class="string">&quot;GOOD&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;BAD&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>省选</tag>
        <tag>2-SAT</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>JSOI</tag>
        <tag>2010</tag>
      </tags>
  </entry>
  <entry>
    <title>「JSOI2008」球形空间产生器 - 高斯消元</title>
    <url>/jsoi2008-sphere/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4035">洛谷链接</a></p>
<p>有一个球形空间产生器能够在 <span class="math inline">\(n\)</span>
维空间中产生一个坚硬的球体。现在，你被困在了这个 <span
class="math inline">\(n\)</span> 维球体中，你只知道球面上 <span
class="math inline">\(n + 1\)</span>
个点的坐标，你需要以最快的速度确定这个 <span
class="math inline">\(n\)</span>
维球体的球心坐标，以便于摧毁这个球形空间产生器。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于本题，我们可以感性感知到这道题是高斯消元。于是我们可以通过距离公式推出下列式子：</p>
<p><span class="math display">\[
\sum_{j = 1}^{n} (a_{i, j} - x_j)^2 = \text{dis} \quad i \in [1, n] \cap
\mathbb{Z}
\]</span></p>
<p>其中 <span class="math inline">\(\text{dis}\)</span> 为常量。</p>
<p>对于该式化简会出现二次项，不好计算，我们需要把二次项化掉，同时化掉
<span class="math inline">\(\text{dis}\)</span>。</p>
<p>于是我们可以将相邻两项作差，得到下列式子：</p>
<p><span class="math display">\[
\sum_{j = 1}^{n} ( a_{i, j}^2 - a_{i + 1, j}^2 - 2(a_{i, j} - a_{i + 1,
j})x_j ) = 0 \quad i \in [1, n] \cap \mathbb{Z}
\]</span></p>
<p>然后移项得到下列式子：</p>
<p><span class="math display">\[
\sum_{j = 1}^{n} 2(a_{i, j} - a_{i + 1})x_j = \sum_{j = 1}^{n} (a_{i,
j}^2 - a_{i + 1, j}^2) \quad i \in [1, n] \cap \mathbb{Z}
\]</span></p>
<p>由于 <span class="math inline">\(a_{i, j}\)</span>，<span
class="math inline">\(n\)</span> 为常量，故 <span
class="math inline">\(x_j\)</span> 可用高斯消元求解，最后得解。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> pos[MAXN + <span class="number">2</span>][MAXN + <span class="number">1</span>], a[MAXN + <span class="number">1</span>][MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) a[i][j] /= a[i][i];</span><br><span class="line">        a[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                a[j][k] -= a[i][k] * a[j][i] / a[i][i];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            a[j][n + <span class="number">1</span>] -= a[i][n + <span class="number">1</span>] * a[j][i] / a[i][i];</span><br><span class="line">            a[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        a[i][n + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            a[i][j] = <span class="number">2</span> * (pos[i][j] - pos[i + <span class="number">1</span>][j]);</span><br><span class="line">            a[i][n + <span class="number">1</span>] += pos[i][j] * pos[i][j] - pos[i + <span class="number">1</span>][j] * pos[i + <span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            std::cin &gt;&gt; pos[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f &quot;</span>, a[i][n + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>JSOI</tag>
        <tag>高斯消元</tag>
        <tag>2008</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1407」稳定婚姻 - 强连通分量</title>
    <url>/luogu-1407/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1407">洛谷链接</a></p>
<p>我们已知 <span class="math inline">\(n\)</span>
对夫妻的婚姻状况，称第 <span class="math inline">\(i\)</span>
对夫妻的男方为 <span class="math inline">\(B_i\)</span>，女方为 <span
class="math inline">\(G_i\)</span>。若某男 <span
class="math inline">\(B_i\)</span> 与某女 <span
class="math inline">\(G_j\)</span>
曾经交往过（无论是大学，高中，亦或是幼儿园阶段，<span
class="math inline">\(i \le j\)</span>），则当某方与其配偶（即 <span
class="math inline">\(B_i\)</span> 与 <span
class="math inline">\(G_i\)</span>或 <span
class="math inline">\(B_j\)</span> 与 <span
class="math inline">\(G_j\)</span>）感情出现问题时，他们有私奔的可能性。不妨设
<span class="math inline">\(B_i\)</span> 和其配偶 <span
class="math inline">\(G_i\)</span> 感情不和，于是 <span
class="math inline">\(B_i\)</span> 和 <span
class="math inline">\(G_j\)</span> 旧情复燃，进而 <span
class="math inline">\(B_j\)</span>
因被戴绿帽而感到不爽，联系上了他的初恋情人 <span
class="math inline">\(G_k\)</span>……一串串的离婚事件像多米诺骨牌一般接踵而至。若在
<span class="math inline">\(B_i\)</span> 和 <span
class="math inline">\(G_i\)</span> 离婚的前提下，这 <span
class="math inline">\(2n\)</span> 个人最终依然能够结合成 <span
class="math inline">\(n\)</span> 对情侣，那么我们称婚姻 <span
class="math inline">\(i\)</span> 为不安全的，否则婚姻 <span
class="math inline">\(i\)</span> 就是安全的。</p>
<p>给定所需信息，你的任务是判断每对婚姻是否安全。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题考得是图的连通性。</p>
<p>由于若一人感情不和，随之不和的是异性，我们可以在异性之间连有向边。</p>
<p>于是我们可以考虑用以下方式建图：</p>
<ul>
<li><p>对于夫妻，我们连一条 <span class="math inline">\(G_i \rightarrow
B_i\)</span> 的有向边；</p></li>
<li><p>对于情侣，我们连一条 <span class="math inline">\(B_i \rightarrow
G_j\)</span> 的有向边。</p></li>
</ul>
<p>接下来跑一边 Tarjan 求强连通分量。若 <span
class="math inline">\(G_i\)</span> 和 <span
class="math inline">\(B_i\)</span>
在同一个强连通分量中，则他们的婚姻是不安全的。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">4000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> *edges;</span><br><span class="line">    <span class="type">int</span> dfn, low;</span><br><span class="line">    <span class="type">bool</span> visited;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Connected</span> *connected;</span><br><span class="line">&#125; N[<span class="number">2</span> * MAXN];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *from, *to;</span><br><span class="line">    Edge *next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *from, Node *to) : <span class="built_in">from</span>(from), <span class="built_in">to</span>(to), <span class="built_in">next</span>(from-&gt;edges) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Connected</span> &#123;</span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">&#125; connecteds[<span class="number">2</span> * MAXN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::string girl[MAXN], boy[MAXN];</span><br><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; mp;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to)</span> </span>&#123;</span><br><span class="line">    N[from].edges = <span class="keyword">new</span> <span class="built_in">Edge</span>(&amp;N[from], &amp;N[to]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>, counts = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::stack&lt;Node *&gt; stk;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++num;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    x-&gt;visited = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *edges = x-&gt;edges; edges; edges = edges-&gt;next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!edges-&gt;to-&gt;dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(edges-&gt;to);</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, edges-&gt;to-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (edges-&gt;to-&gt;visited) &#123;</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, edges-&gt;to-&gt;dfn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;dfn == x-&gt;low) &#123;</span><br><span class="line">        counts++;</span><br><span class="line">        Node *y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            y-&gt;visited = <span class="literal">false</span>;</span><br><span class="line">            y-&gt;connected = &amp;connecteds[counts];</span><br><span class="line">            connecteds[counts].size++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; girl[i] &gt;&gt; boy[i];</span><br><span class="line">        mp[girl[i]] = <span class="number">2</span> * i;</span><br><span class="line">        mp[boy[i]] = <span class="number">2</span> * i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">addEdge</span>(mp[girl[i]], mp[boy[i]]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        std::string g, b;</span><br><span class="line">        std::cin &gt;&gt; g &gt;&gt; b;</span><br><span class="line">        <span class="built_in">addEdge</span>(mp[b], mp[g]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!N[i].dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(&amp;N[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N[mp[girl[i]]].connected == N[mp[boy[i]]].connected) <span class="built_in">puts</span>(<span class="string">&quot;Unsafe&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">&quot;Safe&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1365」Easy - 概率与期望</title>
    <url>/luogu-1365/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1365">洛谷链接</a></p>
<p>有一种音游的计分方式为在一首歌中有 <span
class="math inline">\(n\)</span> 次点击要做，成功了就是
<code>o</code>，失败了就是 <code>x</code>，分数是按 combo 计算的，连续
<span class="math inline">\(a\)</span> 个 combo 就有 <span
class="math inline">\(a\times a\)</span> 分，combo 就是极大的连续
<code>o</code>。</p>
<p>Sevenkplus 闲的慌就看他打了一盘，有些地方跟运气无关要么是
<code>o</code> 要么是 <code>x</code>，有些地方 <code>o</code> 或者
<code>x</code> 各有 <span class="math inline">\(50\%\)</span>
的可能性，用 <code>?</code> 号来表示。</p>
<p>那么的期望得分是多少？</p>
<p>数据范围：<span class="math inline">\(n\le3\times10^5\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于这种期望题，我们可以用 DP 解决。</p>
<p>我们可以定义状态 <span class="math inline">\(f_i\)</span> 表示在第
<span class="math inline">\(i\)</span>
次点击中获得分数的期望，同时我们可以定义 <span
class="math inline">\(\text{len}\)</span> 为当前连击数的期望。</p>
<p>我们有以下三种情况：</p>
<ol type="1">
<li>第 <span class="math inline">\(i\)</span> 次点击为
<code>x</code>：显然 <span class="math inline">\(f_i = f_{i -
1}\)</span>，<span class="math inline">\(\text{len} = 0\)</span></li>
<li>第 <span class="math inline">\(i\)</span> 次点击为
<code>o</code>：对于连续次 combo 可加的分为 <span
class="math inline">\((\text{len + 1})^2 - \text{len}^2 = 2 \times
\text{len} + 1\)</span>，故 <span class="math inline">\(f_i = f_{i - 1}
+ 2 \times \text{len} + 1\)</span>，<span
class="math inline">\(\text{len} = \text{len} + 1\)</span></li>
<li>第 <span class="math inline">\(i\)</span> 次点击为
<code>?</code>：则有 <span class="math inline">\(50\%\)</span> 为
<code>x</code>，<span class="math inline">\(50\%\)</span> 为
<code>o</code>。故两种情况求平均值即可。即 <span
class="math inline">\(f_i = \frac{f_{i - 1} + f_{i - 1} + 2 \times
\text{len} + 1}{2} = f_{i - 1} + \text{len} + 0.5\)</span>，<span
class="math inline">\(\text{len} = \frac{0 + \text{len} + 1}{2} =
\frac{\text{len} + 1}{2}\)</span></li>
</ol>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">300000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> f[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">double</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (str[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;x&#x27;</span>:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>];</span><br><span class="line">                len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + <span class="number">2</span> * len + <span class="number">1</span>;</span><br><span class="line">                len++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                f[i] = f[i - <span class="number">1</span>] + len + <span class="number">0.5</span>;</span><br><span class="line">                len = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.4lf\n&quot;</span>, f[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>概率与期望</tag>
        <tag>数学</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2257」YY 的 GCD - 莫比乌斯反演</title>
    <url>/luogu-2257/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2257">洛谷链接</a></p>
<p>给定 <span class="math inline">\(N, M\)</span>，求 <span
class="math inline">\(1 \leq x \leq N\)</span>，<span
class="math inline">\(1 \leq y \leq M\)</span> 且 <span
class="math inline">\(\gcd(x, y)\)</span> 为质数的 <span
class="math inline">\((x, y)\)</span> 有多少对。</p>
<p>数据范围：<span class="math inline">\(T = 10^4\)</span>，<span
class="math inline">\(N, M \leq 10^7\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题要求求下列式子的值（<span
class="math inline">\(\text{Primes}\)</span> 为质数集合）：</p>
<p><span class="math display">\[
\sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) \in \text{Primes}]} }
\]</span></p>
<p>看到单元函数我们可以尝试用莫比乌斯反演化简。</p>
<p>我们设函数 <span class="math inline">\(A(n, m) = \sum_{x = 1}^n{
\sum_{y = 1}^m{[\gcd(x, y) \in \text{Primes}]}
}\)</span>，进行一些化简即可得 <span class="math inline">\(A(n, m) =
\sum_{ k \in \text{Primes} }{ \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y)
= k]} } }\)</span>，显然 <span class="math inline">\(A(n, m)\)</span>
即为答案。</p>
<p>对于 <span class="math inline">\(A(n, m)\)</span>
这个函数的整体不好化简，我们可以先把 <span class="math inline">\(A(n,
m)\)</span> 拆出来。我们设下列函数：</p>
<p><span class="math display">\[
f(k) = \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) = k]} }
\]</span></p>
<p>显然 <span class="math inline">\(A(n, m) = \sum_{k \in
Primes}{f(k)}\)</span>，故问题转化成了化简 <span
class="math inline">\(f(k)\)</span>。</p>
<p>我们可以尝试用莫比乌斯反演化简 <span
class="math inline">\(f(k)\)</span>。设下列函数：</p>
<p><span class="math display">\[
\begin{align*}
F(k) &amp;= \sum_{k | d}{f(d)} \\
&amp;= \sum_{k | d}{ \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) = d]} }
} \\
&amp;= \sum_{t = 1}^{\min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{ \sum_{x = 1}^n{ \sum_{y = 1}^m{[\gcd(x, y) =
tk]} } } \\
&amp;= \sum_{x = 1}^n{ \sum_{y = 1}^m{[k | \gcd(x, y)]} } \\
&amp;= \sum_{x = 1}^n{ \sum_{y = 1}^m{[k | x][k | y]} } \\
&amp;= \lfloor \frac{n}{k} \rfloor \lfloor \frac{m}{k} \rfloor
\end{align*} \\
\]</span></p>
<p>由于 <span class="math inline">\(F(k) = \sum_{k |
d}{f(d)}\)</span>，我们可以进行莫比乌斯反演：</p>
<p><span class="math display">\[
\begin{align*}
f(k) &amp;= \sum_{k | d}{ \mu(\frac{d}{k}) F(d) } \\
&amp;= \sum_{k | d}{ \mu(\frac{d}{k}) \lfloor \frac{n}{d} \rfloor
\lfloor \frac{m}{d} \rfloor } \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k} \rfloor , \lfloor
\frac{m}{k} \rfloor \} }{ \mu(t) \lfloor \frac{n}{tk} \rfloor \lfloor
\frac{m}{tk} \rfloor }
\end{align*}
\]</span></p>
<p>于是我们可以得出：</p>
<p><span class="math display">\[
A(n, m) = \sum_{k \in Primes}{ \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{k}
\rfloor , \lfloor \frac{m}{k} \rfloor \} }{ \mu(t) \lfloor \frac{n}{tk}
\rfloor \lfloor \frac{m}{tk} \rfloor } }
\]</span></p>
<p>但现在直接求 <span class="math inline">\(A(n, m)\)</span> 显然会
TLE，我们需要进行进一步优化。</p>
<p>我们发现在 <span class="math inline">\(A(n, m)\)</span> 中大量出现
<span class="math inline">\(tk\)</span>，我们可以尝试把 <span
class="math inline">\(tk\)</span> 提出来：</p>
<p><span class="math display">\[
\begin{align*}
A(n, m) &amp;= \sum_{k \in Primes}{ \sum_{t = 1}^{ \min\{ \lfloor
\frac{n}{k} \rfloor , \lfloor \frac{m}{k} \rfloor \} }{ \mu(t) \lfloor
\frac{n}{tk} \rfloor \lfloor \frac{m}{tk} \rfloor } } \\
&amp;= \sum_{x = 1}^{ \min\{n, m\} }{ \sum_{ k | x, k \in \text{Primes}
}{ \mu(\frac{x}{k}) \lfloor \frac{n}{x} \rfloor \lfloor \frac{m}{x}
\rfloor } } \\
&amp;= \sum_{x = 1}^{ \min\{n, m\} }{  \lfloor \frac{n}{x} \rfloor
\lfloor \frac{m}{x} \rfloor \sum_{ k | x, k \in \text{Primes} }{
\mu(\frac{x}{k}) } }
\end{align*}
\]</span></p>
<p>对于 <span class="math inline">\(\sum_{ k | x, k \in \text{Primes} }{
\mu(\frac{x}{k}) }\)</span>，我们可以在预处理 <span
class="math inline">\(\mu(n)\)</span>
过后预处理该式，然后对该式作前缀和。最后再用数论分块求 <span
class="math inline">\(A(n, m)\)</span> 即可。每次询问的时间复杂度为
<span class="math inline">\(O(\sqrt{n})\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sumMu[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; primes[i] * j &lt;= MAXN; j++) &#123;</span><br><span class="line">            sumMu[primes[i] * j] += mu[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) sumMu[i] += sumMu[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= std::<span class="built_in">min</span>(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (sumMu[r] - sumMu[l - <span class="number">1</span>]) * (n / l) * (m / l);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getPrimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">f</span>(n, m));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P1436」棋盘分割 - 区间 DP</title>
    <url>/luogu-1436/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1436">洛谷链接</a></p>
<p>将一个 <span class="math inline">\(8 \times 8\)</span>
的棋盘进行如下分割：将原棋盘割下一块矩形棋盘并使剩下部分也是矩形，再将剩下的两部分中的任意一块继续如此分割，这样割了
<span class="math inline">\(n - 1\)</span>
次后，连同最后剩下的矩形棋盘共有 <span class="math inline">\(n\)</span>
块矩形棋盘。(每次切割都只能沿着棋盘格子的边进行)</p>
<img src="/luogu-1436/p1436.png" class="">
<p>原棋盘上每一格有一个分值，一块矩形棋盘的总分为其所含各格分值之和。现在需要把棋盘按上述规则分割成
<span class="math inline">\(n\)</span>
块矩形棋盘，并使各矩形棋盘总分的平方和最小。</p>
<p>请编程对给出的棋盘及 <span class="math inline">\(n\)</span>
，求出平方和的最小值。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 15\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题可以用区间 DP 来做。我们定义如下状态：</p>
<p><span class="math display">\[
f_{i, l, d, r, u} \quad i, l, d, r, u \in [1, 8] \cap \mathbb{Z} \wedge
l \leq r \wedge d \leq u
\]</span></p>
<p>这个状态表示在这个棋盘中，从左下角 <span class="math inline">\((l,
d)\)</span> 到右上角 <span class="math inline">\((r, u)\)</span>
所构成的矩形被拆成 <span class="math inline">\(i\)</span>
个矩形后平方和最小值。</p>
<p>我们将 <span class="math inline">\(f_{1, l, d, r, u}\)</span>
初始化为 <span class="math inline">\((l, d) \rightarrow (r, u)\)</span>
这个矩形的总分平方和。</p>
<p>对于一个矩形，我们只能横切或竖切分割成两个矩形，于是可以得到下列动态转移方程：</p>
<p><span class="math display">\[
\begin{cases}
f_{i, l, d, r, u} = \min \limits_{l \leq j \leq r} \{ f_{i - 1, l, d, j,
u} + f_{1, j + 1, d, r, u}, f_{1, l, d, j, u} + f_{i - 1, j + 1, d, r,
u} \} \\
f_{i, l, d, r, u} = \min \limits_{l \leq j \leq r} \{ f_{i - 1, l, d, r,
j} + f_{1, l, j + 1, r, u}, f_{1, l, d, r, j} + f_{i - 1, l, j + 1, r,
u} \}
\end{cases}
\]</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXB = <span class="number">8</span>, MAXN = <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> board[MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>], s[MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN + <span class="number">1</span>][MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>][MAXB + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getTri</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> d, <span class="type">int</span> r, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s[r][u] - s[r][d - <span class="number">1</span>] - s[l - <span class="number">1</span>][u] + s[l - <span class="number">1</span>][d - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(s, <span class="number">0</span>, <span class="built_in">sizeof</span>(s));</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXB; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAXB; j++) &#123;</span><br><span class="line">            s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= MAXB; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= MAXB; d++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= MAXB; r++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> u = d; u &lt;= MAXB; u++) &#123;</span><br><span class="line">                    f[<span class="number">1</span>][l][d][r][u] = <span class="built_in">pow</span>(<span class="built_in">getTri</span>(l, d, r, u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l &lt;= MAXB; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> d = <span class="number">1</span>; d &lt;= MAXB; d++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> r = l; r &lt;= MAXB; r++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> u = d; u &lt;= MAXB; u++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = l; j &lt; r; j++) f[i][l][d][r][u] = std::<span class="built_in">min</span>(f[i][l][d][r][u], std::<span class="built_in">min</span>(f[i - <span class="number">1</span>][l][d][j][u] + f[<span class="number">1</span>][j + <span class="number">1</span>][d][r][u], f[<span class="number">1</span>][l][d][j][u] + f[i - <span class="number">1</span>][j + <span class="number">1</span>][d][r][u]));</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> j = d; j &lt; u; j++) f[i][l][d][r][u] = std::<span class="built_in">min</span>(f[i][l][d][r][u], std::<span class="built_in">min</span>(f[i - <span class="number">1</span>][l][d][r][j] + f[<span class="number">1</span>][l][j + <span class="number">1</span>][r][u], f[<span class="number">1</span>][l][d][r][j] + f[i - <span class="number">1</span>][l][j + <span class="number">1</span>][r][u]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXB; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= MAXB; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;board[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; f[n][<span class="number">1</span>][<span class="number">1</span>][MAXB][MAXB] &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>区间 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2371」墨墨的等式 - 最短路</title>
    <url>/luogu-2371/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2371">洛谷链接</a></p>
<p>墨墨突然对等式很感兴趣，他正在研究 <span
class="math inline">\(\sum_{i = 1}^n a_i x_i = b\)</span>
存在非负整数解的条件，他要求你编写一个程序，给定 <span
class="math inline">\(n, a_{1 \dots n}, l, r\)</span> 求出有多少 <span
class="math inline">\(b \in [l, r]\)</span>
可以使等式存在非负整数解。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题看似可以用完全背包可解，但由于该数据范围，肯定 T 飞。</p>
<p>于是我们可以采用图论方法来解这道题。</p>
<p>解决本题需要了解 <strong>同余最短路</strong>
这个知识。具体同余最短路是什么，我们可以用本题举例。</p>
<p>首先我们要做的是确定一个数 <span
class="math inline">\(x\)</span>，表示为加其他数等同于加 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(x\)</span> 的余数。在这里可以定义 <span
class="math inline">\(x = \min \limits_{1 \leq j \leq n}
a_j\)</span>，且对于 <span class="math inline">\(\forall i \in N \wedge
i &lt; x\)</span>，计算出满足该题非负整数解条件的 <span
class="math inline">\(b\)</span> 的最小值为 <span
class="math inline">\(\text{dis}_i\)</span></p>
<p>具体怎么计算 <span
class="math inline">\(\text{dis}_i\)</span>，我们可以建立一张图。对于
<span class="math inline">\(\forall i \in N \wedge i &lt;
n\)</span>，建立连向 <span class="math inline">\((i + a_j) \mod
x\)</span> 的权值为 <span class="math inline">\(a_j\)</span>
的边。这条边表明我们可通过将当前 <span class="math inline">\(\mod
x\)</span> 的数加上 <span class="math inline">\(a_j\)</span> 转化成
<span class="math inline">\(\mod x = (i + a_j) \mod x\)</span>
的数。</p>
<p>接下来我们从 <span class="math inline">\(0\)</span>
出发求最短路。求出的最短路 <span
class="math inline">\(\text{dis}_i\)</span> 即为满足该数 <span
class="math inline">\(\mod n = i\)</span> 且满足该题非负整数解条件的
<span class="math inline">\(b\)</span> 的最小值。</p>
<p>最后对于 <span class="math inline">\(b \mod x =
i\)</span>，若我们总共有 <span class="math inline">\(\lfloor \frac{h -
\text{dis}_i}{x} \rfloor + 1\)</span> 种满足小于等于 <span
class="math inline">\(h\)</span>
且符合条件的情况。最后将所有余数的情况相加即为答案。</p>
<p>对于本题，我们可以先分别算出小于等于 <span
class="math inline">\(r\)</span> 的情况总数和小于等于 <span
class="math inline">\(l - 1\)</span>
的情况总数，由于两者重复，我们仅需将两情况数相减即为 <span
class="math inline">\(l \leq b \leq r\)</span> 的情况总数。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">long</span> <span class="type">long</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> from, <span class="type">int</span> to, <span class="type">int</span> ver)</span> </span>&#123;</span><br><span class="line">    e[from].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(to, ver) );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">(<span class="type">int</span> s)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    dis[s] = <span class="number">0</span>, vis[s] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>(), vis[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="type">int</span> v = ed.first, w = ed.second;</span><br><span class="line">            <span class="keyword">if</span> (dis[v] &gt; dis[u] + w) &#123;</span><br><span class="line">                dis[v] = dis[u] + w;</span><br><span class="line">                <span class="keyword">if</span> (!vis[v]) q.<span class="built_in">push</span>(v), vis[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> l, r;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[<span class="number">13</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; l &gt;&gt; r;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> minA = MAXN + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">        minA = std::<span class="built_in">min</span>(minA, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minA; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] != minA) &#123;</span><br><span class="line">                <span class="built_in">add</span>(i, (i + a[j]) % minA, a[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">spfa</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; minA; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &gt;= dis[i]) ans += (r - dis[i]) / minA + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l - <span class="number">1</span> &gt;= dis[i]) ans -= (l - <span class="number">1</span> - dis[i]) / minA + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>洛谷</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDOI2006」线性方程组 - 高斯消元</title>
    <url>/luogu-2455/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2455">洛谷链接</a></p>
<p>已知 <span class="math inline">\(n\)</span> 元线性一次方程组。</p>
<p><span class="math display">\[
\begin{cases}
a_{1, 1} x_1 + a_{1, 2} x_2 + \cdots + a_{1, n} x_n = b_1 \\
a_{2, 1} x_1 + a_{2, 2} x_2 + \cdots + a_{2, n} x_n = b_2 \\
\cdots \\
a_{n,1} x_1 + a_{n, 2} x_2 + \cdots + a_{n, n} x_n = b_n
\end{cases}
\]</span></p>
<p>请根据输入的数据，编程输出方程组的解的情况。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于求 <span class="math inline">\(n\)</span>
元一次方程组，显然需要用高斯消元。但本题需要判断无解或无穷解。对于此类，我们可以在高斯消元后判断第
<span class="math inline">\(i\)</span> 行第 <span
class="math inline">\(i\)</span> 项是否为 <span
class="math inline">\(0\)</span>。若为 <span
class="math inline">\(0\)</span> 且最后一项不为 <span
class="math inline">\(0\)</span>，无解。在判断有解的前提下，第 <span
class="math inline">\(i\)</span> 行第 <span
class="math inline">\(i\)</span> 项同时为 <span
class="math inline">\(0\)</span> 则有无穷解。</p>
<p>最后注意一下需要调换增广矩阵每一行的位置。对于第 <span
class="math inline">\(i\)</span> 行可将未计算的行中最大的第 <span
class="math inline">\(i\)</span> 项所在行调换。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">double</span> a[MAXN + <span class="number">1</span>][MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">swaps</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; k++) &#123;</span><br><span class="line">        std::<span class="built_in">swap</span>(a[i][k], a[j][k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sorts</span><span class="params">(<span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> maxn = pos;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = pos + <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fabs</span>(a[maxn][pos]) &lt; <span class="built_in">fabs</span>(a[i][pos])) &#123;</span><br><span class="line">            maxn = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pos != maxn) <span class="built_in">swaps</span>(pos, maxn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">sorts</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (a[i][i] == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) a[i][j] /= a[i][i];</span><br><span class="line">        a[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; k++) &#123;</span><br><span class="line">                a[j][k] -= a[i][k] * a[j][i] / a[i][i];</span><br><span class="line">            &#125;</span><br><span class="line">            a[j][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt; <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++) &#123;</span><br><span class="line">            a[j][n + <span class="number">1</span>] -= a[i][n + <span class="number">1</span>] * a[j][i] / a[i][i];</span><br><span class="line">            a[j][i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> op = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i][i] == <span class="number">0</span> &amp;&amp; a[i][n + <span class="number">1</span>] != <span class="number">0</span>) op = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[i][i] == <span class="number">0</span> &amp;&amp; a[i][n + <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; op == <span class="number">1</span>) op = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> op;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n + <span class="number">1</span>; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lf&quot;</span>, &amp;a[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">gauss</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> op = <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (op != <span class="number">1</span>) std::cout &lt;&lt; op &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;x%d=%.2lf\n&quot;</span>, i, a[i][n + <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>2006</tag>
        <tag>洛谷</tag>
        <tag>高斯消元</tag>
        <tag>SDOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P3047」Nearby Cows - 树形 DP + 容斥原理</title>
    <url>/luogu-3047/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3047">洛谷链接</a></p>
<p>给你一棵 <span class="math inline">\(n\)</span>
个点的树，点带权，对于每个节点求出距离它不超过 <span
class="math inline">\(k\)</span> 的所有节点权值和 <span
class="math inline">\(m_i\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题树形 DP 可做。首先我们统计 <span class="math inline">\(f_{i,
j}\)</span>，<span class="math inline">\(f_{i, j}\)</span> 表示以 <span
class="math inline">\(i\)</span> 为根的子树中距离为 <span
class="math inline">\(j\)</span> 的节点个数。</p>
<p>于是有下列方程：</p>
<p><span class="math display">\[
f_{i, j} = f_{i, j} + f_{e, j - 1} \quad i \rightarrow e
\]</span></p>
<p>接下来就是换根。对于 <span class="math inline">\(i\)</span>
节点，我们有一下方程：</p>
<p><span class="math display">\[
f_{i, j} = f_{i, j} + f_{e, j - 1} \quad e \rightarrow i
\]</span></p>
<p>然而此时必有重复，因为在统计 <span class="math inline">\(f_{e,
j}\)</span> 时，<span class="math inline">\(f_{i, j - 2}\)</span>
已被统计。故这里简单容斥一下即可。</p>
<p><span class="math display">\[
f_{i, j} \cup f_{e, j - 1} = f_{i, j} + f_{e, j - 1} - f_{i, j} \cap
f_{e, j - 1}
\]</span></p>
<p><span class="math display">\[
f_{i, j} = f_{i, j} + f_{e, j - 1} - f_{i, j - 2} \quad e \rightarrow i
\]</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXK = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> f[MAXK + <span class="number">1</span>];</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dp1</span>(e-&gt;t, v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) v-&gt;f[i] += e-&gt;t-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dp2</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = k; i &gt;= <span class="number">2</span>; i--) e-&gt;t-&gt;f[i] -= e-&gt;t-&gt;f[i - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) e-&gt;t-&gt;f[i] += v-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">dp2</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;s, &amp;t);</span><br><span class="line">        <span class="built_in">addEdge</span>(s, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N[i].f[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp1</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line">    <span class="built_in">dp2</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= k; j++) ans += N[i].f[j];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>树形 DP</tag>
        <tag>换根</tag>
        <tag>洛谷</tag>
        <tag>容斥原理</tag>
        <tag>USACO</tag>
        <tag>2012</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2922」Secret Message - Trie</title>
    <url>/luogu-2922/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2922">洛谷链接</a></p>
<p>贝茜正在领导奶牛们逃跑．为了联络，奶牛们互相发送秘密信息．</p>
<p>信息是二进制的，共有 <span class="math inline">\(M\)</span>（<span
class="math inline">\(1 \le M \le
50000\)</span>）条，反间谍能力很强的约翰已经部分拦截了这些信息，知道了第
<span class="math inline">\(i\)</span> 条二进制信息的前 <span
class="math inline">\(b_i\)</span>（<span class="math inline">\(l \le
b_i \le 10000\)</span>）位，他同时知道，奶牛使用 <span
class="math inline">\(N\)</span>（<span class="math inline">\(1 \le N
\le 50000\)</span>）条暗号．但是，他仅仅知道第 <span
class="math inline">\(j\)</span> 条暗号的前 <span
class="math inline">\(c_j\)</span>（<span class="math inline">\(1 \le
c_j \le 10000\)</span>）位。</p>
<p>对于每条暗号 <span
class="math inline">\(j\)</span>，他想知道有多少截得的信息能够和它匹配。也就是说，有多少信息和这条暗号有着相同的前缀。当然，这个前缀长度必须等于暗号和那条信息长度的较小者。</p>
<p>在输入文件中，位的总数（即 <span class="math inline">\(\sum b_i +
\sum c_i\)</span>）不会超过 <span
class="math inline">\(500000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然是一道字符串题，我们可以用 Trie 解决。我们可以将所有的 <span
class="math inline">\(b_i\)</span> 插入到一个 Trie 中。对于每个 <span
class="math inline">\(c_i\)</span>，我们有下列两种统计：</p>
<ul>
<li>通过查询路径统计 <strong>比暗号短的信息</strong> 的个数；</li>
<li>通过在暗号尾部 DFS 统计 <strong>比暗号长的信息</strong>
的个数。</li>
</ul>
<p>这里单纯的 DFS 会 TLE，加个记忆化就行了。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">500000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[MAXN + <span class="number">2</span>][<span class="number">2</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> end[MAXN + <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> size[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> *str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ch = str[i];</span><br><span class="line">        <span class="keyword">if</span> (trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">    &#125;</span><br><span class="line">    end[p]++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getSize</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size[p] != <span class="number">-1</span>) <span class="keyword">return</span> size[p];</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    size[p] = end[p];</span><br><span class="line">    size[p] += <span class="built_in">getSize</span>(trie[p][<span class="number">0</span>]);</span><br><span class="line">    size[p] += <span class="built_in">getSize</span>(trie[p][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> size[p];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(<span class="type">int</span> *str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>, cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        p = trie[p][str[i]];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">0</span>) <span class="keyword">return</span> cnt;</span><br><span class="line">        cnt += end[p];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cnt += <span class="built_in">getSize</span>(trie[p][<span class="number">0</span>]);</span><br><span class="line">    cnt += <span class="built_in">getSize</span>(trie[p][<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> m, n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;m, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> b[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;b[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">insert</span>(b, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(size, <span class="number">-1</span>, <span class="built_in">sizeof</span>(size));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> c[MAXN];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;c[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">search</span>(c, len));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>2008</tag>
        <tag>USACO</tag>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2619」Tree I - 二分答案 + 最小生成树</title>
    <url>/luogu-2619/</url>
    <content><![CDATA[<h1 id="题目描述">题目描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2619">洛谷链接</a></p>
<p>给你一个无向带权连通图，每条边是黑色或白色。让你求一棵最小权的恰好有
<span class="math inline">\(need\)</span> 条白色边的生成树。</p>
<p>题目保证有解。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题靠的是最小生成树。而要求有 <span
class="math inline">\(\text{need}\)</span>
条白色边。于是我们可以在白色边上操作。</p>
<p>我们可以将所有的白边同时加上或减去一个权值，使最小生成树的边的选择产生变化，直到选择的边中恰有
<span class="math inline">\(\text{need}\)</span> 条白色边。</p>
<p>于是我们可以二分答案白边加上或减去的权值。在利用 Kruskal
求出最小生成树的同时统计白边的数量。通过调整白边权值变化达到生成树中恰有
<span class="math inline">\(\text{need}\)</span>
条白边且权值最小即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> INF = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    <span class="type">int</span> s, t, c, col;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == other.c) <span class="keyword">return</span> col &lt; other.col;</span><br><span class="line">        <span class="keyword">return</span> c &lt; other.c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[MAXM];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UFS</span> &#123;</span><br><span class="line">    <span class="type">int</span> f[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == f[x] ? x : f[x] = <span class="built_in">find</span>(f[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        f[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> v, e, need;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ufs.<span class="built_in">init</span>(v);</span><br><span class="line">    std::<span class="built_in">sort</span>(E, E + e);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, counts = <span class="number">0</span>, cntNeed = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        Edge &amp;edge = E[i];</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(edge.s) == ufs.<span class="built_in">find</span>(edge.t)) <span class="keyword">continue</span>;</span><br><span class="line">        ufs.<span class="built_in">merge</span>(edge.s, edge.t);</span><br><span class="line">        ans += edge.c;</span><br><span class="line">        <span class="keyword">if</span> (edge.col == <span class="number">0</span>) cntNeed++;</span><br><span class="line">        <span class="keyword">if</span> (++counts == v - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(cntNeed, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;v, &amp;e, &amp;need);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;E[i].s, &amp;E[i].t, &amp;E[i].c, &amp;E[i].col);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = -INF, r = INF, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (E[i].col == <span class="number">0</span>) &#123;</span><br><span class="line">                E[i].c += mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; res = <span class="built_in">kruskal</span>();</span><br><span class="line">        res.second -= mid * need;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (E[i].col == <span class="number">0</span>) &#123;</span><br><span class="line">                E[i].c -= mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res.first &gt;= need) l = mid + <span class="number">1</span>, ans = res.second;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>最小生成树</tag>
        <tag>洛谷</tag>
        <tag>国家集训队</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4180」严格次小生成树 - 最小生成树 + 最近公共祖先</title>
    <url>/luogu-4180/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4180">洛谷链接</a></p>
<p>小 C 最近学了很多最小生成树的算法，Prim 算法、Kruskal
算法、消圈算法等等。正当小 C 洋洋得意之时，小 P 又来泼小 C 冷水了。小 P
说，让小 C
求出一个无向图的次小生成树，而且这个次小生成树还得是严格次小的，也就是说：如果最小生成树选择的边集是
<span class="math inline">\(E_M\)</span>，严格次小生成树选择的边集是
<span class="math inline">\(E_S\)</span>，那么需要满足：(<span
class="math inline">\(value(e)\)</span> 表示边 <span
class="math inline">\(e\)</span> 的权值) <span
class="math inline">\(\sum_{e \in E_M}value(e)&lt;\sum_{e \in
E_S}value(e)\)</span></p>
<p>这下小 C 蒙了，他找到了你，希望你帮他解决这个问题。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据， <span
class="math inline">\(N\le 10^5\)</span>，<span
class="math inline">\(M\le 3\times10^5\)</span>，边权 <span
class="math inline">\(\in
[0,10^9]\)</span>，数据保证必定存在严格次小生成树。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们求出最小生成树。然后对于每个未选中的边按权值从小到达遍历。对于每个未选中的边，设我们找到了边
<span class="math inline">\(u \leftrightarrow
v\)</span>，我们可以在最小生成树中找到 <span class="math inline">\(u
\rightarrow v\)</span>
的路径，再将路径中的权值最大的边替换成该边。这样可以同时满足是一颗生成树且总权值相差最小。于是我们就得到了次小生成树的可能情况。最后在这些可能情况中取最小值即可。</p>
<p>但这样的次小生成树是非严格的，因为我们找到的边和将要替换的边权值可能相等。此时我们只需要用路径上的次大边替换就行了。</p>
<p>对于路径上的最大边和次大边，我们可以在预处理 LCA 的时候同时预处理 LCA
对应的路径的最大边和次大边即可。</p>
<p>整个问题的时间复杂度为 <span class="math inline">\(O(m \log
m)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">3e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    Node *p, *f[LOG_MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> maxe[LOG_MAXN + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">    <span class="type">int</span> d, id;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> sid, tid;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">long</span> <span class="type">long</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> Edge &amp;other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; other.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; E[MAXM + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">UnionFindSet</span> &#123;</span><br><span class="line">    <span class="type">int</span> fa[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fa[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == fa[x] ? x : fa[x] = <span class="built_in">find</span>(fa[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">        fa[<span class="built_in">find</span>(x)] = <span class="built_in">find</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; ufs;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t], w));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ufs.<span class="built_in">init</span>(n);</span><br><span class="line">    std::<span class="built_in">sort</span>(E + <span class="number">1</span>, E + m + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> counts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        Edge &amp;e = E[i];</span><br><span class="line">        <span class="keyword">if</span> (ufs.<span class="built_in">find</span>(e.sid) == ufs.<span class="built_in">find</span>(e.tid)) <span class="keyword">continue</span>;</span><br><span class="line">        e.v = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">addEdge</span>(e.sid, e.tid, e.w);</span><br><span class="line">        ufs.<span class="built_in">merge</span>(e.sid, e.tid);</span><br><span class="line">        ans += e.w;</span><br><span class="line">        <span class="keyword">if</span> (++counts == n - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;f[<span class="number">0</span>] = v-&gt;p = f;</span><br><span class="line">    v-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    v-&gt;maxe[<span class="number">0</span>][<span class="number">1</span>] = LLONG_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            v-&gt;f[i] = v-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> choice[<span class="number">4</span>] = &#123; v-&gt;maxe[i - <span class="number">1</span>][<span class="number">0</span>], v-&gt;maxe[i - <span class="number">1</span>][<span class="number">1</span>],</span><br><span class="line">                                    v-&gt;f[i - <span class="number">1</span>]-&gt;maxe[i - <span class="number">1</span>][<span class="number">0</span>], v-&gt;f[i - <span class="number">1</span>]-&gt;maxe[i - <span class="number">1</span>][<span class="number">1</span>] &#125;;</span><br><span class="line">            std::<span class="built_in">sort</span>(choice, choice + <span class="number">4</span>);</span><br><span class="line">            v-&gt;maxe[i][<span class="number">0</span>] = choice[<span class="number">3</span>];</span><br><span class="line">            <span class="type">int</span> p = <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">while</span> (p &gt;= <span class="number">0</span> &amp;&amp; choice[p] == choice[<span class="number">3</span>]) p--;</span><br><span class="line">            v-&gt;maxe[i][<span class="number">1</span>] = (p == <span class="number">-1</span> ? LLONG_MIN : choice[p]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        e-&gt;t-&gt;maxe[<span class="number">0</span>][<span class="number">0</span>] = e-&gt;w;</span><br><span class="line">        <span class="built_in">prepare</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(Node *v, Node *f, <span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = LLONG_MIN;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i] &amp;&amp; v-&gt;f[i]-&gt;d &gt;= f-&gt;d) &#123;</span><br><span class="line">            <span class="keyword">if</span> (w != v-&gt;maxe[i][<span class="number">0</span>]) res = std::<span class="built_in">max</span>(res, v-&gt;maxe[i][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">else</span> res = std::<span class="built_in">max</span>(res, v-&gt;maxe[i][<span class="number">1</span>]);</span><br><span class="line">            v = v-&gt;f[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) N[i].id = i;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;E[i].sid, &amp;E[i].tid, &amp;E[i].w);</span><br><span class="line">        E[i].s = &amp;N[E[i].sid], E[i].t = &amp;N[E[i].tid];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = LLONG_MAX;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sum = <span class="built_in">kruskal</span>();</span><br><span class="line">    <span class="built_in">prepare</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!E[i].v) &#123;</span><br><span class="line">            Edge *e = &amp;E[i];</span><br><span class="line">            Node *f = <span class="built_in">lca</span>(e-&gt;s, e-&gt;t);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> sw = <span class="built_in">query</span>(e-&gt;s, f, e-&gt;w);</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> tw = <span class="built_in">query</span>(e-&gt;t, f, e-&gt;w);</span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">max</span>(sw, tw) &gt; LLONG_MIN) ans = std::<span class="built_in">min</span>(ans, sum - std::<span class="built_in">max</span>(sw, tw) + e-&gt;w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最小生成树</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P2746」校园网 Network of Schools - 强连通分量</title>
    <url>/luogu-2746/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2746">洛谷链接</a></p>
<p>一些学校连入一个电脑网络。那些学校已订立了协议：每个学校都会给其它的一些学校分发软件（称作“接受学校”）。注意即使
<span class="math inline">\(B\)</span> 在 <span
class="math inline">\(A\)</span> 学校的分发列表中，<span
class="math inline">\(A\)</span> 也不一定在 <span
class="math inline">\(B\)</span> 学校的列表中。</p>
<p>你要写一个程序计算，根据协议，为了让网络中所有的学校都用上新软件，必须接受新软件副本的最少学校数目（子任务
A）。更进一步，我们想要确定通过给任意一个学校发送新软件，这个软件就会分发到网络中的所有学校。为了完成这个任务，我们可能必须扩展接收学校列表，使其加入新成员。计算最少需要增加几个扩展，使得不论我们给哪个学校发送新软件，它都会到达其余所有的学校（子任务
B）。一个扩展就是在一个学校的接收学校列表中引入一个新成员。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题考的是强连通分量。将学校用节点表示，分发关系用有向边表示，接着用
Tarjan 求一遍之后缩点即可。</p>
<p>第一问答案即为缩点后入度为 <span class="math inline">\(0\)</span>
的节点个数，第二问答案即为入度为 <span class="math inline">\(0\)</span>
和出度为 <span class="math inline">\(0\)</span>
的节点数两者的最大值。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dfn[MAXN + <span class="number">1</span>], low[MAXN + <span class="number">1</span>], num = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"><span class="type">int</span> ins[MAXN + <span class="number">1</span>], c[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; scc[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ec[MAXN + <span class="number">1</span>], ecRev[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    sta.<span class="built_in">push</span>(x);</span><br><span class="line">    ins[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[each]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(each);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[each]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[each]) &#123;</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            ins[y] = <span class="number">0</span>;</span><br><span class="line">            c[y] = cnt, scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, x; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;x) != EOF) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            e[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each : e[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[each]) <span class="keyword">continue</span>;</span><br><span class="line">            ec[c[i]].<span class="built_in">push_back</span>(c[each]);</span><br><span class="line">            ecRev[c[each]].<span class="built_in">push_back</span>(c[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count1 = <span class="number">0</span>, count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ecRev[i].<span class="built_in">size</span>() == <span class="number">0</span>) count1++;</span><br><span class="line">        <span class="keyword">if</span> (ec[i].<span class="built_in">size</span>() == <span class="number">0</span>) count2++;</span><br><span class="line">    &#125;</span><br><span class="line">    count2 = std::<span class="built_in">max</span>(count1, count2);</span><br><span class="line">    <span class="keyword">if</span> (cnt == <span class="number">1</span>) count1 = <span class="number">1</span>, count2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; count1 &lt;&lt; std::endl &lt;&lt;  count2 &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>洛谷</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
        <tag>USACO</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4321」三步必杀 - 前缀和</title>
    <url>/luogu-4321/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4231">洛谷链接</a></p>
<p><span class="math inline">\(N\)</span>
个柱子排成一排，一开始每个柱子损伤度为 0。</p>
<p>接下来勇仪会进行 <span class="math inline">\(M\)</span>
次攻击，每次攻击可以用 4 个参数<span
class="math inline">\(l\)</span>,<span
class="math inline">\(r\)</span>,<span
class="math inline">\(s\)</span>,<span
class="math inline">\(e\)</span>来描述：</p>
<p>表示这次攻击作用范围为第 <span class="math inline">\(l\)</span>
个到第 <span class="math inline">\(r\)</span> 个之间所有的柱子（包含
<span class="math inline">\(l\)</span>，<span
class="math inline">\(r\)</span>），对第一个柱子的伤害为 <span
class="math inline">\(s\)</span>，对最后一个柱子的伤害为 <span
class="math inline">\(e\)</span>。</p>
<p>攻击产生的伤害值是一个等差数列。若 <span class="math inline">\(l =
1\)</span>，<span class="math inline">\(r = 5\)</span>，<span
class="math inline">\(s = 2\)</span>，<span class="math inline">\(e =
10\)</span>，则对第 1 ~ 5 个柱子分别产生 2, 4, 6, 8, 10 的伤害。</p>
<p>鬼族们需要的是所有攻击完成之后每个柱子的损伤度。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>一道简单但比较有意思的思维题。</p>
<p>我们可以考虑构造一个差分序列 <span
class="math inline">\(\text{diff1}\)</span>，显然对于公差为 <span
class="math inline">\(d\)</span> 等差数列 <span
class="math inline">\(a_{l \cdots r}\)</span>，<span
class="math inline">\(\text{diff1}_{l + 1 \cdots r} =
d\)</span>，但此时对于添加一个等差数列，对于 <span
class="math inline">\(\text{diff1}\)</span> 的操作仍然是 <span
class="math inline">\(O(n)\)</span> 的。此时我们可以考虑对 <span
class="math inline">\(\text{diff1}\)</span> 再构造一个差分序列 <span
class="math inline">\(\text{diff2}\)</span>。对于上述的等差数列，我们仅需要在
<span class="math inline">\(\text{diff2}_l = a_l\)</span>，<span
class="math inline">\(\text{diff2}_{l + 1} = d - a_l\)</span>，<span
class="math inline">\(\text{diff2}_{r + 1} = - d - a_r\)</span>，<span
class="math inline">\(\text{diff2}_{r + 2} = a_r\)</span>
即可，对于单个等差数列把算法优化到 <span
class="math inline">\(O(1)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> diff2[MAXN + <span class="number">3</span>];</span><br><span class="line">    <span class="built_in">memset</span>(diff2, <span class="number">0</span>, <span class="built_in">sizeof</span>(diff2));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> s, e;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld %lld&quot;</span>, &amp;l, &amp;r, &amp;s, &amp;e);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            diff2[l] += s;</span><br><span class="line">            diff2[r + <span class="number">1</span>] -= s + e;</span><br><span class="line">            diff2[r + <span class="number">2</span>] += e;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> d = (e - s) / (r - l);</span><br><span class="line">            diff2[l] += s;</span><br><span class="line">            diff2[l + <span class="number">1</span>] -= s - d;</span><br><span class="line">            diff2[r + <span class="number">1</span>] -= e + d;</span><br><span class="line">            diff2[r + <span class="number">2</span>] += e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> diff[MAXN + <span class="number">1</span>];</span><br><span class="line">    diff[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        diff[i] = diff2[i] + diff[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> sumXor = <span class="number">0</span>, maxN = <span class="number">0</span>, each = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        each += diff[i];</span><br><span class="line">        sumXor ^= each;</span><br><span class="line">        maxN = std::<span class="built_in">max</span>(maxN, each);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, each);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld %lld\n&quot;</span>, sumXor, maxN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>前缀和</tag>
        <tag>洛谷</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4310」绝世好题 - 线性 DP + 位运算</title>
    <url>/luogu-4310/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4310">洛谷链接</a></p>
<p>给定一个长度为 <span class="math inline">\(n\)</span> 的序列 <span
class="math inline">\(a_{1 \cdots n}\)</span>，求它满足 <span
class="math inline">\(\forall i \in \left[ 1, n \right) , b_i \&amp;
b_{i + 1} \neq 0\)</span> 的子序列 <span
class="math inline">\(b\)</span> 的最大长度，其中 <span
class="math inline">\(\&amp;\)</span> 是按位与操作。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 1 \times
10^5\)</span>，<span class="math inline">\(1 \leq a_i \leq
10^9\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然我们可以使用线性 DP 解决这个问题。将遍历到的 a_i
的长度作为状态，很明显有下列转移方程：</p>
<p><span class="math display">\[
f_i = \max \limits_{1 \leq j &lt; i \wedge a_i \&amp; a_j \neq 0} \{ f_j
+ 1 \}
\]</span></p>
<p>但这个算法时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>，在实际测试中仅可获得 60 分。</p>
<p>接下来我们需要优化这个算法。显然在寻找满足 <span
class="math inline">\(1 \leq j &lt; i \bigwedge a_i \&amp; a_j \neq
0\)</span> 的数花的时间过长，我们可以对这进行优化。</p>
<p>我们可以从 <span class="math inline">\(a_i \&amp; a_j \neq 0\)</span>
下手。显然在 <span class="math inline">\(a_i\)</span> 与 <span
class="math inline">\(a_j\)</span>
的二进制表示中必定含有一或以上的位数同时不为 <span
class="math inline">\(0\)</span>。我们可以通过维护一个数组 <span
class="math inline">\(\text{bit}\)</span>，在 <span
class="math inline">\(\text{bit}_x\)</span> 中记录所有在二进制下第 <span
class="math inline">\(x\)</span> 位不为 <span
class="math inline">\(0\)</span> 的 <span
class="math inline">\(a_i\)</span> 对应的 <span
class="math inline">\(f_i\)</span>
的最大值。利用该方法我们可以把上面的状态转移方程优化成下列样式：</p>
<p><span class="math display">\[
f_i = \max \limits_{0 \leq 2^j &lt; a_i} \{ \text{bit}_j + 1 \}
\]</span></p>
<p>在 <span class="math inline">\(f_i\)</span> 计算完毕后更新 <span
class="math inline">\(\text{bit}\)</span> 数组即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[MAXN + <span class="number">1</span>], bit[<span class="number">31</span>], ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(bit, <span class="number">0</span>, <span class="built_in">sizeof</span>(bit));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        f[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (<span class="number">1ll</span> &lt;&lt; j) &lt;= a[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; j) &amp; a[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                f[i] = std::<span class="built_in">max</span>(f[i], bit[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = std::<span class="built_in">max</span>(ans, f[i]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; (<span class="number">1ll</span> &lt;&lt; j) &lt;= a[i]; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; j) &amp; a[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">                bit[j] = std::<span class="built_in">max</span>(bit[j], f[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>位运算</tag>
        <tag>洛谷</tag>
        <tag>线性 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4556」雨天的尾巴 - 线段树合并 + 最近公共祖先 + 树上差分</title>
    <url>/luogu-4556/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4556">洛谷链接</a></p>
<p>首先村落里的一共有 <span class="math inline">\(n\)</span>
座房屋，并形成一个树状结构。然后救济粮分 <span
class="math inline">\(m\)</span> 次发放，每次选择两个房屋 <span
class="math inline">\((x,~y)\)</span>，然后对于 <span
class="math inline">\(x\)</span> 到 <span
class="math inline">\(y\)</span> 的路径上(含 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(y\)</span>)每座房子里发放一袋 <span
class="math inline">\(z\)</span> 类型的救济粮。</p>
<p>然后深绘里想知道，当所有的救济粮发放完毕后，每座房子里存放的最多的是哪种救济粮。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 测试数据，保证 <span
class="math inline">\(1 \leq n, m \leq 10^5\)</span>，<span
class="math inline">\(1 \leq a,b,x,y \leq n\)</span>，<span
class="math inline">\(1 \leq z \leq 10^5\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>由于村落是树状结构，对于从 <span class="math inline">\(x\)</span> 到
<span class="math inline">\(y\)</span> 的路径我们可以用 LCA
求出。但直接使用 LCA
后修改则复杂度过高，于是我们可以考虑使用树上差分。假设 <span
class="math inline">\(x\)</span> 与 <span
class="math inline">\(y\)</span> 的 LCA 为 <span
class="math inline">\(f\)</span>，我们可以将 <span
class="math inline">\(x\)</span>，<span class="math inline">\(y\)</span>
的救济粮 <span class="math inline">\(+1\)</span>，将 <span
class="math inline">\(f\)</span> 与 <span
class="math inline">\(f\)</span> 的父节点的救济粮 <span
class="math inline">\(-1\)</span>，最后求的时候从叶子节点向根节点作差分的前缀和即可得出每个节点的救济粮个数。</p>
<p>对于每种救济粮的最大值，我们可以在每个节点开一颗权值线段树维护。树上差分则在线段树上修改，然后在求前缀和的时候使用线段树合并即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Food</span> &#123;</span><br><span class="line">    <span class="type">int</span> cnt, type;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Food</span>() &#123;&#125;</span><br><span class="line">    <span class="built_in">Food</span>(<span class="type">int</span> cnt, <span class="type">int</span> type) : <span class="built_in">cnt</span>(cnt), <span class="built_in">type</span>(type) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> Food &amp;other) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == other.cnt) <span class="keyword">return</span> type &lt; other.type;</span><br><span class="line">        <span class="keyword">return</span> cnt &gt; other.cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    Food val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="built_in">Food</span>(<span class="number">0</span>, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc, Food val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="built_in">Food</span>(<span class="number">0</span>, l));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="keyword">this</span>-&gt;l &amp;&amp; pos == <span class="keyword">this</span>-&gt;r) val.cnt += delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lc) lc = <span class="built_in">build</span>(l, mid);</span><br><span class="line">                lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">                rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">Food <span class="title">res</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (lc &amp;&amp; lc-&gt;val &gt; res) res = lc-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (rc &amp;&amp; rc-&gt;val &gt; res) res = rc-&gt;val;</span><br><span class="line">            val = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">merge</span><span class="params">(SegT *u, SegT *v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span> u;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;l == u-&gt;r) &#123;</span><br><span class="line">            u-&gt;val.cnt = u-&gt;val.cnt + v-&gt;val.cnt;</span><br><span class="line">            <span class="keyword">return</span> u;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        u-&gt;lc = <span class="built_in">merge</span>(u-&gt;lc, v-&gt;lc);</span><br><span class="line">        u-&gt;rc = <span class="built_in">merge</span>(u-&gt;rc, v-&gt;rc);</span><br><span class="line">        <span class="function">Food <span class="title">res</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;lc &amp;&amp; u-&gt;lc-&gt;val &gt; res) res = u-&gt;lc-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;rc &amp;&amp; u-&gt;rc-&gt;val &gt; res) res = u-&gt;rc-&gt;val;</span><br><span class="line">        u-&gt;val = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> u;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> d, ans;</span><br><span class="line">    Node *p, *f[LOG_MAXN + <span class="number">1</span>];</span><br><span class="line">    SegT *segment;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> ans[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;f[<span class="number">0</span>] = v-&gt;p = f;</span><br><span class="line">    v-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            v-&gt;f[i] = v-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">prepare</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;ans = v-&gt;segment-&gt;val.type;</span><br><span class="line">    <span class="keyword">if</span> (f) f-&gt;segment = SegT::<span class="built_in">merge</span>(f-&gt;segment, v-&gt;segment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) N[i].segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, MAXN);</span><br><span class="line">    <span class="built_in">prepare</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y, z;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">        Node *u = &amp;N[x], *v = &amp;N[y];</span><br><span class="line">        Node *f = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        u-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">1</span>);</span><br><span class="line">        v-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">1</span>);</span><br><span class="line">        f-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">if</span> (f-&gt;p) f-&gt;p-&gt;segment-&gt;<span class="built_in">update</span>(z, <span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N[i].ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>线段树</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
        <tag>洛谷</tag>
        <tag>树上差分</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P4341」外星联络 - Trie</title>
    <url>/luogu-4341/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4341">洛谷链接</a></p>
<p>小 P
在看过电影《超时空接触》(Contact)之后被深深的打动，决心致力于寻找外星人的事业。于是，他每天晚上都爬在屋顶上试图用自己的收音机收听外星人发来的信息。</p>
<p>虽然他收听到的仅仅是一些噪声，但是他还是按照这些噪声的高低电平将接收到的信号改写为由
<code>0</code> 和 <code>1</code> 构成的串，
并坚信外星人的信息就隐藏在其中。他认为，外星人发来的信息一定会在他接受到的
01 串中重复出现，所以他希望找到他接受到的 01 串中所有重复出现次数大于
<span class="math inline">\(1\)</span> 的子串。</p>
<p>但是他收到的信号串实在是太长了，于是，他希望你能编一个程序来帮助他。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，满足 <span
class="math inline">\(0 \le N \le 3000\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这个数据范围就限制了最高复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>对于所有子串，我们可以建立一颗 Trie。设字符串开头为 <span
class="math inline">\(1\)</span>，插入开头为 <span
class="math inline">\(1\)</span>、<span
class="math inline">\(2\)</span>、<span
class="math inline">\(3\)</span>、<span
class="math inline">\(\cdots\)</span>、<span
class="math inline">\(n\)</span>，结尾均为 <span
class="math inline">\(n\)</span>
的子串。然后从根遍历就可得到所有的子串。然后从根 DFS
统计即可得到答案。</p>
<p>对于字典序，我们可以先 DFS <span class="math inline">\(0\)</span>
节点，再 DFS <span class="math inline">\(1\)</span> 节点。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> trie[MAXN * MAXN + <span class="number">2</span>][<span class="number">2</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> end[MAXN * MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> *str, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="type">int</span> ch = str[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span> (trie[p][ch] == <span class="number">0</span>) trie[p][ch] = ++tot;</span><br><span class="line">        p = trie[p][ch];</span><br><span class="line">        end[p]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end[p] &gt; <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, end[p]);</span><br><span class="line">    <span class="keyword">if</span> (trie[p][<span class="number">0</span>]) <span class="built_in">dfs</span>(trie[p][<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">if</span> (trie[p][<span class="number">1</span>]) <span class="built_in">dfs</span>(trie[p][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> str[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, str);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">insert</span>(str + i, n - i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>洛谷</tag>
        <tag>字符串</tag>
        <tag>Trie</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P6218」Round Numbers - 数位 DP</title>
    <url>/luogu-6218/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P6218">洛谷链接</a></p>
<p>如果一个正整数的二进制表示中，<span class="math inline">\(0\)</span>
的数目不小于 <span class="math inline">\(1\)</span>
的数目，那么它就被称为「圆数」。</p>
<p>例如，<span class="math inline">\(9\)</span> 的二进制表示为 <span
class="math inline">\(1001\)</span>，其中有 <span
class="math inline">\(2\)</span> 个 <span
class="math inline">\(0\)</span> 与 <span
class="math inline">\(2\)</span> 个 <span
class="math inline">\(1\)</span>。因此，<span
class="math inline">\(9\)</span> 是一个「圆数」。</p>
<p>请你计算，区间 <span class="math inline">\([l,r]\)</span>
中有多少个「圆数」。</p>
<p>数据范围：<span class="math inline">\(1\le l,r\le 2\times
10^9\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然数位 DP。我们设 <span class="math inline">\(a_n\)</span>
为小于等于 <span class="math inline">\(n\)</span>
中的圆数的个数，则答案为 <span class="math inline">\(a_r - a_{l -
1}\)</span>。其中 <span class="math inline">\(a_n\)</span> 可用数位 DP
解决。</p>
<p>对于 <span class="math inline">\(a_i\)</span>，我们首先将 <span
class="math inline">\(n\)</span> 使用二进制表示。设 <span
class="math inline">\(n\)</span> 有 <span
class="math inline">\(\text{len}\)</span> 位，于是圆数至少要有 <span
class="math inline">\(\text{need} = \lfloor \frac{\text{len} + 1}{2}
\rfloor\)</span> 个 <span class="math inline">\(0\)</span>。设 <span
class="math inline">\(f_{i, \text{last}, \text{num}}\)</span> 为剩下
<span class="math inline">\(i\)</span> 位时，前 <span
class="math inline">\(\text{len} - \text{i} - 1\)</span> 位有 <span
class="math inline">\(\text{last}\)</span> 个 <span
class="math inline">\(0\)</span>，第 <span
class="math inline">\(\text{len} - \text{i}\)</span> 位为 <span
class="math inline">\(\text{num}\)</span>，且小于剩余 <span
class="math inline">\(i\)</span> 位均为 <span
class="math inline">\(0\)</span>
的数时的圆数个数。显然我们可得到下列状态转移方程：</p>
<p><span class="math display">\[
f_{i, \text{last}, \text{num}} =
\begin{cases}
\begin{align}
&amp; \sum_{j = 1}^{\text{len - 1}}\sum_{k = \lfloor \frac{i + 1}{2}
\rfloor}^{j - 1}{j - 1 \choose k} &amp; i = \text{len} - 1 \wedge
\text{num} = 1 \\
&amp; \sum_{j = \text{need} - \text{last} - 1}^{i}{i \choose j} &amp; i
\ne \text{len} - 1 \wedge \text{num} = 1 \\
&amp; 0 &amp; \text{num} = 0
\end{align}
\end{cases}
\]</span></p>
<ul>
<li>公式 <span class="math inline">\((1)\)</span> 表示遍历第 <span
class="math inline">\(1\)</span> 位的情况，由于这种情况不可含前导 <span
class="math inline">\(0\)</span> 所以要特殊处理；</li>
<li>公式 <span class="math inline">\((2)\)</span>
表示遍历到后面位数时该位为 <span class="math inline">\(1\)</span>
的情况，此时 <span class="math inline">\(f_{i, \text{last},
\text{num}}\)</span> 则计算当小于当前数的情况，即该位为 <span
class="math inline">\(0\)</span>、后面位数任意时圆数的个数；</li>
<li>公式 <span class="math inline">\((3)\)</span>
表示遍历到后面位数时该位为 <span class="math inline">\(0\)</span>
的情况，由于不存在比 <span class="math inline">\(0\)</span>
小的自然数，故 <span class="math inline">\(f_{i, \text{last},
\text{num}} = 0\)</span>。</li>
</ul>
<p>设 <span class="math inline">\(n\)</span> 的前 <span
class="math inline">\(\text{len} - \text{i}\)</span> 位的 <span
class="math inline">\(0\)</span> 的个数为 <span
class="math inline">\(\text{last}_i\)</span>、第 <span
class="math inline">\(\text{len} - \text{i}\)</span> 位为 <span
class="math inline">\(\text{num}_i\)</span>。于是我们可以预处理组合数，计算出答案
<span class="math inline">\(a_n = (\sum_{i = 1}^{\text{len}}\sum_{j =
0}^{\text{num}_i}{f_{i, \text{last}_i, j}}) + [n \in
\text{圆数}]\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> C[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == <span class="number">0</span>) C[i][j] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> C[i][j] = C[i - <span class="number">1</span>][j] + C[i- <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (; n; n &gt;&gt;= <span class="number">1</span>) nums.<span class="built_in">push_back</span>(n &amp; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>(), need = (len + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="type">int</span> x = nums[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == len - <span class="number">1</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = (j + <span class="number">1</span>) / <span class="number">2</span>; k &lt;= j - <span class="number">1</span>; k++) &#123;</span><br><span class="line">                        res += C[j - <span class="number">1</span>][k];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = need - last - <span class="number">1</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                    res += C[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> last++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; last &gt;= need) res++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">prepare</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;l, &amp;r);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="built_in">solve</span>(r) - <span class="built_in">solve</span>(l - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>洛谷</tag>
        <tag>USACO</tag>
        <tag>数位 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P5154」数列游戏 - 区间 DP + 线性 DP</title>
    <url>/luogu-5154/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P5154">洛谷链接</a></p>
<p>有一次，HKE 和 LJC 在玩一个游戏。</p>
<p>游戏的规则是这样的：LJC 在纸上写下两个长度均为 <span
class="math inline">\(n\)</span> 的数列 <span
class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span>，两个数列一一对应。HKE
每次可以找两个相邻的数 <span class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(a_{i + 1}\)</span>，如果它们两个不互质，HKE
可以选择得到 <span class="math inline">\((b_i + b_{i + 1})\)</span>
分，然后擦掉 <span class="math inline">\(a\)</span> 和 <span
class="math inline">\(b\)</span> 位置上的第 <span
class="math inline">\(i, i + 1\)</span>
个数，并把两个序列重新按顺序编号。当所有相邻的数互质时，游戏结束。</p>
<p>HKE 想知道他最大得分是多少。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>对于这道题，我们首先可以使用区间 DP 解决。</p>
<p>我们可以设 <span class="math inline">\(f_{l, r}\)</span> 表示区间
<span class="math inline">\([l, r]\)</span> 可合并为 <span
class="math inline">\(1\)</span> 个数所得分数。显然有下列方程：</p>
<p><span class="math display">\[
f_{l, r} = \max\begin{cases}
f_{l + 1, r - 1} + b_l + b_r &amp; \gcd(a_l, a_r) \ne 1 \\
f_{l, k} + f_{k + 1, r} &amp; k \in (l, r)
\end{cases}
\]</span></p>
<p>初始化：当 <span class="math inline">\(\gcd(a_i, a_{i + 1}) \ne
1\)</span> 时，<span class="math inline">\(f_{i, i + 1} = b_i + b_{i +
1}\)</span>，其余情况 <span class="math inline">\(f_{l, r} =
-\infty\)</span>。</p>
<p>接下来我们将利用这个区间 DP 的结果得出正确答案。</p>
<p>接下来我们进行线性 DP。以求出可互质情况下的最终答案。</p>
<p>我们设 <span class="math inline">\(g_i\)</span> 表示遍历到第 <span
class="math inline">\(i\)</span>
个数的最优答案。于是有下列转移方程：</p>
<p><span class="math display">\[
g_i = \max\begin{cases}
g_{i - 1} \\
g_j + f_{j + 1, i} &amp; j \in [0, i)
\end{cases}
\]</span></p>
<p>最终答案为 <span class="math inline">\(g_n\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">800</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">1</span>], b[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;b[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> f[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">gcd</span>(a[i], a[i + <span class="number">1</span>]) != <span class="number">1</span>) &#123;</span><br><span class="line">            f[i][i + <span class="number">1</span>] = b[i] + b[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> len = <span class="number">4</span>; len &lt;= n; len += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; l++) &#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">gcd</span>(a[l], a[r]) != <span class="number">1</span>) f[l][r] = f[l + <span class="number">1</span>][r - <span class="number">1</span>] + b[l] + b[r];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = l + <span class="number">1</span>; k &lt;= r - <span class="number">1</span>; k += <span class="number">2</span>) f[l][r] = std::<span class="built_in">max</span>(f[l][r], f[l][k] + f[k + <span class="number">1</span>][r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> g[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        g[i] = g[i - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; j++) g[i] = std::<span class="built_in">max</span>(g[i], g[j] + f[j + <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, g[n]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>洛谷</tag>
        <tag>区间 DP</tag>
        <tag>线性 DP</tag>
      </tags>
  </entry>
  <entry>
    <title>「洛谷 P5782」和平委员会 - 2-SAT</title>
    <url>/luogu-5782/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P5782">洛谷链接</a></p>
<p>根据宪法，Byteland
民主共和国的公众和平委员会应该在国会中通过立法程序来创立。
不幸的是，由于某些党派代表之间的不和睦而使得这件事存在障碍。
此委员会必须满足下列条件：</p>
<ul>
<li>每个党派都在委员会中恰有 <span class="math inline">\(1\)</span>
个代表。</li>
<li>如果 <span class="math inline">\(2\)</span>
个代表彼此厌恶，则他们不能都属于委员会。</li>
</ul>
<p>每个党在议会中有 <span class="math inline">\(2\)</span>
个代表。代表从 <span class="math inline">\(1\)</span> 编号到 <span
class="math inline">\(2n\)</span>。 编号为 <span
class="math inline">\(2i-1\)</span> 和 <span
class="math inline">\(2i\)</span> 的代表属于第 <span
class="math inline">\(i\)</span> 个党派。</p>
<p>任务：写一程序读入党派的数量和关系不友好的代表对，计算决定建立和平委员会是否可能，若行，则列出委员会的成员表。</p>
<p>对于 <span class="math inline">\(100\%\)</span> 的数据，<span
class="math inline">\(1 \leq n \leq 8000\)</span>，<span
class="math inline">\(0 \leq m \leq 20000\)</span>，<span
class="math inline">\(1 \leq a &lt; b \leq 8000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这是一道 2-SAT 问题。</p>
<p>如果 <span class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 互相厌恶，那么只能 <span
class="math inline">\(a\)</span> 出现时 <span class="math inline">\(b
\oplus 1\)</span> 必定出现，或 <span class="math inline">\(b\)</span>
出现时 <span class="math inline">\(a \oplus 1\)</span> 必定出现。连接
<span class="math inline">\(a \rightarrow (b \oplus 1)\)</span> 和 <span
class="math inline">\(b \rightarrow (a \oplus 1)\)</span>
这两条边，然后跑一遍 2-SAT 就得出答案了。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">80000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="type">int</span> dfn, low;</span><br><span class="line">    <span class="type">bool</span> v;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Connected</span> *connected;</span><br><span class="line">&#125; N[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Connected</span> &#123;</span><br><span class="line">    <span class="type">int</span> size, id;</span><br><span class="line">&#125; connecteds[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(Node *x)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> num = <span class="number">0</span>, counts = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> std::stack&lt;Node *&gt; stk;</span><br><span class="line">    x-&gt;dfn = x-&gt;low = ++num;</span><br><span class="line">    stk.<span class="built_in">push</span>(x);</span><br><span class="line">    x-&gt;v = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;x-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;x-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!e-&gt;t-&gt;dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(e-&gt;t);</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;low);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e-&gt;t-&gt;v) &#123;</span><br><span class="line">            x-&gt;low = std::<span class="built_in">min</span>(x-&gt;low, e-&gt;t-&gt;dfn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (x-&gt;dfn == x-&gt;low) &#123;</span><br><span class="line">        counts++;</span><br><span class="line">        connecteds[counts].id = counts;</span><br><span class="line">        Node *y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            y-&gt;v = <span class="literal">false</span>;</span><br><span class="line">            y-&gt;connected = &amp;connecteds[counts];</span><br><span class="line">            connecteds[counts].size++;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b % <span class="number">2</span> ? b + <span class="number">1</span> : b - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">addEdge</span>(b, a % <span class="number">2</span> ? a + <span class="number">1</span> : a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!N[i].dfn) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(&amp;N[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (N[i].connected == N[i + <span class="number">1</span>].connected) &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;NIE&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">2</span> * n; i += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, N[i].connected-&gt;id &lt; N[i + <span class="number">1</span>].connected-&gt;id ? i : i + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>POI</tag>
        <tag>2001</tag>
        <tag>洛谷</tag>
        <tag>2-SAT</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>莫比乌斯反演学习笔记</title>
    <url>/mobius-notes/</url>
    <content><![CDATA[<h1 id="莫比乌斯函数">莫比乌斯函数</h1>
<p>了解莫比乌斯反演前，我们先要了解莫比乌斯函数。记 <span
class="math inline">\(\mu(n)\)</span> 为莫比乌斯函数，<span
class="math inline">\(n\)</span> 可被分解质因数为 <span
class="math inline">\(n = \prod_{i = 1}^{m}{ {p_i}^{c_i} }\)</span>
定义如下：</p>
<p><span class="math display">\[
\mu(n) = \begin{cases}
1 &amp; n = 1 \\
0 &amp; \exists i \in [1, m], c_i &gt; 1 \\
(-1)^m &amp; \forall i \in [1, m], c_i = 1 \\
\end{cases}
\]</span></p>
<p>形式化地解释一下：</p>
<ul>
<li>当 <span class="math inline">\(n = 1\)</span> 时，<span
class="math inline">\(\mu(n) = 1\)</span>；</li>
<li>当 <span class="math inline">\(n\)</span>
存在至少一个出现次数大于等于两次的质因子时，<span
class="math inline">\(\mu(n) = 0\)</span>；</li>
<li>当 <span class="math inline">\(n\)</span>
的所有质因子仅出现过一次，且 <span class="math inline">\(n\)</span>
有奇数个质因子时，<span class="math inline">\(\mu(n) =
-1\)</span>；</li>
<li>当 <span class="math inline">\(n\)</span>
的所有质因子仅出现过一次，且 <span class="math inline">\(n\)</span>
有偶数个质因子时，<span class="math inline">\(\mu(n) = 1\)</span>。</li>
</ul>
<span id="more"></span>
<h1 id="莫比乌斯函数的性质">莫比乌斯函数的性质</h1>
<h2 id="积性函数">积性函数</h2>
<p>首先易得 <span class="math inline">\(\mu(i)\)</span>
为积性函数，即对于 <span class="math inline">\(\forall a, b \in
\mathbb{N}^*\)</span>，且 <span class="math inline">\(\gcd(a, b) =
1\)</span>，均满足 <span class="math inline">\(\mu(ab) = \mu(a)
\mu(b)\)</span>。于是 <span class="math inline">\(\mu(n)\)</span>
满足积性函数性质：</p>
<ul>
<li>令 <span class="math inline">\(n\)</span> 分解质因数为 <span
class="math inline">\(n = \prod_{i = 1}^{m}{ {p_i}^{c_i}
}\)</span>，则有 <span class="math inline">\(\mu(n) = \prod_{i =
1}^{m}{\mu({p_i}^{c_i})}\)</span></li>
</ul>
<p>证明显然。</p>
<h3 id="筛法">筛法</h3>
<p>由于是积性函数，我们可以用线性筛求莫比乌斯函数。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="特殊性质">特殊性质</h2>
<p>莫比乌斯函数还有以下性质：</p>
<p><span class="math display">\[
\sum_{d | n}{\mu(d)} = [n = 1]
\]</span></p>
<p>其中 <span class="math inline">\([n = 1]\)</span> 表示：当 <span
class="math inline">\(n = 1\)</span> 时，该值为 <span
class="math inline">\(1\)</span>；否则该值为 <span
class="math inline">\(0\)</span>。</p>
<p>证明：</p>
<ul>
<li>当 <span class="math inline">\(n = 1\)</span> 时，显然成立；</li>
<li>当 <span class="math inline">\(n \ne 1\)</span> 时：首先我们将 <span
class="math inline">\(n\)</span> 分解质因数为 <span
class="math inline">\(n = \prod_{i = 1}^{m}{ {p_i}^{c_i} } \quad m &gt;
1\)</span>，设 <span class="math inline">\(n&#39; = \prod_{i =
1}^{m}{p_i}\)</span>，显然有 <span class="math inline">\(\sum_{d |
n}{\mu(d)} = \sum_{d | n&#39;}{\mu(d)}\)</span>，通过组合数学可得：<span
class="math inline">\(\sum_{d | n&#39;}{\mu(d)} = \sum_{i = 0}^m{ {m
\choose i} (-1)^m }\)</span>。由二项式定理可得：<span
class="math inline">\((1 + (-1))^m = \sum_{i = 0}^{m}{ {m \choose i}
(-1)^m }\)</span>，故我们可得 <span class="math inline">\(\sum_{d | n}{
\mu(d) } = 0^m = 0\)</span>。</li>
</ul>
<h1 id="莫比乌斯反演">莫比乌斯反演</h1>
<p>接下来就是莫比乌斯反演了。莫比乌斯反演定义如下：</p>
<p>设 <span class="math inline">\(f(n)\)</span>，<span
class="math inline">\(F(n)\)</span>
为数论函数（即定义域为正整数的函数），则满足下列关系：</p>
<p><span class="math display">\[
F(n) = \sum_{d | n}{f(d)} \Rightarrow
f(n) = \sum_{d | n}{\mu(d)F(\frac{n}{d})}
\]</span></p>
<p>莫比乌斯反演还有下列另一种形式：</p>
<p><span class="math display">\[
F(n) = \sum_{n | d}{f(d)} \Rightarrow
f(n) = \sum_{n | d}{\mu(\frac{d}{n})F(d)}
\]</span></p>
<h2 id="证明">证明</h2>
<h3 id="狄利克雷卷积">狄利克雷卷积</h3>
<p>在证明之前，我们需要先了解狄利克雷卷积。</p>
<p>对于两个数论函数 <span class="math inline">\(f(n)\)</span> 与 <span
class="math inline">\(g(n)\)</span>，定义两函数的狄利克雷卷积（其中
<span class="math inline">\((n)\)</span> 可省略不写）：</p>
<p><span class="math display">\[
(f * g)(n) = \sum_{d | n}{f(d)g(\frac{n}{d})}
\]</span></p>
<p>显然该运算满足以下运算律：</p>
<ul>
<li>交换律：<span class="math inline">\(f * g = g * f\)</span></li>
<li>结合律：<span class="math inline">\((f * g) * h = f * (g *
h)\)</span></li>
<li>分配律：<span class="math inline">\(f * (g + h) = f * g + f *
h\)</span></li>
</ul>
<p>我们定义 <span class="math inline">\(\varepsilon(n) = [n =
1]\)</span> 为单位函数，显然有以下结论：</p>
<p><span class="math display">\[
f = f * \varepsilon = \varepsilon * f
\]</span></p>
<h3 id="证明步骤">证明步骤</h3>
<p>接下来就可以证明了。利用卷积定义可推出：</p>
<p><span class="math display">\[
\sum_{d | n}{\mu(d)} = [n = 1] \Rightarrow \mu * 1 = \varepsilon
\]</span></p>
<p><span class="math display">\[
F(n) = \sum_{d | n}{f(d)} \Rightarrow F = f * 1
\]</span></p>
<p>故我们可以推出：</p>
<p><span class="math display">\[
\begin{align*}
F * \mu &amp;= f * 1 * \mu \\
\Rightarrow F * \mu &amp;= f * (\mu * 1) \\
\Rightarrow F * \mu &amp;= f * \varepsilon \\
\Rightarrow F * \mu &amp;= f
\end{align*}
\]</span></p>
<p>将最后的等式展开即可得：</p>
<p><span class="math display">\[
f(n) = \sum_{d | n}{\mu(d)F(\frac{n}{d})}
\]</span></p>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
      </tags>
  </entry>
  <entry>
    <title>「牛客 CSP-S 模拟赛」光 - 二分答案</title>
    <url>/nc-40645a/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://ac.nowcoder.com/acm/contest/40645/A">牛客链接（需付费）</a></p>
<p>在一个 <span class="math inline">\(2 \times 2\)</span>
的网格上有四盏灯，每个网格一盏。这四盏灯的位置分别是左上角，右上角，左下角，右下角。</p>
<p>每盏灯有一个可供调节的耗电量，耗电量越高，则灯对周围提供的亮度越多。具体来说，若某一盏灯的耗电量为
<span class="math inline">\(x\)</span>，那么它将会为自己的格子提供 <span
class="math inline">\(x\)</span> 的亮度，为相邻的两个格子提供 <span
class="math inline">\(\lfloor \frac{x}{2} \rfloor\)</span>
的亮度，为对角的格子提供 <span class="math inline">\(\lfloor \frac{x}{4}
\rfloor\)</span>。其中 <span class="math inline">\(\lfloor x
\rfloor\)</span> 表示对 <span class="math inline">\(x\)</span>
向下取整。</p>
<p>某一个<strong>格子的亮度</strong>是四盏灯对它提供的亮度之和。例如左上角的灯耗电量为
<span class="math inline">\(4\)</span>，右上角的灯耗电量为 <span
class="math inline">\(7\)</span>，右下角的灯耗电量为 <span
class="math inline">\(8\)</span>，左下角的灯耗电量为 <span
class="math inline">\(0\)</span>，那么左上角这个格子的亮度就是 <span
class="math inline">\(4 + \lfloor \frac{7}{2} \rfloor + \lfloor
\frac{8}{4} \rfloor + 0 = 9\)</span></p>
<p>现在我们对 <strong>四个格子的最低亮度</strong>
提出了要求，我们想要让四个格子的亮度都达到标准。你可以将每一盏灯的耗电量调节为任何一个大于等于零的整数，为了省电，你希望四盏灯的耗电量之和尽可能的小，请问
<strong>四盏灯的最小耗电量之和</strong> 是多小？</p>
<p>数据范围：四个格子的最低亮度均为正整数且不超过 <span
class="math inline">\(1500\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题由于直接算出四个格子的耗电量较为困难，可考虑二分答案，二分总耗电值。假设我们已经二分出了耗电值为
<span
class="math inline">\(\text{limit}\)</span>，我们可以枚举一下左上角和右下角的耗电值，然后判断出是否合法，再通过剩余的耗电值算出另外两个格子的耗电值是否合法即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a, b, c, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(a, <span class="number">4</span> * d), std::<span class="built_in">max</span>(<span class="number">2</span> * b, <span class="number">2</span> * d)); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= std::<span class="built_in">max</span>(std::<span class="built_in">max</span>(<span class="number">4</span> * a, d), std::<span class="built_in">max</span>(<span class="number">2</span> * b, <span class="number">2</span> * d)); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i + j &gt; limit) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> ((limit - i - j) / <span class="number">2</span> &lt; std::<span class="built_in">max</span>(a - i - j / <span class="number">4</span>, d - i / <span class="number">4</span> - j)) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> res = limit - i - j;</span><br><span class="line">            <span class="type">int</span> y = std::<span class="built_in">max</span>(<span class="number">0</span>, b - i / <span class="number">2</span> - j / <span class="number">2</span>), z = std::<span class="built_in">max</span>(<span class="number">0</span>, c - i / <span class="number">2</span> - j / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= res; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (k + (res - k) / <span class="number">4</span> &gt;= y &amp;&amp; k / <span class="number">4</span> + res - k &gt;= z) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = a + b + c + d;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>2022</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>牛客</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2001」炮兵阵地 - 状压 DP</title>
    <url>/noi2001-cannon/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2704">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10173">LOJ 链接</a></p>
<p>司令部的将军们打算在 <span class="math inline">\(N \times M\)</span>
的网格地图上部署他们的炮兵部队。一个 <span class="math inline">\(N
\times M\)</span> 的地图由 <span class="math inline">\(N\)</span> 行
<span class="math inline">\(M\)</span>
列组成，地图的每一格可能是山地（用 H 表示），也可能是平原（用 P
表示），如下图。在每一格平原地形上最多可以布置一支炮兵部队（山地上不能够部署炮兵部队）；一支炮兵部队在地图上的攻击范围如图中黑色区域所示：</p>
<img src="/noi2001-cannon/cannon.png" class="">
<p>如果在地图中的灰色所标识的平原上部署一支炮兵部队，则图中的黑色的网格表示它能够攻击到的区域：沿横向左右各两格，沿纵向上下各两格。图上其它白色网格均攻击不到。从图上可见炮兵的攻击范围不受地形的影响。</p>
<p>现在，将军们规划如何部署炮兵部队，在防止误伤的前提下（保证任何两支炮兵部队之间不能互相攻击，即任何一支炮兵部队都不在其他支炮兵部队的攻击范围内），在整个地图区域内最多能够摆放多少我军的炮兵部队。</p>
<p>数据范围：<span class="math inline">\(N \leq 100\)</span>，<span
class="math inline">\(M \leq 10\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然这道题是状压 DP。</p>
<p>对于这道题，由于放置本行的炮兵和上两行都有关，于是我们可以定义状态为：</p>
<p><span class="math display">\[
f_{i, j, k} \quad i \in [1, n] \cap \mathbb{Z}, j \in S_j, k \in S_k
\]</span></p>
<p>其中 <span class="math inline">\(i\)</span> 表示遍历到第 <span
class="math inline">\(i\)</span> 行，<span
class="math inline">\(j\)</span> 表示该行状态，<span
class="math inline">\(k\)</span> 表示上一行状态。其中 <span
class="math inline">\(S_j\)</span>，<span
class="math inline">\(S_k\)</span> 分别表示 <span
class="math inline">\(j\)</span> 和 <span
class="math inline">\(k\)</span> 的合法情况的集合。</p>
<p>于是我们可以很容易地推出下列状态转移方程：</p>
<p><span class="math display">\[
f_{i, j, k} = \max \limits_{l \in S_l} \{ f_{i - 1, k, l} + \text{cnt}_j
\} \quad i \in (1, n] \cap \mathbb{Z}, j \in S_j, k \in S_k
\]</span></p>
<p>其中 <span class="math inline">\(l\)</span> 为上两行的状态，<span
class="math inline">\(S_l\)</span> 同理。<span
class="math inline">\(\text{cnt}_j\)</span> 表示的是在第 <span
class="math inline">\(j\)</span> 行放置的炮兵数。</p>
<p>对于该题，由于空间有限，我们可以先将合法的状态存起来，离散化一下，遍历的时候就直接用离散化过的数据遍历即可。时间复杂度为
<span class="math inline">\(O(n(2^m)^3) =
O(n8^m)\)</span>，空间复杂度远小于时间复杂度。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>, MAXM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">char</span> board[MAXN + <span class="number">1</span>][MAXM + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> f[MAXN + <span class="number">1</span>][<span class="number">30</span> * MAXM + <span class="number">1</span>][<span class="number">30</span> * MAXM + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> s[<span class="number">100</span> * MAXM + <span class="number">1</span>], len = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; m); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i &lt;&lt; <span class="number">1</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; (i &lt;&lt; <span class="number">2</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        s[++len] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">count</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((s[x] &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> pos, <span class="type">int</span> now)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((board[pos][i + <span class="number">1</span>] == <span class="string">&#x27;H&#x27;</span>) &amp;&amp; ((s[now] &gt;&gt; i) &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getSet</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    f[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(<span class="number">1</span>, i)) &#123;</span><br><span class="line">            f[<span class="number">1</span>][i][<span class="number">0</span>] = <span class="built_in">count</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(i, j)) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt;= len; k++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">1</span>, k) &amp;&amp; (s[j] &amp; s[k]) == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt;= len; l++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (<span class="built_in">check</span>(i - <span class="number">2</span>, l) &amp;&amp; (s[j] &amp; s[l]) == <span class="number">0</span>) &#123;</span><br><span class="line">                                f[i][j][k] = std::<span class="built_in">max</span>(f[i][j][k], f[i - <span class="number">1</span>][k][l] + <span class="built_in">count</span>(j));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= len; j++) &#123;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, f[n][i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            std::cin &gt;&gt; board[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getAns</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>2001</tag>
        <tag>状压 DP</tag>
        <tag>NOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「牛客 CSP-S 模拟赛」躲避技能 - 树上差分 + 贪心 + 高精度</title>
    <url>/nc-40646a/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://ac.nowcoder.com/acm/contest/40646/A">牛客链接（需付费）</a></p>
<p>鸡尾酒是一个多操手，他可以同时操作 <span
class="math inline">\(m\)</span> 个账号。今天，他使用这些账号一起打一个
boss。这个 boss 战的地图共有 <span class="math inline">\(n\)</span>
个关键点，其中有 <span class="math inline">\(n - 1\)</span>
条边，每条边连接着两个不同的点，使得从任意点出发可以到达其他所有的点。鸡尾酒的
<span class="math inline">\(m\)</span> 个账号分别编号 <span
class="math inline">\(1\)</span> 至 <span
class="math inline">\(m\)</span>，一开始，第 <span
class="math inline">\(i\)</span> 个账号在点 <span
class="math inline">\(s_i\)</span>。<strong>可能有两个账号在同一位置</strong>。</p>
<p>现在，boss 放出了一个致命技能。boss 在地图上标出了 <span
class="math inline">\(m\)</span>
个关键点，想成功躲避这个技能，必须在每一个被标记的点上，都有一个账号站在上面。<strong>注意，可能会有点被多次标记，多次标记的点需要有多个账号站在上面</strong>。</p>
<p>由于鸡尾酒无法分身，所以
<strong>他必须先把一个账号移动到一个位置，才能动另一个账号，不能同时移动多个账号</strong>。假设鸡尾酒的任意账号通过第
<span class="math inline">\(i\)</span> 条边的时间为 <span
class="math inline">\(w_i\)</span>，请帮鸡尾酒求出他成功躲避技能所需要的最少时间。</p>
<p>数据范围：<span class="math inline">\(1 \le n, m \le
10^5\)</span>，<span class="math inline">\(1 \le w_i \le
10^{100}\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>通过贪心分析题目性质，我们可以发现对于一颗子树，优先在子树中匹配是不劣的。因为两点仅有一条路径，且匹配到子树外必须经过根的边，于是优先在子树中匹配可尽量少走必须的边。这样我们就可以通过
DFS 得出方案。</p>
<p>考虑树上差分，我们对每个起点标记 <span
class="math inline">\(+1\)</span>，在每个终点标记 <span
class="math inline">\(-1\)</span>，从任一点开始 DFS
进行树上差分即可判断出在何时两点匹配。计算答案时只需将子树的答案加起来再加上未匹配的点经过边到达父亲所需的边权即可。由于
<span class="math inline">\(w_i\)</span> 过大，此题再写个高精即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BigInt</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MAXM = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> <span class="type">int</span> n = <span class="number">0</span>) &#123; *<span class="keyword">this</span> = n; &#125;</span><br><span class="line"></span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>=(<span class="type">int</span> x) &#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="keyword">do</span> v.<span class="built_in">push_back</span>(x % <span class="number">10</span>); <span class="keyword">while</span> (x /= <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInt &amp;<span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">char</span> s[MAXN + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        v.<span class="built_in">resize</span>(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; len; i++) v[i] = s[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = v.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, v[i]);</span><br><span class="line">        <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>+(<span class="type">const</span> BigInt &amp;a, <span class="type">const</span> BigInt &amp;b) &#123;</span><br><span class="line">    BigInt res;</span><br><span class="line">    res.v.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">max</span>(a.v.<span class="built_in">size</span>(), b.v.<span class="built_in">size</span>()); i++) &#123;</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; a.v.<span class="built_in">size</span>()) t += a.v[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt; b.v.<span class="built_in">size</span>()) t += b.v[i];</span><br><span class="line">        <span class="keyword">if</span> (flag) t++, flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">10</span>) t -= <span class="number">10</span>, flag = <span class="literal">true</span>;</span><br><span class="line">        res.v.<span class="built_in">push_back</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) res.v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt &amp;<span class="keyword">operator</span>+=(BigInt &amp;a, <span class="type">const</span> BigInt &amp;b) &#123;</span><br><span class="line">    <span class="keyword">return</span> a = a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BigInt <span class="keyword">operator</span>*(<span class="type">const</span> BigInt &amp;a, <span class="type">const</span> BigInt &amp;b) &#123;</span><br><span class="line">    BigInt res;</span><br><span class="line">    res.v.<span class="built_in">resize</span>(a.v.<span class="built_in">size</span>() + b.v.<span class="built_in">size</span>() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; a.v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; b.v.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            res.v[i + j] += a.v[i] * b.v[j];</span><br><span class="line">            res.v[i + j + <span class="number">1</span>] += res.v[i + j] / <span class="number">10</span>;</span><br><span class="line">            res.v[i + j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (res.v.<span class="built_in">size</span>() &gt; <span class="number">1</span> &amp;&amp; res.v.<span class="built_in">back</span>() == <span class="number">0</span>) res.v.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; adj;</span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    BigInt w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, BigInt w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, BigInt w)</span> </span>&#123;</span><br><span class="line">    N[u].adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[u], &amp;N[v], w));</span><br><span class="line">    N[v].adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[v], &amp;N[u], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::pair&lt;BigInt, <span class="type">int</span>&gt; <span class="title">dfs</span><span class="params">(Node *u, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    BigInt val = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> cnt = u-&gt;cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge e : u-&gt;adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        std::pair&lt;BigInt, <span class="type">int</span>&gt; res = <span class="built_in">dfs</span>(e.t, u);</span><br><span class="line">        res.first += std::<span class="built_in">abs</span>(res.second) * e.w;</span><br><span class="line">        val += res.first, cnt += res.second;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(val, cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> s;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;s);</span><br><span class="line">        N[s].cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line">        N[t].cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        BigInt w;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        w.<span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">addEdge</span>(u, v, w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(&amp;N[<span class="number">1</span>]).first.<span class="built_in">print</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>贪心</tag>
        <tag>2022</tag>
        <tag>树上差分</tag>
        <tag>牛客</tag>
        <tag>高精度</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2015」软件包管理器 - 树链剖分</title>
    <url>/noi2015-manager/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2146">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2130">LOJ 链接</a></p>
<p>你决定设计你自己的软件包管理器。不可避免地，你要解决软件包之间的依赖问题。如果软件包
<span class="math inline">\(A\)</span> 依赖软件包 <span
class="math inline">\(B\)</span>，那么安装软件包 <span
class="math inline">\(A\)</span> 以前，必须先安装软件包 <span
class="math inline">\(B\)</span>。同时，如果想要卸载软件包 <span
class="math inline">\(B\)</span>，则必须卸载软件包 <span
class="math inline">\(A\)</span>。现在你已经获得了所有的软件包之间的依赖关系。而且，由于你之前的工作，除
<span class="math inline">\(0\)</span>
号软件包以外，在你的管理器当中的软件包都会依赖一个且仅一个软件包，而
<span class="math inline">\(0\)</span>
号软件包不依赖任何一个软件包。依赖关系不存在环（若有 <span
class="math inline">\(m \ (m \geq 2)\)</span> 个软件包<span
class="math inline">\(A_1, A_2, A_3, \ldots ,A_m\)</span>，其中 <span
class="math inline">\(A_1\)</span> 依赖 <span
class="math inline">\(A_2\)</span>，<span
class="math inline">\(A_2\)</span> 依赖 <span
class="math inline">\(A_3\)</span>，<span
class="math inline">\(A_3\)</span> 依赖 <span
class="math inline">\(A_4\)</span>，……，<span
class="math inline">\(A_{m−1}\)</span> 依赖 <span
class="math inline">\(A_m\)</span>，而 <span
class="math inline">\(A_m\)</span> 依赖 <span
class="math inline">\(A_1\)</span>，则称这 <span
class="math inline">\(m\)</span>
个软件包的依赖关系构成环），当然也不会有一个软件包依赖自己。</p>
<p>现在你要为你的软件包管理器写一个依赖解决程序。根据反馈，用户希望在安装和卸载某个软件包时，快速地知道这个操作实际上会改变多少个软件包的安装状态（即安装操作会安装多少个未安装的软件包，或卸载操作会卸载多少个已安装的软件包），你的任务就是实现这个部分。注意，安装一个已安装的软件包，或卸载一个未安装的软件包，都不会改变任何软件包的安装状态，即在此情况下，改变安装状态的软件包数为
<span class="math inline">\(0\)</span>。</p>
<p>对于所有数据，<span class="math inline">\(n \leq 100000, \ q \leq
100000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题是一个树上问题。由于是对路径上以及子树上的点操作，我们可以想到使用树链剖分解决。我们可以使用可以使用线段树维护每个点是否被安装，以及这条链或子树上安装的软件的数量。</p>
<p>接下来需要解决软件的安装卸载问题。对于安装软件 <span
class="math inline">\(x\)</span>，我们只需要将从根节点到 <span
class="math inline">\(x\)</span>
的这条路径上的所有软件安装即可；对于卸载软件 <span
class="math inline">\(x\)</span>，我们只需要将以 <span
class="math inline">\(x\)</span>
为根节点的子树中的所有软件删除即可。</p>
<p>维护时我们在线段树可处理懒标记 <span
class="math inline">\(-1\)</span>、<span
class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>
三种值，分别表示无操作、将区间中所有数赋值为 <span
class="math inline">\(0\)</span>、将区间中所有数赋值为 <span
class="math inline">\(1\)</span>。序列中所有数只有 <span
class="math inline">\(0\)</span>、<span class="math inline">\(1\)</span>
两种数，线段树维护区间和即可满足题目要求。</p>
<p>对于记录每次该边的状态，我们只需要在每次操作前先求出已安装的软件数量，然后和操作后的安装软件数量比较即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chain</span> *chain;</span><br><span class="line">    <span class="type">int</span> size, dfn, depth;</span><br><span class="line">    Node *fa, *ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Chain</span>(Node *top) : <span class="built_in">top</span>(top) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    v-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        e.t-&gt;fa = v;</span><br><span class="line">        e.t-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.t, v);</span><br><span class="line">        v-&gt;size += e.t-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;ch || v-&gt;ch-&gt;size &lt; e.t-&gt;size) v-&gt;ch = e.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ts = <span class="number">0</span>;</span><br><span class="line">    v-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v-&gt;fa || v != v-&gt;fa-&gt;ch) v-&gt;chain = <span class="keyword">new</span> <span class="built_in">Chain</span>(v);</span><br><span class="line">    <span class="keyword">else</span> v-&gt;chain = v-&gt;fa-&gt;chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ch) <span class="built_in">dfs2</span>(v-&gt;ch);</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;fa == v &amp;&amp; e.t != v-&gt;ch) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    v-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v);</span><br><span class="line">    <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">int</span> val, tag;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">tag</span>(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">const</span> <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (delta == <span class="number">-1</span>) <span class="keyword">return</span>;</span><br><span class="line">        val = delta == <span class="number">1</span> ? r - l + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        tag = delta == <span class="number">1</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag != <span class="number">-1</span>) &#123;</span><br><span class="line">            lc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            rc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            tag = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="built_in">cover</span>(delta);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">pushDown</span>();</span><br><span class="line">            lc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            rc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            val = lc-&gt;val + rc-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="built_in">build</span>(l, mid), <span class="built_in">build</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Node *u, Node *v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        segment-&gt;<span class="built_in">update</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn, w);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    segment-&gt;<span class="built_in">update</span>(u-&gt;dfn, v-&gt;dfn, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;p);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[p], &amp;nodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">split</span>(&amp;nodes[<span class="number">0</span>]);</span><br><span class="line">    segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;q);</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="built_in">sizeof</span>(<span class="string">&quot;uninstall&quot;</span>)];</span><br><span class="line">        <span class="type">int</span> x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>, op, &amp;x);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> bef = segment-&gt;val;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;i&#x27;</span>) &#123;</span><br><span class="line">            <span class="built_in">update</span>(&amp;nodes[<span class="number">0</span>], &amp;nodes[x], <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, segment-&gt;val - bef);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op[<span class="number">0</span>] == <span class="string">&#x27;u&#x27;</span>) &#123;</span><br><span class="line">            segment-&gt;<span class="built_in">update</span>(nodes[x].dfn, nodes[x].dfn + nodes[x].size - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, bef - segment-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>树</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2014」随机数生成器 - 贪心</title>
    <url>/noi2014-random/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2354">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2248">LOJ 链接</a></p>
<p>小 H 最近在研究随机算法。随机算法往往需要通过调用随机数生成函数（例如
Pascal 中的 <span class="math inline">\(\texttt{random}\)</span> 和
C/C++ 中的 <span
class="math inline">\(\texttt{rand}\)</span>）来获得随机性。事实上，随机数生成函数也不是真正的「随机」，其一般都是按某个算法计算得来的。</p>
<p>比如，下面这个二次多项式递推算法就是一个常用算法：</p>
<p>算法选定非负整数 <span
class="math inline">\(x_0,a,b,c,d\)</span>，并采用如下公式递推进行计算。
<span class="math display">\[\forall i \geq 1,\
x_i=(ax_{i-1}^2+bx_{i-1}+c)\bmod d\]</span>
这样可以得到一个任意长度的非负整数 <strong>数列</strong> <span
class="math inline">\(\{x_i\}_{i \geq
1}\)</span>。一般说来，我们认为这个 <strong>数列</strong> 是随机的。</p>
<p>利用随机序列 <span class="math inline">\(\{x_i\}_{i \geq
1}\)</span>，我们还可以采用如下算法产生一个从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(K\)</span> 的 <strong>随机排列</strong> <span
class="math inline">\(\{T_i\}^K_{i \geq 1}\)</span>：</p>
<ol type="1">
<li>初始设 <span class="math inline">\(T\)</span> 为 <span
class="math inline">\(1 \sim K\)</span> 的递增序列；</li>
<li>对 <span class="math inline">\(T\)</span> 进行 <span
class="math inline">\(K\)</span> 次交换，第 <span
class="math inline">\(i\)</span> 次交换，交换 <span
class="math inline">\(T_i\)</span> 和 <span
class="math inline">\(T_{(x_i \bmod i)+1}\)</span> 的值。</li>
</ol>
<p>此外，小 H 在这 <span class="math inline">\(K\)</span>
次交换的基础上，又 <strong>额外</strong> 进行了 <span
class="math inline">\(Q\)</span> 次交换工作，对于第 <span
class="math inline">\(i\)</span> 次交换，小 H 会选定两个额外下标 <span
class="math inline">\(u_i\)</span> 和 <span
class="math inline">\(v_i\)</span>，并交换 <span
class="math inline">\(T_{u_i}\)</span> 和 <span
class="math inline">\(T_{v_i}\)</span> 的值。</p>
<p>为了检验这个随机生成算法的实用性，小 H 设计了如下问题：</p>
<p>小 H 有一个 <span class="math inline">\(N\)</span> 行 <span
class="math inline">\(M\)</span> 列的棋盘，她首先按照上述过程，通过
<span class="math inline">\(N\times M+Q\)</span> 次交换操作，生成一个
<span class="math inline">\(1 \sim N \times M\)</span> 的随机排列 <span
class="math inline">\(\{T_i\}^{N \times M}_{i \geq 1}\)</span>，然后将这
<span class="math inline">\(N \times M\)</span>
个数逐行逐列依次填入这个棋盘：也就是第 <span
class="math inline">\(i\)</span> 行第 <span
class="math inline">\(j\)</span> 列的格子上所填入的数应为 <span
class="math inline">\(T_{(i-1)M+j}\)</span>。</p>
<p>接着小 H
希望从棋盘的左上角，也就是第一行第一列的格子出发，<strong>每次向右走或向下走</strong>，在不走出棋盘的前提下，走到棋盘的右下角，也就是第
<span class="math inline">\(N\)</span> 行第 <span
class="math inline">\(M\)</span> 列的格子。</p>
<p>小 H 把所经过格子上的数字都记录了下来，并
<strong>从小到大排序</strong>，这样，对于任何一条合法的移动路径，小 H
都可以得到一个长度为 <span class="math inline">\(N+M-1\)</span>
的升序序列，我们称之为 <strong>路径序列</strong>。</p>
<p>小 H 想知道，她可能得到的 <strong>字典序最小</strong> 的
<strong>路径序列</strong> 应该是怎样的呢？</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题诈骗，实际上可直接模拟出 <span class="math inline">\(T\)</span>
序列，为使字典序最小，我们可以从 <span class="math inline">\(1\)</span>
到 <span class="math inline">\(n + m - 1\)</span>
的点权顺序遍历点，看目前遍历到的点是否可以加入到路径中。通过分析题目，我们可以很容易地得出对于每个被选用的点
<span class="math inline">\((x, y)\)</span>，则坐标位于 <span
class="math inline">\((x&#39; &lt; x, y&#39; &gt; y)\)</span> 与 <span
class="math inline">\((x&#39; &gt; x, y&#39; &lt; y)\)</span>
的点无法被选。于是我们可以记录每一行可选的坐标区间，然后每次更新答案的同时更新坐标区间即可。由于答案只有
<span class="math inline">\(n\)</span> 个数，时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>本题略卡空间，每个点的坐标直接在线计算即可卡过。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x0, a, b, c, d;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld %lld %lld %lld %lld&quot;</span>, &amp;x0, &amp;a, &amp;b, &amp;c, &amp;d);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">t</span><span class="params">(n * m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = x0;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) &#123;</span><br><span class="line">        t[i] = i;</span><br><span class="line">        x = (a * x % d * x % d + b * x % d + c) % d;</span><br><span class="line">        std::<span class="built_in">swap</span>(t[i], t[x % i + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        std::<span class="built_in">swap</span>(t[u], t[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(n * m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) pos[t[i]] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> getX = [m](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="built_in">return</span> (a - <span class="number">1</span>) / m + <span class="number">1</span>; &#125;;</span><br><span class="line">    <span class="keyword">auto</span> getY = [m](<span class="type">int</span> a) -&gt; <span class="type">int</span> &#123; <span class="keyword">return</span> a % m ? a % m : m; &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">l</span><span class="params">(n + <span class="number">1</span>, <span class="number">1</span>)</span>, <span class="title">r</span><span class="params">(n + <span class="number">1</span>, m)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n * m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getY</span>(pos[i]) &gt;= l[<span class="built_in">getX</span>(pos[i])] &amp;&amp; <span class="built_in">getY</span>(pos[i]) &lt;= r[<span class="built_in">getX</span>(pos[i])]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; <span class="built_in">getX</span>(pos[i]); j++) r[j] = std::<span class="built_in">min</span>(r[j], <span class="built_in">getY</span>(pos[i]));</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="built_in">getX</span>(pos[i]) + <span class="number">1</span>; j &lt;= n; j++) l[j] = std::<span class="built_in">max</span>(l[j], <span class="built_in">getY</span>(pos[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>NOI</tag>
        <tag>2014</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2012」同余方程 - 拓展欧几里得定理</title>
    <url>/noip2012-mod/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1082">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2605">LOJ 链接</a></p>
<p>求关于 <span class="math inline">\(x\)</span> 的同余方程 <span
class="math inline">\(ax \equiv 1 \pmod {b}\)</span>
的最小正整数解。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很简单的拓展欧几里得板子题，我们可以由同余方程得出下列等式</p>
<p><span class="math display">\[
ax + by = \gcd(a, b) \quad a, b \in \mathbb{Z}
\]</span></p>
<p>利用拓展欧几里得定理求出 <span class="math inline">\(x\)</span>
即可。对于本题 <span class="math inline">\(\gcd(a, b) \neq 1\)</span>
的情况，只需在等式左右除以一个 <span class="math inline">\(\gcd(a,
b)\)</span>，最后结果乘上 <span class="math inline">\(\gcd(a,
b)\)</span> 即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> &amp;x, <span class="type">int</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">int</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    std::cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="built_in">exgcd</span>(a / <span class="built_in">gcd</span>(a, b), b / <span class="built_in">gcd</span>(a, b), x, y);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; (x % b + b) % <span class="function">b * <span class="title">gcd</span><span class="params">(a, b)</span> &lt;&lt; std::endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>数论</tag>
        <tag>2012</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>NOI Online 2022 行记</title>
    <url>/noio2022/</url>
    <content><![CDATA[<p>纪念一下这个 <del>爆炸</del> 的考试</p>
<h1 id="day-0">Day 0</h1>
<p>晚上考完数学考试就到机房刷题。写了几道状压
DP。没过多久就下课了。然后回寝睡觉。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起来后看了一下 DP 题，感觉没啥做的，就看了会儿 B 站
<del>然后发现鸽子 Alan Becker 居然更新了</del>。</p>
<p>没过多久就开始考试，提前开网页，题目加载出来后把题面扔在了我们学校的
OI 群里。</p>
<span id="more"></span>
<p>首先看了一下 T1
丹钓战，<del>谐音梗扣钱</del>。考场上想不出来正解，就胡乱写了暴力。然后再暴力的基础上优化了一下，预处理了可使
<span class="math inline">\((a_i, b_i)\)</span>
成为成功的二元组的最近的下标，复杂度优化到了 <span
class="math inline">\(O(n^2)\)</span>。</p>
<p>然后看了一下 T3，感觉考得是多项式之类的题，没学过，就打了一个 <span
class="math inline">\(O(n^3)\)</span> 的暴力走人了。</p>
<p>最后看了 T2，想着用图论搞，就建了一个无向图，写了一个用 bitset 优化的
Floyd 传递闭包，最后用 bitset
检测集合是否互相包含，不包含就输出答案。复杂度大概是 <span
class="math inline">\(O(\frac{n^3}{w})\)</span>。</p>
<h1 id="day-1.5">Day 1.5</h1>
<p>下午考入门组，题目简单一点。考试前不想刷题，就看了会儿群。没过多久就开始考试了。</p>
<p>T1 是水题，很快就切掉了。</p>
<p>T2 想了一下，一道比较有意思的数论题，用 <span
class="math inline">\(\gcd\)</span>
乱搞一下就可以了。有点怕中间程序爆精度，就开了
<code>__int128_t</code>。</p>
<p>T3 感觉是 Trie 或者是 AC
自动机，没学过就没管了。<del>没想到是跟这些没啥关系的 DP 题</del></p>
<p>后来看了洛谷，真的没想到这次的入门组难度评级是红蓝蓝。。。</p>
<h1 id="day">Day ???</h1>
<p>分数线出来了。提高组 100 分，入门组 140 分。</p>
<p>我的成绩提高组 70，入门组 200。。。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>2022</tag>
        <tag>NOI Online</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI Online 2022 入门组」数学游戏 - 数论</title>
    <url>/noio2022-math/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8255">洛谷链接</a></p>
<p>Kri 喜欢玩数字游戏。</p>
<p>一天，他在草稿纸上写下了 <span class="math inline">\(t\)</span>
对正整数 <span class="math inline">\((x,
y)\)</span>，并对于每一对正整数计算出了 <span class="math inline">\(z =
xy \gcd(x, y)\)</span>。</p>
<p>可是调皮的 Zay 找到了 Kri 的草稿纸，并把每一组的 <span
class="math inline">\(y\)</span> 都擦除了，还可能改动了一些 <span
class="math inline">\(z\)</span>。</p>
<p>现在 Kri 想请你帮忙还原每一组的 <span
class="math inline">\(y\)</span>，具体地，对于每一组中的 <span
class="math inline">\(x\)</span> 和 <span
class="math inline">\(z\)</span>，你需要输出最小的正整数 <span
class="math inline">\(z\)</span>，使得 <span class="math inline">\(z =
xy \gcd(x, y)\)</span>。如果这样的 <span
class="math inline">\(y\)</span> 不存在，也就是 Zay 一定改动了 <span
class="math inline">\(z\)</span>，那么请输出 <span
class="math inline">\(-1\)</span>。</p>
<p>数据范围：<span class="math inline">\(1 \le t \le 5 \times
{10}^5\)</span>，<span class="math inline">\(1 \le x \le
{10}^9\)</span>，<span class="math inline">\(1 \le z &lt;
2^{63}\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很明显这是一道数论题。</p>
<p>我们可以设 <span class="math inline">\(x = m \gcd(x,
y)\)</span>，<span class="math inline">\(y = n \gcd(x, y)\)</span>，显然
<span class="math inline">\(\gcd(m, n) = 1\)</span>。对于 <span
class="math inline">\(z = xy \gcd(x, y)\)</span>，我们可以变形为 <span
class="math inline">\(\frac{z}{x} = y \gcd(x, y)\)</span>。又显然 <span
class="math inline">\(\gcd(x, y) = \frac{x}{m}\)</span>，<span
class="math inline">\(y = \frac{nx}{m}\)</span>，故该式可变形为 <span
class="math inline">\(\frac{z}{x} = \frac{nx^2}{m^2}\)</span>，即 <span
class="math inline">\(\frac{z}{x^3} = \frac{n}{m^2}\)</span>。又由于
<span class="math inline">\(\gcd(m, n) = 1\)</span>，故两者无相同非
<span class="math inline">\(1\)</span> 因子，故 <span
class="math inline">\(\gcd(m^2, n) = 1\)</span>。故我们可以求出 <span
class="math inline">\(\gcd(z, x^3)\)</span>，从而求出 <span
class="math inline">\(m = \sqrt{\frac{x^3}{\gcd(z, x^3)}}\)</span> 和
<span class="math inline">\(n = \frac{z}{\gcd(z,
x^3)}\)</span>，进而得出答案。</p>
<p>对于无解，由于 <span class="math inline">\(z = xy \gcd(x,
y)\)</span>，且 <span class="math inline">\(y\)</span>, <span
class="math inline">\(\gcd(x, y)\)</span>, <span
class="math inline">\(m\)</span> 均为整数，故我们仅需判断 <span
class="math inline">\(m = \sqrt{\frac{x^3}{\gcd(z, x^3)}}\)</span> 和
<span class="math inline">\(\frac{z}{x}\)</span> 是否为整数即可。</p>
<p>注意一下这里 <span class="math inline">\(x^3\)</span> 可能会超出
<code>long long</code> 的范围，这时我们用 <code>__int128_t</code>
代替一下即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(<span class="type">__int128_t</span> a, <span class="type">__int128_t</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        ll x, z;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lld%lld&quot;</span>, &amp;x, &amp;z);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (z % x != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ll g = <span class="built_in">gcd</span>(z, (<span class="type">__int128_t</span>)x * x * x);</span><br><span class="line">        ll n = z / g;</span><br><span class="line">        ll m = <span class="built_in">sqrt</span>((<span class="type">__int128_t</span>)x * x * x / g);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">sqrt</span>((<span class="type">__int128_t</span>)x * x * x / g) != m) <span class="built_in">printf</span>(<span class="string">&quot;-1\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, n * x / m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>2022</tag>
        <tag>数论</tag>
        <tag>NOI Online</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2014」解方程 - 数论 + Hash</title>
    <url>/noip2014-equation/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2312">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2503">LOJ 链接</a></p>
<p>已知多项式方程：</p>
<p><span
class="math display">\[a_0+a_1x+a_2x^2+\cdots+a_nx^n=0\]</span></p>
<p>求这个方程在 <span class="math inline">\([1,m]\)</span>
内的整数解（<span class="math inline">\(n\)</span> 和 <span
class="math inline">\(m\)</span> 均为正整数）。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题数据范围过大，显然我们无法用正常思路解决。而 <span
class="math inline">\(m\)</span> 的数据范围不大，于是我们可以尝试枚举
<span class="math inline">\(x\)</span> 来得出答案。</p>
<p>通过同余性质我们可以知道，对于一个数 <span
class="math inline">\(p\)</span>，如果 <span
class="math inline">\(\sum_{i = 0}^n{a_ix^i} = 0\)</span>，则 <span
class="math inline">\(\sum_{i = 0}^n{a_ix^i} \equiv 0 \pmod
p\)</span>。于是我们可以用 Hash 的思想解决这道题。</p>
<p>我们可以将 <span class="math inline">\(a_ix^i \bmod p\)</span>
存储累加，然后最后于 0 比较即可。如果担心被卡可以使用多模数
Hash（虽然这道题经过测试只需要 <span
class="math inline">\(998244353\)</span> 这个模数可过）。</p>
<p>这道题可以用秦九昭公式进一步优化，但 whk 数学还没学到那就没写了
QWQ</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = (x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>)) % MOD;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i++) a[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>, p = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            res = (res + (a[j] * p) % MOD) % MOD;</span><br><span class="line">            p = (p * i) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) ans.<span class="built_in">push_back</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, ans.<span class="built_in">size</span>());</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : ans) <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, each);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>Hash</tag>
        <tag>数论</tag>
        <tag>2014</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2015」运输计划 - 二分答案 + 最近公共祖先 + 树上差分</title>
    <url>/noip2015-transport/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2680">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2425">LOJ 链接</a></p>
<p>公元 <span class="math inline">\(2044\)</span>
年，人类进入了宇宙纪元。</p>
<p>L 国有 <span class="math inline">\(n\)</span> 个星球，还有 <span
class="math inline">\(n - 1\)</span>
条双向航道，每条航道建立在两个星球之间，这 <span class="math inline">\(n
- 1\)</span> 条航道连通了 L 国的所有星球。</p>
<p>小 P
掌管一家物流公司，该公司有很多个运输计划，每个运输计划形如：有一艘物流飞船需要从
<span class="math inline">\(u_i\)</span> 号星球沿最快的宇航路径飞行到
<span class="math inline">\(v_i\)</span>
号星球去。显然，飞船驶过一条航道是需要时间的，对于航道 <span
class="math inline">\(j\)</span>，任意飞船驶过它所花费的时间为 <span
class="math inline">\(t_j\)</span>，并且任意两艘飞船之间不会产生任何干扰。</p>
<p>为了鼓励科技创新，L 国国王同意小 P 的物流公司参与 L
国的航道建设，即允许小 P
把某一条航道改造成虫洞，飞船驶过虫洞不消耗时间。</p>
<p>在虫洞的建设完成前小 P 的物流公司就预接了 <span
class="math inline">\(m\)</span> 个运输计划。在虫洞建设完成后，这 <span
class="math inline">\(m\)</span>
个运输计划会同时开始，所有飞船一起出发。当这 <span
class="math inline">\(m\)</span> 个运输计划都完成时，小 P
的物流公司的阶段性工作就完成了。</p>
<p>如果小 P 可以自由选择将哪一条航道改造成虫洞，试求出小 P
的物流公司完成阶段性工作所需要的最短时间是多少?</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题实质上是将一棵树中的一条边的权值设为 <span
class="math inline">\(0\)</span>，使 <span
class="math inline">\(m\)</span>
条最大路径长度最小。显然可以想到二分答案。</p>
<p>我们可以二分最长路径的长度。设最长长度为 <span
class="math inline">\(\text{limit}\)</span>，我们可以得出：对于所有长度大于
<span class="math inline">\(\text{limit}\)</span>
的路径，我们必须删去这些路径的最长公共边。判断删去这条公共边后所有路径长度是否小于
<span
class="math inline">\(\text{limit}\)</span>，这样不停二分出答案即可。</p>
<p>但直接找出公共边的时间复杂度过高，又由于这是一颗树，于是我们可以用
LCA + 树上差分解决。对于一条路径，我们可以在其两端点标记 <span
class="math inline">\(+1\)</span>，在两端点的 LCA 标记 <span
class="math inline">\(-2\)</span>，最后树上求前缀和，边上标记数即代表了这是多少条路径的公共边。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">300000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Edge</span> *in;</span><br><span class="line">    Node *f[LOG_MAXN + <span class="number">1</span>], *p;</span><br><span class="line">    <span class="type">int</span> d, sum, mark;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> w, mark;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">int</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125; *E[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Path</span> &#123;</span><br><span class="line">    Node *u, *v, *p;</span><br><span class="line">    <span class="type">int</span> dist;</span><br><span class="line">&#125; P[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">Node *tasks[MAXN + <span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> maxDist;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t], w));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *v, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;f[<span class="number">0</span>] = v-&gt;p = f;</span><br><span class="line">    v-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            v-&gt;f[i] = v-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        e-&gt;t-&gt;sum += e-&gt;w + e-&gt;s-&gt;sum;</span><br><span class="line">        e-&gt;t-&gt;in = e;</span><br><span class="line">        <span class="built_in">prepare</span>(e-&gt;t, v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">dist</span><span class="params">(Node *u, Node *v, Node *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> u-&gt;sum + v-&gt;sum - <span class="number">2</span> * p-&gt;sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">calcSum</span><span class="params">(Node *v, Node *p = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == p) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">calcSum</span>(e-&gt;t, v);</span><br><span class="line">        v-&gt;mark += e-&gt;t-&gt;mark;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v-&gt;in) v-&gt;in-&gt;mark += v-&gt;mark;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) N[i].mark = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) E[i]-&gt;mark = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (P[i].dist &gt; limit) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            P[i].u-&gt;mark++;</span><br><span class="line">            P[i].v-&gt;mark++;</span><br><span class="line">            P[i].p-&gt;mark -= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">calcSum</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    Edge *maxEdge = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (E[i]-&gt;mark == cnt &amp;&amp; (!maxEdge || E[i]-&gt;w &gt; maxEdge-&gt;w)) &#123;</span><br><span class="line">            maxEdge = E[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> maxEdge &amp;&amp; maxDist - maxEdge-&gt;w &lt;= limit;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    maxDist = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, t;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;t);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prepare</span>(&amp;N[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) E[i] = N[i].in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        P[i].u = &amp;N[u], P[i].v = &amp;N[v];</span><br><span class="line">        P[i].p = <span class="built_in">lca</span>(P[i].u, P[i].v);</span><br><span class="line">        P[i].dist = <span class="built_in">dist</span>(P[i].u, P[i].v, P[i].p);</span><br><span class="line">        maxDist = std::<span class="built_in">max</span>(maxDist, P[i].dist);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = maxDist;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
        <tag>最近公共祖先</tag>
        <tag>倍增</tag>
        <tag>树上差分</tag>
        <tag>NOIP</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOI 2022」众数 - 线段树合并 + 链表</title>
    <url>/noi2022-major/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8496">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3847">LOJ 链接</a></p>
<p><strong>对于一个序列，定义其众数为序列中出现次数严格大于一半的数字。注意该定义与一般的定义有出入，在本题中请以题面中给出的定义为准。</strong></p>
<p>一开始给定 <span class="math inline">\(n\)</span>
个长度不一的正整数序列，编号为 <span class="math inline">\(1 \sim
n\)</span>，初始序列可以为空。这 <span class="math inline">\(n\)</span>
个序列被视为存在，其他编号对应的序列视为不存在。</p>
<p>有 <span class="math inline">\(q\)</span> 次操作，操作有以下类型:</p>
<ul>
<li><span class="math inline">\(1 \ x \ y\)</span>：在 <span
class="math inline">\(x\)</span> 号序列末尾插入数字 <span
class="math inline">\(y\)</span>。保证 <span
class="math inline">\(x\)</span> 号序列存在，且 <span
class="math inline">\(1 \le x, y \le n + q\)</span>。</li>
<li><span class="math inline">\(2 \ x\)</span>：删除 <span
class="math inline">\(x\)</span> 号序列末尾的数字，保证 <span
class="math inline">\(x\)</span> 号序列存在、非空，且 <span
class="math inline">\(1 \le x \le n + q\)</span>。</li>
<li><span class="math inline">\(3 \ m \ x_1 \ x_2 \ x_m\)</span>：将
<span class="math inline">\(x_1, x_2, \ldots, x_m\)</span>
号序列顺次拼接，得到一个新序列，并询问其众数。如果不存在满足上述条件的数，则返回
<span class="math inline">\(-1\)</span>。数据保证对于任意 <span
class="math inline">\(1 \le i \le m\)</span>，<span
class="math inline">\(x_i\)</span> 是一个仍然存在的序列，<span
class="math inline">\(1 \le x_i \le n +
q\)</span>，且拼接得到的序列非空。<strong>注意：不保证 <span
class="math inline">\(\boldsymbol{x_1, \ldots, x_m}\)</span>
互不相同，询问中的合并操作不会对后续操作产生影响。</strong></li>
<li><span class="math inline">\(4 \ x_1 \ x_2 \
x_3\)</span>：新建一个编号为 <span class="math inline">\(x_3\)</span>
的序列，其为 <span class="math inline">\(x_1\)</span> 号序列后顺次添加
<span class="math inline">\(x_2\)</span>
号序列中数字得到的结果，然后删除 <span class="math inline">\(x_1,
x_2\)</span> 对应的序列。此时序列 <span
class="math inline">\(x_3\)</span> 视为存在，而序列 <span
class="math inline">\(x_1, x_2\)</span>
被视为不存在，在后续操作中也不会被再次使用。保证 <span
class="math inline">\(1 \le x_1, x_2, x_3 \le n + q\)</span>、<span
class="math inline">\(x_1 \ne x_2\)</span>、序列 <span
class="math inline">\(x_1, x_2\)</span>
在操作前存在、且在操作前没有序列使用过编号 <span
class="math inline">\(x_3\)</span>。</li>
</ul>
<p>假定 <span class="math inline">\(C_l = \sum l_i\)</span>
代表输入序列长度之和，<span class="math inline">\(C_m = \sum m\)</span>
代表所有操作 <span class="math inline">\(3\)</span>
需要拼接的序列个数之和；对于所有测试数据，保证 <span
class="math inline">\(1 \le n, q, C_m, C_l \le 5 \times
{10}^5\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题显然是一道数据结构题。对于序列的插入、删除和拼接，我们可以用
<code>std::list</code>
链表完成。对于每个序列的众数，我们可以对每个序列都开一颗线段树，统计序列众数。由于不确定序列长度，我们可以使用权值线段树
+
动态开点解决。权值线段树维护区间最大值及最大值的下标，即众数的出现次数和众数的下标。对于序列合并操作可用线段树合并解决。</p>
<p>接下来我们需要解决查询操作。对于查询操作我们直接新建线段树然后用线段树合并会
TLE，实际得分 80pts，于是我们需要寻找更优的方法。</p>
<p>对于寻找本题中的众数（我们将其定义为绝对众数），我们可以用
<strong>摩尔投票</strong>
解决。对于一个拥有绝对众数的序列，我们不停地消去序列中两个不同的数，最后剩下的一个数或多个相同的数即为这个序列的绝对众数（而对于不一定有绝对众数的序列，最终答案需带回检验），这种方法叫做摩尔投票。同时我们可以发现，对于多个序列总共的绝对众数，<strong>摩尔投票具有结合律</strong>，即我们将每个序列进行摩尔投票剩下来的数一起再进行一次摩尔投票，得到的结果即为所有序列总共的绝对众数。</p>
<p>接下来我们就可以用摩尔投票解决查询操作：我们先新建一个空序列 <span
class="math inline">\(\text{res}\)</span>，然后遍历每个询问的序列（每个序列的绝对众数可用先线段树查询众数，然后将二倍众数出现次数与序列长度比较即可得出）：</p>
<ul>
<li>若没有绝对众数，则这个序列对答案没有贡献，跳过；</li>
<li>若有绝对众数，则通过众数出现次数及序列长度算出这个序列进行摩尔投票的结果
<span class="math inline">\(\text{now}\)</span>，然后将 <span
class="math inline">\(\text{res}\)</span> 和 <span
class="math inline">\(\text{now}\)</span> 进行摩尔投票，结果存储于 <span
class="math inline">\(\text{res}\)</span>。</li>
</ul>
<p>这样我们就得出了这些序列的可能的绝对众数 <span
class="math inline">\(p\)</span>。接下来再遍历一遍询问的序列，用线段树统计
<span class="math inline">\(p\)</span> 的出现次数，最后再将二倍 <span
class="math inline">\(p\)</span>
的出现次数与这些序列的总长度比较即可得出 <span
class="math inline">\(p\)</span> 是否为这些序列总共的绝对众数。</p>
<p>时间复杂度为 <span class="math inline">\(O(n \log n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>)) &#123;&#125;</span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc, std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; val) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(val) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>, std::<span class="built_in">make_pair</span>(<span class="number">0</span>, l));</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="keyword">this</span>-&gt;l &amp;&amp; pos == <span class="keyword">this</span>-&gt;r) val.first += delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lc) lc = <span class="built_in">build</span>(l, mid);</span><br><span class="line">                lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">                rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125;</span><br><span class="line">            std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (lc) res = std::<span class="built_in">max</span>(res, lc-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (rc) res = std::<span class="built_in">max</span>(res, rc-&gt;val);</span><br><span class="line">            val = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;l == <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (lc) res = std::<span class="built_in">max</span>(res, lc-&gt;<span class="built_in">query</span>(pos));</span><br><span class="line">            <span class="keyword">if</span> (rc) res = std::<span class="built_in">max</span>(res, rc-&gt;<span class="built_in">query</span>(pos));</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">merge</span><span class="params">(SegT *u, SegT *v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!u) <span class="keyword">return</span> v;</span><br><span class="line">        <span class="keyword">if</span> (!v) <span class="keyword">return</span> u;</span><br><span class="line">        SegT *w = <span class="built_in">build</span>(u-&gt;l, u-&gt;r);</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;l == w-&gt;r) &#123;</span><br><span class="line">            w-&gt;val.first = u-&gt;val.first + v-&gt;val.first;</span><br><span class="line">            <span class="keyword">return</span> w;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        w-&gt;lc = <span class="built_in">merge</span>(u-&gt;lc, v-&gt;lc);</span><br><span class="line">        w-&gt;rc = <span class="built_in">merge</span>(u-&gt;rc, v-&gt;rc);</span><br><span class="line">        std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;lc) res = std::<span class="built_in">max</span>(res, w-&gt;lc-&gt;val);</span><br><span class="line">        <span class="keyword">if</span> (w-&gt;rc) res = std::<span class="built_in">max</span>(res, w-&gt;rc-&gt;val);</span><br><span class="line">        w-&gt;val = res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> l[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line">std::list&lt;<span class="type">int</span>&gt; a[<span class="number">2</span> * MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, w = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (ch &lt; <span class="string">&#x27;0&#x27;</span> || ch &gt; <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ch == <span class="string">&#x27;-&#x27;</span>) w = <span class="number">-1</span>;</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) &#123;</span><br><span class="line">        x = x * <span class="number">10</span> + (ch - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        ch = <span class="built_in">getchar</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x * w;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(), q = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        segment[i] = SegT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">2</span> * MAXN);</span><br><span class="line">        l[i] = <span class="built_in">read</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= l[i]; j++) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            x = <span class="built_in">read</span>();</span><br><span class="line">            segment[i]-&gt;<span class="built_in">update</span>(x, <span class="number">1</span>);</span><br><span class="line">            a[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> cmd;</span><br><span class="line">        cmd = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cmd == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            x = <span class="built_in">read</span>(), y = <span class="built_in">read</span>();</span><br><span class="line">            segment[x]-&gt;<span class="built_in">update</span>(y, <span class="number">1</span>);</span><br><span class="line">            a[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">            l[x]++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            x = <span class="built_in">read</span>();</span><br><span class="line">            segment[x]-&gt;<span class="built_in">update</span>(a[x].<span class="built_in">back</span>(), <span class="number">-1</span>);</span><br><span class="line">            a[x].<span class="built_in">pop_back</span>();</span><br><span class="line">            l[x]--;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> m;</span><br><span class="line">            <span class="type">static</span> <span class="type">int</span> x[MAXN + <span class="number">1</span>];</span><br><span class="line">            m = <span class="built_in">read</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) x[i] = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">2</span> * segment[x[i]]-&gt;val.first &lt;= l[x[i]]) <span class="keyword">continue</span>;</span><br><span class="line">                std::pair&lt;<span class="type">long</span> <span class="type">long</span>, <span class="type">int</span>&gt; now = std::<span class="built_in">make_pair</span>(segment[x[i]]-&gt;val.first - (l[x[i]] - segment[x[i]]-&gt;val.first), segment[x[i]]-&gt;val.second);</span><br><span class="line">                <span class="keyword">if</span> (now.second == res.second) res.first += now.first;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (now.first == res.first) res = std::<span class="built_in">make_pair</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (now.first &gt; res.first) res = std::<span class="built_in">make_pair</span>(now.first - res.first, now.second);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (now.first &lt; res.first) res.first -= now.first;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (res.first == <span class="number">0</span>) <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> cnt = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                    cnt += segment[x[i]]-&gt;<span class="built_in">query</span>(res.second).first;</span><br><span class="line">                    len += l[x[i]];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, <span class="number">2</span> * cnt &gt; len ? res.second : <span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> x1, x2, x3;</span><br><span class="line">            x1 = <span class="built_in">read</span>(), x2 = <span class="built_in">read</span>(), x3 = <span class="built_in">read</span>();</span><br><span class="line"></span><br><span class="line">            segment[x3] = SegT::<span class="built_in">build</span>(<span class="number">1</span>, <span class="number">2</span> * MAXN);</span><br><span class="line">            segment[x3] = SegT::<span class="built_in">merge</span>(segment[x3], segment[x1]);</span><br><span class="line">            segment[x3] = SegT::<span class="built_in">merge</span>(segment[x3], segment[x2]);</span><br><span class="line">            a[x3].<span class="built_in">splice</span>(a[x3].<span class="built_in">end</span>(), a[x1]);</span><br><span class="line">            a[x3].<span class="built_in">splice</span>(a[x3].<span class="built_in">end</span>(), a[x2]);</span><br><span class="line">            l[x3] = l[x1] + l[x2];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>2022</tag>
        <tag>线段树</tag>
        <tag>权值线段树</tag>
        <tag>线段树合并</tag>
        <tag>NOI</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2017」时间复杂度 - 模拟</title>
    <url>/noip2017-complexity/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3952">洛谷链接</a></p>
<p>本题定义了一个新语言名为 A++，语言的循环定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">F i x y</span><br><span class="line">    循环体</span><br><span class="line">E</span><br></pre></td></tr></table></figure>
<p>本循环相当于</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= y; i++)</span><br></pre></td></tr></table></figure>
<p>输入一个程序和时间复杂度，判断时间复杂度是否和程序相符。 其中满足
x，y 必为常数或 n，n 远大于 x，y。</p>
<p>具体信息可详见洛谷，链接见上</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>显然本题为一道模拟题。</p>
<h2 id="模型建立">模型建立</h2>
<p>解题思路为通过 A++ 循环分析该代码的时间复杂度。 时间复杂度可通过存储
<span class="math inline">\(O(n^k)\)</span> 的指数达到目的。 通过新建
<code>depth</code> 变量存储有效增加代码时间复杂度的个数，使用
<code>maxn</code> 变量存储 <code>depth</code> 的最大值即可记录该 A++
代码的时间复杂度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cin &gt;&gt; l &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp[<span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) o = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    o = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">4</span>; tmp[each] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tmp[each] &lt;= <span class="string">&#x27;9&#x27;</span>; each++) &#123;</span><br><span class="line">        o = o * <span class="number">10</span> + tmp[each] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本题由于有嵌套循环的可能，所以可以写一个栈来模拟。 又由于 A++
中变量不可重名，故有遍历栈的需求。 故可以写一个手工栈，栈中存有 A++
变量名。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> top = <span class="number">0</span>;</span><br><span class="line">std::string stack[<span class="number">100</span>];</span><br></pre></td></tr></table></figure>
<p>此时输入 F 则入栈，输入 E 则出栈，注意当 F 与 E
没有一一对应时需要处理为 ERR。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">std::cin &gt;&gt; tmp;</span><br><span class="line"><span class="keyword">if</span> (tmp == <span class="string">&quot;F&quot;</span>) &#123;</span><br><span class="line">    std::cin &gt;&gt; stack[top] &gt;&gt; x &gt;&gt; y;</span><br><span class="line">    <span class="comment">// 处理后续</span></span><br><span class="line">    top++;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// A++语法错误，输出ERR及处理后续</span></span><br><span class="line">    &#125; <span class="keyword">else</span> top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环处理">循环处理</h2>
<p>首先处理 A++ 循环中申明的变量，若变量重复，则处理为 ERR。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; top; j++)</span><br><span class="line">    <span class="keyword">if</span>(stack[j] == stack[top])</span><br><span class="line">        err = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>循环可分 4 种情况讨论：</p>
<ol type="1">
<li>x，y 均为 n；</li>
<li>x 为 n，y 为常数；</li>
<li>x 为常数，y 为 n；</li>
<li>x，y 均为常数。</li>
</ol>
<p>第一种情况显然时间复杂度为 <span
class="math inline">\(O(1)\)</span>。 第二种情况由于 n 远大于
x，故这个循环和循环内部的任何语句都不会被执行，此时需要新建变量
<code>unknown</code> 来记录该层层数，在这个层数之上则不记录时间复杂度。
第三种情况由于 n 远大于 y，时间复杂度为 <span
class="math inline">\(O(n)\)</span>，所以需要 <code>depth++</code>。
第四种情况则需要分两种情况讨论。</p>
<ol type="1">
<li><span class="math inline">\(x \leq y\)</span></li>
<li><span class="math inline">\(x &gt; y\)</span>
其中第一种情况显然时间复杂度为 <span
class="math inline">\(O(1)\)</span>。
第二种情况得循环及其内部也不会被执行，等同 x 为 n，y 为常数的情况。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) f[top] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">    f[top] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; unshown)</span><br><span class="line">        unshown = top;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (top &lt; unshown) &#123;</span><br><span class="line">        f[top] = <span class="literal">true</span>;</span><br><span class="line">        depth++;</span><br><span class="line">    &#125; <span class="keyword">else</span> f[top] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">    nx = ny = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x.<span class="built_in">length</span>(); j++) nx = nx * <span class="number">10</span> + x[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; y.<span class="built_in">length</span>(); j++) ny = ny * <span class="number">10</span> + y[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (nx &gt; ny &amp;&amp; top &lt; unshown) unshown = top;</span><br><span class="line">    f[top] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">top++;</span><br><span class="line"><span class="keyword">if</span> (depth &gt; maxn) maxn = depth;</span><br></pre></td></tr></table></figure>
<p>最后在收到 E 的时候结束循环，弹出栈。 若栈已空，则说明 F 与 E
不匹配，处理为 ERR。 此时则需检测这层循环中 <code>depth</code>
有无变化，若有变化则 <code>depth--</code>
表明这层循环已退出时间复杂度的统计，以便处理其他循环。 同时需注意处理
<code>unknown</code> 变量。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (top == <span class="number">0</span>) err = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (top - <span class="number">1</span> == unshown) unshown = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (f[top - <span class="number">1</span>]) depth--;</span><br><span class="line">    top--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t, l, o, nx, ny, unshown;</span><br><span class="line">    std::string tmp, stack[<span class="number">100</span>], x, y;</span><br><span class="line">    <span class="type">int</span> depth, top, maxn;</span><br><span class="line">    <span class="type">bool</span> err, f[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        top = depth = maxn = <span class="number">0</span>;</span><br><span class="line">        unshown = <span class="number">100</span>;</span><br><span class="line">        err = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        std::cin &gt;&gt; l &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tmp[<span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span>) o = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            o = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">4</span>; tmp[each] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; tmp[each] &lt;= <span class="string">&#x27;9&#x27;</span>; each++) &#123;</span><br><span class="line">                o = o * <span class="number">10</span> + tmp[each] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">0</span>; each &lt; l; each++) &#123;</span><br><span class="line">            std::cin &gt;&gt; tmp;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tmp == <span class="string">&quot;F&quot;</span>) &#123;</span><br><span class="line">                std::cin &gt;&gt; stack[top] &gt;&gt; x &gt;&gt; y;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; top; j++)</span><br><span class="line">                    <span class="keyword">if</span> (stack[j] == stack[top])</span><br><span class="line">                        err = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) f[top] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x == <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">                    f[top] = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">if</span> (top &lt; unshown) unshown = top;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y == <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top &lt; unshown) &#123;</span><br><span class="line">                        f[top] = <span class="literal">true</span>;</span><br><span class="line">                        depth++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> f[top] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (x != <span class="string">&quot;n&quot;</span> &amp;&amp; y != <span class="string">&quot;n&quot;</span>) &#123;</span><br><span class="line">                    nx = ny = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; x.<span class="built_in">length</span>(); j++) nx = nx * <span class="number">10</span> + x[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; y.<span class="built_in">length</span>(); j++) ny = ny * <span class="number">10</span> + y[j] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt; ny &amp;&amp; top &lt; unshown) unshown = top;</span><br><span class="line"></span><br><span class="line">                    f[top] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                top++;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (depth &gt; maxn) maxn = depth;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (top == <span class="number">0</span>) err = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (top - <span class="number">1</span> == unshown)</span><br><span class="line">                        unshown = <span class="number">100</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (f[top - <span class="number">1</span>])</span><br><span class="line">                        depth--;</span><br><span class="line"></span><br><span class="line">                    top--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (err || top != <span class="number">0</span>) std::cout &lt;&lt; <span class="string">&quot;ERR&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (maxn == o) std::cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        t--;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>模拟</tag>
        <tag>NOIP</tag>
        <tag>栈</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2017」列队 - 线段树</title>
    <url>/noip2017-phalanx/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3960">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2319">LOJ 链接</a></p>
<p><code>Sylvia</code> 是一个热爱学习的女孩子。</p>
<p>前段时间，<code>Sylvia</code>
参加了学校的军训。众所周知，军训的时候需要站方阵。</p>
<p>Sylvia 所在的方阵中有 <span class="math inline">\(n \times m\)</span>
名学生，方阵的行数为 <span class="math inline">\(n\)</span>，列数为
<span class="math inline">\(m\)</span>。</p>
<p>为了便于管理，教官在训练开始时，按照从前到后，从左到右的顺序给方阵中
的学生从 <span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n \times m\)</span> 编上了号码。即：初始时，第
<span class="math inline">\(i\)</span> 行第 <span
class="math inline">\(j\)</span> 列 的学生的编号是 <span
class="math inline">\((i-1)\times m + j\)</span>。</p>
<p>然而在练习方阵的时候，经常会有学生因为各种各样的事情需要离队。在一天
中，一共发生了 <span class="math inline">\(q\)</span>
件这样的离队事件。每一次离队事件可以用数对 <span
class="math inline">\((x,y) (1 \le x \le n, 1 \le y \le m)\)</span>
描述，表示第 <span class="math inline">\(x\)</span> 行第 <span
class="math inline">\(y\)</span> 列的学生离队。</p>
<p>在有学生离队后，队伍中出现了一个空位。为了队伍的整齐，教官会依次下达
这样的两条指令：</p>
<ol type="1">
<li><p>向左看齐。这时第一列保持不动，所有学生向左填补空缺。不难发现在这条
指令之后，空位在第 <span class="math inline">\(x\)</span> 行第 <span
class="math inline">\(m\)</span> 列。</p></li>
<li><p>向前看齐。这时第一行保持不动，所有学生向前填补空缺。不难发现在这条
指令之后，空位在第 <span class="math inline">\(n\)</span> 行第 <span
class="math inline">\(m\)</span> 列。</p></li>
</ol>
<p>教官规定不能有两个或更多学生同时离队。即在前一个离队的学生归队之后，
下一个学生才能离队。因此在每一个离队的学生要归队时，队伍中有且仅有第
<span class="math inline">\(n\)</span> 行 第 <span
class="math inline">\(m\)</span>
列一个空位，这时这个学生会自然地填补到这个位置。</p>
<p>因为站方阵真的很无聊，所以 <code>Sylvia</code>
想要计算每一次离队事件中，离队的同学 的编号是多少。</p>
<p>注意：每一个同学的编号不会随着离队事件的发生而改变，在发生离队事件后
方阵中同学的编号可能是乱序的。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题直接模拟显然超时，通过分析题目，我们可以发现修改都与 <span
class="math inline">\(m\)</span>
列、当前点和最后一个点有关，于是我们可以建 <span class="math inline">\(n
+ 1\)</span> 颗线段树来存储状态。其中前 <span
class="math inline">\(n\)</span> 颗存储 <span
class="math inline">\(n\)</span> 行目前的状态，用第 <span
class="math inline">\(n + 1\)</span> 棵存储第 <span
class="math inline">\(m\)</span>
行的状态。每个线段树只需记录该点是否存在即可。删除点在线段树对应点打上标记，添加点则增加每行计数即可，这样我们就可以知道每行有多少个点，以及可以查询每行第几个点在线段树中的坐标。而对于每行线段树前
<span class="math inline">\(m - 1\)</span>
个点，我们显然可以直接推出；而对于之后的新添加点，我们可以在每一行建一个
<code>std::vector</code> 来存储新建节点的编号。由于询问次数小于 <span
class="math inline">\(3 \times 10^5\)</span>
故该方法可行。最后我们只需要对 <span class="math inline">\(y =
m\)</span> 的情况特判即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">NULL</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; r || pos &lt; l)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == l &amp;&amp; pos == r)</span><br><span class="line">            val += delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= mid) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!lc) lc = <span class="built_in">build</span>(l, mid);</span><br><span class="line">                lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = <span class="built_in">build</span>(mid + <span class="number">1</span>, r);</span><br><span class="line">                rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            &#125;</span><br><span class="line">            val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (lc) val += lc-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (rc) val += rc-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)</span><br><span class="line">            <span class="keyword">return</span> l;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!lc) lc = SegT::<span class="built_in">build</span>(l, (l + r) / <span class="number">2</span>);</span><br><span class="line">            <span class="type">int</span> lSize = (r - l) / <span class="number">2</span> + <span class="number">1</span> + lc-&gt;val;</span><br><span class="line">            <span class="keyword">if</span> (pos &lt;= lSize)</span><br><span class="line">                <span class="keyword">return</span> lc-&gt;<span class="built_in">query</span>(pos);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rc) rc = SegT::<span class="built_in">build</span>((l + r) / <span class="number">2</span> + <span class="number">1</span>, r);</span><br><span class="line">                <span class="keyword">return</span> rc-&gt;<span class="built_in">query</span>(pos - lSize);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *seg[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, q;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;n, &amp;m, &amp;q);</span><br><span class="line">    <span class="type">int</span> max = std::<span class="built_in">max</span>(n, m) + q;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n + <span class="number">1</span>; i++) seg[i] = SegT::<span class="built_in">build</span>(<span class="number">1</span>, max);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; tail[MAXN + <span class="number">2</span>];</span><br><span class="line">    <span class="keyword">while</span> (q--) &#123;</span><br><span class="line">        <span class="type">int</span> x, y;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;x, &amp;y);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>, val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (y != m) &#123;</span><br><span class="line">            <span class="type">int</span> pos = seg[x]-&gt;<span class="built_in">query</span>(y);</span><br><span class="line">            seg[x]-&gt;<span class="built_in">update</span>(pos, <span class="number">-1</span>);</span><br><span class="line">            res = pos &lt; m ? (<span class="number">1ll</span> * (x - <span class="number">1</span>) * m + pos) : (tail[x][pos - m]);</span><br><span class="line">            val = res;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> pos = seg[n + <span class="number">1</span>]-&gt;<span class="built_in">query</span>(x);</span><br><span class="line">        seg[n + <span class="number">1</span>]-&gt;<span class="built_in">update</span>(pos, <span class="number">-1</span>);</span><br><span class="line">        res = pos &lt;= n ? (<span class="number">1ll</span> * pos * m) : tail[n + <span class="number">1</span>][pos - n - <span class="number">1</span>];</span><br><span class="line">        tail[n + <span class="number">1</span>].<span class="built_in">push_back</span>(val ? val : res);</span><br><span class="line">        <span class="keyword">if</span> (y == m)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, res);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tail[x].<span class="built_in">push_back</span>(res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>NOIP</tag>
        <tag>2017</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2016」愤怒的小鸟 - 状压 DP</title>
    <url>/noip2016-angrybirds/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2831">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2363">LOJ 链接</a></p>
<p>Kiana 最近沉迷于一款神奇的游戏无法自拔。<br />
简单来说，这款游戏是在一个平面上进行的。有一架弹弓位于 <span
class="math inline">\((0, 0)\)</span> 处，每次 Kiana
可以用它向第一象限发射一只小鸟，小鸟们的飞行轨迹均为形如 <span
class="math inline">\(y = ax ^ 2 + bx\)</span> 的曲线，其中 <span
class="math inline">\(a\)</span>，<span class="math inline">\(b\)</span>
是 Kiana 指定的参数，且必须满足 <span class="math inline">\(a &lt;
0\)</span>。当小鸟落回地面（即 <span class="math inline">\(x\)</span>
轴）时，它就会瞬间消失。</p>
<p>在游戏的某个关卡里，平面的第一象限中有 <span
class="math inline">\(n\)</span> 只猪，其中第 <span
class="math inline">\(i\)</span> 只猪所在的坐标为 <span
class="math inline">\((x_i, y_i)\)</span>。如果某只小鸟的飞行轨迹经过了
<span class="math inline">\((x_i, y_i)\)</span>，那么第 <span
class="math inline">\(i\)</span>
只猪就会被消灭掉，同时小鸟将会沿着原先的轨迹继续飞行；如果一只小鸟的飞行轨迹没有经过
<span class="math inline">\((x_i,
y_i)\)</span>，那么这只小鸟飞行的全过程就不会对第 <span
class="math inline">\(i\)</span> 只猪产生任何影响。
例如，若两只猪分别位于 <span class="math inline">\((1, 3)\)</span> 和
<span class="math inline">\((3, 3)\)</span>，Kiana
可以选择发射一只飞行轨迹为 <span class="math inline">\(y = -x ^ 2 +
4x\)</span> 的小鸟，这样两只猪就会被这只小鸟一起消灭。<br />
而这个游戏的目的，就是通过发射小鸟消灭所有的猪。</p>
<p>假设这款游戏一共有 <span class="math inline">\(T\)</span>
个关卡，现在 Kiana
想知道，对于每一个关卡，至少需要发射多少只小鸟才能消灭所有的猪。由于她不会算，所以希望由你告诉她。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq
18\)</span>，<span class="math inline">\(0 \leq m \leq 2\)</span>，<span
class="math inline">\(0 &lt; x_i, y_i &lt; 10\)</span>，<span
class="math inline">\(1 \leq T \leq 30\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很明显是状压
DP。先枚举每两个猪是否构成抛物线，以及抛物线后可达到另外的哪些猪。将抛物线可达到的猪的集合存为
<span class="math inline">\(g_i\)</span>，抛物线个数为 <span
class="math inline">\(\text{sizeG}\)</span>。</p>
<p>接下来我们定义 <span class="math inline">\(f_i\)</span> 为已清除
<span class="math inline">\(i\)</span>
集合的猪所需最少的鸟的数量。显然我们可推出下列状态转移方程：</p>
<p><span class="math display">\[
f_{i \cap g_j} = \min\{f_{i \cap g_j}, f_i + 1\} \quad i \in [1, n], j
\in [1, \text{sizeG}]
\]</span></p>
<p>初始化 <span class="math inline">\(f_i = +\infty\)</span>。答案 <span
class="math inline">\(f_S\)</span>，其中 <span
class="math inline">\(S\)</span> 为全集。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">20</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> EPS = <span class="number">1e-6</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">double</span> x[MAXN], y[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%lf %lf&quot;</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> g[MAXN * MAXN];</span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0</span>, <span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="type">int</span> sizeG = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(x[j] - x[i]) &lt; EPS) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">double</span> a = (x[i] * y[j] - x[j] * y[i]) / (x[i] * x[j] * x[j] - x[i] * x[i] * x[j]);</span><br><span class="line">            <span class="type">double</span> b = (x[i] * x[i] * y[j] - x[j] * x[j] * y[i]) / (x[i] * x[i] * x[j] - x[i] * x[j] * x[j]);</span><br><span class="line">            <span class="keyword">if</span> (a &gt; -EPS) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">fabs</span>(a * x[k] * x[k] + b * x[k] - y[k]) &lt; EPS) &#123;</span><br><span class="line">                    g[sizeG] |= (<span class="number">1</span> &lt;&lt; k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sizeG++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[<span class="number">1</span> &lt;&lt; MAXN];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) f[<span class="number">1</span> &lt;&lt; i] = <span class="number">1</span>;</span><br><span class="line">    f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; sizeG; j++) &#123;</span><br><span class="line">            f[i | g[j]] = std::<span class="built_in">min</span>(f[i | g[j]], f[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            f[i | (<span class="number">1</span> &lt;&lt; j)] = std::<span class="built_in">min</span>(f[i | (<span class="number">1</span> &lt;&lt; j)], f[i] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, f[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>状压 DP</tag>
        <tag>NOIP</tag>
        <tag>2016</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ 3070」Fibonacci - 矩阵乘法</title>
    <url>/poj-3070/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://poj.org/problem?id=3070">POJ 链接</a></p>
<p>给定一个数 <span class="math inline">\(n\)</span>，求斐波那契数列第
<span class="math inline">\(n\)</span> 项的后四位。</p>
<p>数据范围：<span class="math inline">\(1 \leq n \leq 10^9\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们可以使用矩阵来加速地推。</p>
<p>我们知道斐波那契的通项公式为：</p>
<p><span class="math display">\[
a_i = a_{i - 1} + a_{i - 2}
\]</span></p>
<p>故我们可以设矩阵 <span class="math inline">\(F(n)\)</span>：</p>
<p><span class="math display">\[
F(n) =
\begin{bmatrix}
a_n &amp; a_{n + 1}
\end{bmatrix}
\]</span></p>
<p>同时我们可以设：</p>
<p><span class="math display">\[
F(n) = F(n - 1) \times X
\]</span></p>
<p>即为：</p>
<p><span class="math display">\[
\begin{bmatrix}
a_n &amp; a_{n + 1}
\end{bmatrix} =
\begin{bmatrix}
a_{n - 1} &amp; a_n
\end{bmatrix} \times X
\]</span></p>
<p>我们可以推出：</p>
<p><span class="math display">\[
\begin{bmatrix}
a_n &amp; a_{n + 1}
\end{bmatrix} =
\begin{bmatrix}
a_{n - 1} &amp; a_n
\end{bmatrix} \times
\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 1
\end{bmatrix}
\]</span></p>
<p>所以我们最终可以推出下列式子：</p>
<p><span class="math display">\[
F(n) = F(1) \times
\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 1
\end{bmatrix} ^ {n - 1} =
\begin{bmatrix}
1 &amp; 1
\end{bmatrix} \times
\begin{bmatrix}
0 &amp; 1 \\
1 &amp; 1
\end{bmatrix} ^ {n - 1}
\]</span></p>
<p>最终利用快速幂就可以在 <span class="math inline">\(O(\log n)\)</span>
的时间复杂度中求出答案。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> fib[<span class="number">1</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>], x[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    fib[<span class="number">1</span>][<span class="number">1</span>] = fib[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    x[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    x[<span class="number">1</span>][<span class="number">2</span>] = x[<span class="number">2</span>][<span class="number">1</span>] = x[<span class="number">2</span>][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mul</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> ax, <span class="type">int</span> ay, <span class="type">int</span> b[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> bx, <span class="type">int</span> by, <span class="type">int</span> ans[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s1[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>], s2[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(s1, a, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (ax + <span class="number">1</span>) * (ay + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memcpy</span>(s2, b, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (bx + <span class="number">1</span>) * (by + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= ax; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= by; j++) &#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= ay; k++) sum = (sum + s1[i][k] * s2[k][j]) % mod;</span><br><span class="line">            ans[i][j] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pow</span><span class="params">(<span class="type">int</span> a[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> ax, <span class="type">int</span> ay, <span class="type">int</span> p, <span class="type">int</span> ans[][<span class="number">2</span> + <span class="number">1</span>], <span class="type">int</span> mod)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> s1[<span class="number">2</span> + <span class="number">1</span>][<span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memcpy</span>(s1, a, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (<span class="number">2</span> + <span class="number">1</span>) * (<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">memset</span>(ans, <span class="number">0</span>, <span class="built_in">sizeof</span>(<span class="type">int</span>) * (<span class="number">2</span> + <span class="number">1</span>) * (<span class="number">2</span> + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= std::<span class="built_in">min</span>(ax, ay); i++) ans[i][i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (; p; p &gt;&gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p &amp; <span class="number">1</span>) <span class="built_in">mul</span>(ans, <span class="number">2</span>, <span class="number">2</span>, s1, <span class="number">2</span>, <span class="number">2</span>, ans, mod);</span><br><span class="line">        <span class="built_in">mul</span>(s1, <span class="number">2</span>, <span class="number">2</span>, s1, <span class="number">2</span>, <span class="number">2</span>, s1, mod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;2\n&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">init</span>();</span><br><span class="line">        <span class="built_in">pow</span>(x, <span class="number">2</span>, <span class="number">2</span>, n - <span class="number">1</span>, x, <span class="number">10000</span>);</span><br><span class="line">        <span class="built_in">mul</span>(fib, <span class="number">1</span>, <span class="number">2</span>, x, <span class="number">2</span>, <span class="number">2</span>, fib, <span class="number">10000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, fib[<span class="number">1</span>][<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>矩阵乘法</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「NOIP2018」赛道修建 - 二分答案 + 贪心</title>
    <url>/noip2018-track/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P5021">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2952">LOJ 链接</a></p>
<p>C 城将要举办一系列的赛车比赛。在比赛前，需要在城内修建 <span
class="math inline">\(m\)</span> 条赛道。</p>
<p>C 城一共有 <span class="math inline">\(n\)</span>
个路口，这些路口编号为 <span class="math inline">\(1,2, \cdots ,
n\)</span>，有 <span class="math inline">\(n − 1\)</span>
条适合于修建赛道的双向通行的道路，每条道路连接着两个路口。其中，第 <span
class="math inline">\(i\)</span> 条道路连接的两个路口编号为 <span
class="math inline">\(a_i\)</span> 和 <span
class="math inline">\(b_i\)</span>，该道路的长度为 <span
class="math inline">\(l_i\)</span>。借助这 <span class="math inline">\(n
− 1\)</span> 条道路，从任何一个路口出发都能到达其他所有的路口。</p>
<p>一条赛道是一组互不相同的道路 <span class="math inline">\(e_1, e_2,
\cdots , e_k\)</span>，满足可以从某个路口出发，依次经过道路 <span
class="math inline">\(e_1, e_2, \cdots ,
e_k\)</span>（每条道路经过一次，不允许调头）到达另一个路口。一条赛道的长度等于经过的各道路的长度之和。为保证安全，要求每条道路至多被一条赛道经过。</p>
<p>目前赛道修建的方案尚未确定。你的任务是设计一种赛道修建的方案，使得修建的
<span class="math inline">\(m\)</span>
条赛道中长度最小的赛道长度最大（即 <span
class="math inline">\(m\)</span> 条赛道中最短赛道的长度尽可能大）。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题求的是最小赛道的最大值，可二分答案。而难点则在二分答案的判定上。</p>
<p>设二分时赛道长度为 <span
class="math inline">\(\text{limit}\)</span>，我们需要考虑一颗子树上形成的长度满足条件的赛道最多有多少个。对于这个问题，我们可以贪心解决。</p>
<p>设对于 <span class="math inline">\(v\)</span> 为树上一节点，<span
class="math inline">\(u\)</span> 为 <span
class="math inline">\(v\)</span> 的父节点。设以 <span
class="math inline">\(u\)</span>、<span class="math inline">\(v\)</span>
为根的子树分别最多有 <span class="math inline">\(f_u\)</span>、<span
class="math inline">\(f_v\)</span> 个赛道，<span
class="math inline">\(u\)</span> 可利用 <span
class="math inline">\(v\)</span> 的最长路径为 <span
class="math inline">\(g_v\)</span>。</p>
<p>对于 <span class="math inline">\(u \stackrel{w}{\longrightarrow}
v\)</span>，我们有两种情况：</p>
<ul>
<li><span class="math inline">\(w + g_v \ge
\text{limit}\)</span>，此时我们可直接将该边与 <span
class="math inline">\(v\)</span> 中剩余的路径连起来形成一条新的赛道。即
<span class="math inline">\(f_u = f_v + 1\)</span>；</li>
<li><span class="math inline">\(w + g_v \ge
\text{limit}\)</span>，此时我们无法形成一条完整的赛道。此时我们需要将这个路径保存以便后续使用。</li>
</ul>
<p>对于节点 <span class="math inline">\(u\)</span>
保存的路径，我们有两种情况：</p>
<ol type="1">
<li>由于保存的路径端点均为 <span
class="math inline">\(u\)</span>，我们可将两条路径连在一起形成一条赛道；</li>
<li>将路径保存至 <span class="math inline">\(g_u\)</span>，以便 <span
class="math inline">\(u\)</span> 的父节点使用。</li>
</ol>
<p>我们可以证明：我们尽量满足情况 <span
class="math inline">\(1\)</span>，对于无法满足情况 <span
class="math inline">\(1\)</span> 的路径中取最长路径满足情况 <span
class="math inline">\(2\)</span>。这种方法不劣。因为对于 <span
class="math inline">\(u\)</span> 的父节点，我们至多只能形成一条利用
<span class="math inline">\(u\)</span> 的赛道。而对于对 <span
class="math inline">\(u\)</span> 的父节点有用的路径，使用情况 <span
class="math inline">\(1\)</span> 和情况 <span
class="math inline">\(2\)</span> 对答案的贡献是等价的。对于对 <span
class="math inline">\(u\)</span> 的父节点无用的路径，使用情况 <span
class="math inline">\(1\)</span> 显然更优。</p>
<p>对于路径的保存，我们用 <code>multiset</code> 保存，用
<code>lower_bound</code> 查询可连接成赛道的路径即可。时间复杂度 <span
class="math inline">\(O(n \log n \log L)\)</span>，其中 <span
class="math inline">\(L\)</span> 为边权和。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    std::multiset&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">&#125; N[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line">    <span class="type">int</span> w;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t, <span class="type">int</span> w) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t), <span class="built_in">w</span>(w) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> t, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    N[s].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[s], &amp;N[t], w));</span><br><span class="line">    N[t].e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(&amp;N[t], &amp;N[s], w));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(Node *v, <span class="type">int</span> limit, Node *f = <span class="literal">NULL</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span> (Edge *e = &amp;v-&gt;e.<span class="built_in">front</span>(); e &amp;&amp; e &lt;= &amp;v-&gt;e.<span class="built_in">back</span>(); e++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e-&gt;t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="built_in">dfs</span>(e-&gt;t, limit, v);</span><br><span class="line">        <span class="keyword">if</span> (res + e-&gt;w &gt;= limit) cnt++;</span><br><span class="line">        <span class="keyword">else</span> v-&gt;s.<span class="built_in">insert</span>(res + e-&gt;w);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!v-&gt;s.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (v-&gt;s.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> std::<span class="built_in">max</span>(max, *v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        std::multiset&lt;<span class="type">int</span>&gt;::iterator it = v-&gt;s.<span class="built_in">lower_bound</span>(limit - *v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">if</span> (it == v-&gt;s.<span class="built_in">begin</span>() &amp;&amp; v-&gt;s.<span class="built_in">count</span>(*it) == <span class="number">1</span>) it++;</span><br><span class="line">        <span class="keyword">if</span> (it == v-&gt;s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            max = std::<span class="built_in">max</span>(max, *v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">            v-&gt;s.<span class="built_in">erase</span>(v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            v-&gt;s.<span class="built_in">erase</span>(it);</span><br><span class="line">            v-&gt;s.<span class="built_in">erase</span>(v-&gt;s.<span class="built_in">begin</span>());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b, l;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;a, &amp;b, &amp;l);</span><br><span class="line">        <span class="built_in">addEdge</span>(a, b, l);</span><br><span class="line">        max += l;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = max;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(&amp;N[<span class="number">1</span>], mid);</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= m) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>贪心</tag>
        <tag>二分</tag>
        <tag>二分答案</tag>
      </tags>
  </entry>
  <entry>
    <title>NOIP2021 行记</title>
    <url>/noip2021/</url>
    <content><![CDATA[<p><del>又滚来记流水账了。。。</del></p>
<h1 id="day--">Day -???</h1>
<p>CSP-S 2021 第二轮成绩出来了，72 分，稳过。</p>
<p>我们学校的 NOIP 名单也出来了，全校参赛不到 10 个人。。。</p>
<h1 id="day--2">Day -2</h1>
<p>成功申请停课。。。</p>
<p>顺带在昨天过了 <a
href="https://www.luogu.com.cn/problem/P3371">单源最短路径（弱化版）</a>。<del>调了
2 天的 bug，我太蒻了 QWQ。</del></p>
<p>看了一下图论基础，准备刷一下 DP 题。</p>
<p>考点也出来了，在天府七中（离家好远啊，开车将近一个小时），不过还好终于在成都考了。</p>
<span id="more"></span>
<h1 id="day--1">Day -1</h1>
<p>刷了一下题，摸了一会儿鱼。</p>
<p>看了一下正睿 OI 的题 <del>真难</del>。</p>
<p>打算刷一下 <a href="https://loj.ac/p?tagIds=186">LibreOJ NOIP Round
#1 的题</a>。</p>
<p>顺带复习了一下 KMP 算法和字符串哈希（lyd 的书真好用）。</p>
<h1 id="day-0">Day 0</h1>
<p>上午刷题的时候发现 "INORI FOR U"
买的键盘到了，粉色红轴，就观摩了一会儿。</p>
<p>中午爸爸把身份证送到学校了，顺带还送来了手机。</p>
<p>晚上简简单单的刷了一下题，就去睡觉了。</p>
<h1 id="day-1">Day 1</h1>
<p>早上起晚了，跑着去吃早饭，赶紧吃完早饭就上车。</p>
<p>到了天府七中之后，看了一下，环境比电子科大的好，电脑配置四代 i5 加上
8G 内存，勉强能用。</p>
<p>考试前开了 Linux 开始打板子，结果老师说考试前不能动电脑，然后把 Linux
关了。。。</p>
<p>考试开始后读了一下题。</p>
<p>首先看了一下 T1，看着数据范围应该用 <span
class="math inline">\(O(n)\)</span>
的算法，于是想到了先在输入数据中取到询问最大值，类似于埃氏筛法的算法，最后挨个查询的做法。感觉极限数据的答案会超过
<span class="math inline">\(1 \times
10^7\)</span>，于是数组和筛法的次数都开了两倍，写 +
调用了一个小时就把大样例过了，于是就开始做下一道题。</p>
<p>T2 花了半个小时才读懂，开始想怎么把数拆成二进制后用 k
枚举，然后发现这种方法不可行。最终还是想不出正解，就花了一点时间写了一个
<span class="math inline">\(O(n^m)\)</span>
的复杂度的暴力，大样例花了三秒钟才跑出来，有点慌。</p>
<p>T3 看了一下，很明显是 DP，并且不是背包或线性
DP。知道这道题我写不出来正解后果断打暴力，由于不会将 <span
class="math inline">\(n^2\)</span> 乘在方差里，最终的结果只能用 double
存（精度爆炸）。到了最后也只能过第一个样例。</p>
<p>T4 很明显不可做，花了 80min 写了一个邻接表 + 爆搜（没有处理 opt = 3
的情况），跑路。</p>
<p>这次至少把题做完了。。。</p>
<p>估分：100 + 20 + 12 + 0 = 132</p>
<p>回家看了一下洛谷群，发现第一题可能会被卡。</p>
<p>分数 -= 20。。。</p>
<h1 id="day-2">Day 2</h1>
<p>补文化课 ing</p>
<p>顺带看了一下有道小图灵，省一无望了，<del>可能省二都没了</del>（意料之中）。</p>
<h1 id="day">Day ???</h1>
<p>分数 70 + 0 + 0 + 0 = 70pts，省三。。。</p>
<p>打算在期末调考之前 AFO 了。</p>
]]></content>
      <categories>
        <category>日常</category>
        <category>行记</category>
      </categories>
      <tags>
        <tag>日常</tag>
        <tag>行记</tag>
        <tag>2021</tag>
        <tag>NOIP</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ 3691」DNA repair - AC 自动机 + DP</title>
    <url>/poj-3691/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://poj.org/problem?id=3691">POJ 链接</a></p>
<p>生物学家终于发明了修复 DNA
的技术，能够将包含各种遗传疾病的DNA片段进行修复。</p>
<p>为了简单起见，DNA 看作是一个由
<code>A</code>、<code>G</code>、<code>C</code>、<code>T</code>
构成的字符串。</p>
<p>修复技术就是通过改变字符串中的一些字符，从而消除字符串中包含的致病片段。</p>
<p>例如，我们可以通过改变两个字符，将 DNA 片段 <code>AAGCAG</code> 变为
<code>AGGCAC</code>，从而使得 DNA 片段中不再包含致病片段
<code>AAG</code>、<code>AGC</code>、<code>CAG</code>，以达到修复该DNA片段的目的。</p>
<p>需注意，被修复的 DNA 片段中，仍然只能包含字符
<code>A</code>、<code>G</code>、<code>C</code>、<code>T</code>。</p>
<p>请你帮助生物学家修复给定的 DNA
片段，并且修复过程中改变的字符数量要尽可能的少。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题存在多个字符串的匹配问题，可以考虑使用 AC
自动机解决。我们可以先将所有的致病片段都插入 AC
自动机中，并将致病基因字符串作标记。注意如果一个字符串的子串是致病基因，则这个字符串必为致病基因。故构建
AC 自动机时需要看 <code>fail</code>
所指的字符串是否为致病基因，然后更新该节点的信息。即
<code>c-&gt;isWord |= c-&gt;fail-&gt;isWord</code>。</p>
<p>接下来我们需要求解问题。由于求的是最小修改次数，可考虑 DP
解决。由于可使用 AC 自动机匹配是否有子串为致病基因，我们可以考虑以 AC
自动机匹配时的状态为维度进行 DP。</p>
<p>对于需要修复的 DNA 片段 <span
class="math inline">\(s\)</span>，我们可定义 <span
class="math inline">\(f_{i, j}\)</span> 为遍历到 <span
class="math inline">\(s_i\)</span>，且达到位于 AC 自动机 <span
class="math inline">\(j\)</span> 节点的状态时需要最小修改次数。对于可从
<span class="math inline">\(j\)</span> 到达的状态 <span
class="math inline">\(k\)</span>，我们设 <span
class="math inline">\(l\)</span> 为 <span
class="math inline">\(k\)</span>
所在的字符。设属于致病基因的字符串所代表的节点的集合为 <span
class="math inline">\(\text{Disease}\)</span>，于是有下列转移方程：</p>
<p><span class="math display">\[
f_{i + 1, k} = \begin{cases}
\min\{ f_{i + 1, k}, f_{i, j} + [s_{i + 1} = l] \} &amp; k \notin
\text{Disaese} \\
\infty &amp; k \in \text{Disease}
\end{cases}
\]</span></p>
<p>接下来我们只需要初始化 <span class="math inline">\(f_{i, j} =
\begin{cases} 0 &amp; i = 0 \wedge j = \text{root} \\ \infty &amp;
otherwise. \end{cases}\)</span>，然后求解即可。设 AC
自动机中所有点的集合为 <span
class="math inline">\(\text{AC}\)</span>，最终答案则为 <span
class="math inline">\(\min\limits_{i \in \text{AC}}{f_{m,
i}}\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<p>由于这里需要枚举 AC 自动机中的所有节点，故使用内存池编写。</p>
<p><del>POJ 不支持 C++11 真 TM 烦</del></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;new&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1000</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> CHARSET_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">const</span> <span class="type">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;A&#x27;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;G&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;C&#x27;</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> id;</span><br><span class="line">        Node *c[CHARSET_SIZE], *fail;</span><br><span class="line">        <span class="type">bool</span> isWord;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">bool</span> isWord = <span class="literal">false</span>) : <span class="built_in">fail</span>(<span class="literal">NULL</span>), <span class="built_in">isWord</span>(isWord) &#123; </span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++) c[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">Node</span>(<span class="type">int</span> id, <span class="type">bool</span> isWord = <span class="literal">false</span>) : <span class="built_in">id</span>(id), <span class="built_in">fail</span>(<span class="literal">NULL</span>), <span class="built_in">isWord</span>(isWord) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++) c[i] = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; *root, _pool[MAXN + <span class="number">1</span>], *_curr;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> idx;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">root</span>(_pool), _curr(_pool + <span class="number">1</span>), <span class="built_in">idx</span>(<span class="number">0</span>) &#123; root-&gt;id = <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Node *<span class="title">insert</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *begin, <span class="type">const</span> <span class="type">char</span> *end)</span> </span>&#123;</span><br><span class="line">        Node **v = &amp;root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="type">char</span> *p = begin; p != end; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!*v) *v = <span class="built_in">new</span> (_curr++) <span class="built_in">Node</span>(++idx);</span><br><span class="line">            v = &amp;(*v)-&gt;c[<span class="built_in">get</span>(*p)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!*v) *v = <span class="built_in">new</span> (_curr++) <span class="built_in">Node</span>(++idx);</span><br><span class="line">        (*v)-&gt;isWord = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> *v;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        std::queue&lt;Node *&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        root-&gt;fail = root;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            Node *v = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; CHARSET_SIZE; i++) &#123;</span><br><span class="line">                Node *&amp;c = v-&gt;c[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!c) &#123;</span><br><span class="line">                    c = v == root ? root : v-&gt;fail-&gt;c[i];</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Node *u = v-&gt;fail;</span><br><span class="line"></span><br><span class="line">                c-&gt;fail = v != root &amp;&amp; u-&gt;c[i] ? u-&gt;c[i] : root;</span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(c);</span><br><span class="line"></span><br><span class="line">                c-&gt;isWord |= c-&gt;fail-&gt;isWord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, counts = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n) != EOF &amp;&amp; n) &#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">char</span> s[MAXN + <span class="number">1</span>];</span><br><span class="line">        Trie t;</span><br><span class="line">        <span class="function">std::vector&lt;Trie::Node *&gt; <span class="title">node</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">            node[i] = t.<span class="built_in">insert</span>(s, s + <span class="built_in">strlen</span>(s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        t.<span class="built_in">build</span>();</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, s);</span><br><span class="line">        <span class="type">int</span> m = <span class="built_in">strlen</span>(s);</span><br><span class="line"></span><br><span class="line">        std::vector&lt; std::vector&lt;<span class="type">int</span>&gt; &gt; <span class="built_in">f</span>(m + <span class="number">1</span>, std::<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(t.idx + <span class="number">1</span>, INT_MAX));</span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= t.idx; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f[i][j] != INT_MAX) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; CHARSET_SIZE; k++) &#123;</span><br><span class="line">                        <span class="type">int</span> l = <span class="built_in">get</span>(s[i]) != k;</span><br><span class="line">                        Trie::Node *p = t._pool[j].c[k];</span><br><span class="line">                        <span class="keyword">if</span> (!p-&gt;isWord) f[i + <span class="number">1</span>][p-&gt;id] = std::<span class="built_in">min</span>(f[i + <span class="number">1</span>][p-&gt;id], f[i][j] + l);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= t.idx; i++) ans = std::<span class="built_in">min</span>(ans, f[m][i]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Case %d: %d\n&quot;</span>, ++counts, ans == INT_MAX ? <span class="number">-1</span> : ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>字符串</tag>
        <tag>POJ</tag>
        <tag>AC 自动机</tag>
      </tags>
  </entry>
  <entry>
    <title>「POJ 3666」Making the Grade - 线性 DP</title>
    <url>/poj-3666/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://poj.org/problem?id=3666">POJ 链接</a></p>
<p>给定一个长度为 <span class="math inline">\(N\)</span> 的序列 <span
class="math inline">\(A\)</span>，要求构造一个长度为 <span
class="math inline">\(N\)</span> 的序列 <span
class="math inline">\(B\)</span>。<span class="math inline">\(B\)</span>
满足以下条件：</p>
<ol type="1">
<li><p><span class="math inline">\(B\)</span>
非严格单调（单调递增或单调递减都可），</p></li>
<li><p>在满足 <span class="math inline">\(1\)</span> 的条件下，使 <span
class="math inline">\(S = \sum_{i = 1}^{N} | A_i - B_i
|\)</span>。</p></li>
</ol>
<p>仅需求出最小值 <span class="math inline">\(S\)</span>
即可。题目数据满足 <span class="math inline">\(1 \leq N \leq
2000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>首先我们讨论 <span class="math inline">\(B\)</span>
为非严格单调序列。非严格单调递减同理。两者取最小值即使答案。</p>
<h2 id="构造处理">构造处理</h2>
<p>首先我们提出一个猜想：至少有一种构造方法，满足在 <span
class="math inline">\(S\)</span> 最小的情况下，使 <span
class="math inline">\(B\)</span> 中所有数字均在 <span
class="math inline">\(A\)</span> 中出现过。</p>
<p>这个猜想可以用数学归纳法进行证明：</p>
<ol type="1">
<li><p>显然在 <span class="math inline">\(N = 1\)</span>
的时候该结论成立。</p></li>
<li><p>设该猜想对于 <span class="math inline">\(N = x - 1\)</span>
时成立，则对于 <span class="math inline">\(N =
x\)</span>，分为一下情况：</p>
<ul>
<li><p><span class="math inline">\(B_{x - 1} \leq A_x\)</span>，显然
<span class="math inline">\(B_{x} = A_x\)</span> 的时候 <span
class="math inline">\(S\)</span> 最小。</p></li>
<li><p><span class="math inline">\(B_{x - 1} &gt; A_x\)</span>，可令
<span class="math inline">\(B_x = B_{x - 1}\)</span>，或者寻找一个值
<span class="math inline">\(y\)</span>，将 <span
class="math inline">\(B_y, B_{y + 1}, B_{y + 2}, \cdots, B_x\)</span>
赋值为同一个数 <span class="math inline">\(z\)</span>。令 <span
class="math inline">\(A\)</span> 的中位数为 <span
class="math inline">\(mid\)</span>，若 <span class="math inline">\(mid
&lt; B_{y - 1}\)</span>，则 <span class="math inline">\(z = B_{y -
1}\)</span>，否则 <span class="math inline">\(z =
mid\)</span>。从中位数性质易得该结论。</p></li>
</ul></li>
</ol>
<h2 id="动态规划">动态规划</h2>
<p>接下来即可进行动态规划。令排序过的 <span
class="math inline">\(A\)</span> 为 <span
class="math inline">\(S\)</span>，我们可以设数组 <span
class="math inline">\(f_{i, j}\)</span>，其中 <span
class="math inline">\(i\)</span> 表示目标是求 <span
class="math inline">\(B\)</span> 的第 <span
class="math inline">\(i\)</span> 项，<span
class="math inline">\(j\)</span> 表示 <span class="math inline">\(B_i =
S_j\)</span> 的情况。<span class="math inline">\(f_{i, j}\)</span>
的值表示 <span class="math inline">\(A\)</span> 在 <span
class="math inline">\(i\)</span> 及之前的序列在使用 <span
class="math inline">\(S\)</span> 在 <span
class="math inline">\(j\)</span> 及以前的序列的数的情况下 <span
class="math inline">\(S\)</span>
的最小值。我们可以推出下列状态转移方程：</p>
<p><span class="math display">\[
f_{i, j} = \min \limits_{1 \leq k \leq j} \{ f_{i - 1, k} + |A_i - S_j|
\}
\]</span></p>
<p>初始状态为 <span class="math inline">\(f = INF\)</span>，目标所求为
<span class="math inline">\(\min \limits_{1 \leq i \leq n} f_{n,
i}\)</span>。</p>
<p>由于状态转移方程中 <span class="math inline">\(f_{i - 1, k}\)</span>
的最小值滚动时只会受到最后一个数的影响，我们可以将前一个最小值存起来，更新时仅比较前一个最小值和
<span class="math inline">\(f_{i - 1, k}\)</span>。可以将时间复杂度从
<span class="math inline">\(O(n^3)\)</span> 优化到 <span
class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对单调递增的处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fG[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>], s[MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fG, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(fG));</span><br><span class="line">    <span class="built_in">memcpy</span>(s, a, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    std::<span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fG[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            fG[i][<span class="number">0</span>] = std::<span class="built_in">min</span>(fG[i][<span class="number">0</span>], fG[i - <span class="number">1</span>][j]);</span><br><span class="line">            fG[i][j] = fG[i][<span class="number">0</span>] + <span class="built_in">abs</span>(a[i] - s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对单调递减的处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> fL[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(fL, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(fG));</span><br><span class="line">    <span class="built_in">memcpy</span>(s, a, <span class="built_in">sizeof</span>(a));</span><br><span class="line">    std::<span class="built_in">sort</span>(s + <span class="number">1</span>, s + n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) fL[<span class="number">0</span>][i] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            fL[i][<span class="number">0</span>] = std::<span class="built_in">min</span>(fL[i][<span class="number">0</span>], fL[i - <span class="number">1</span>][j]);</span><br><span class="line">            fL[i][j] = fL[i][<span class="number">0</span>] + <span class="built_in">abs</span>(a[i] - s[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fG[n][i] &lt; ans) ans = fG[n][i];</span><br><span class="line">        <span class="keyword">if</span> (fL[n][i] &lt; ans) ans = fL[n][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>USACO</tag>
        <tag>线性 DP</tag>
        <tag>POJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2011」糖果 - 差分约束</title>
    <url>/scoi2011-candy/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3275">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2436">LOJ 链接</a></p>
<p>幼儿园里有 <span class="math inline">\(N\)</span> 个小朋友，lxhgww
老师现在想要给这些小朋友们分配糖果，要求每个小朋友都要分到糖果。但是小朋友们也有嫉妒心，总是会提出一些要求，比如小明不希望小红分到的糖果比他的多，于是在分配糖果的时候，lxhgww
需要满足小朋友们的 <span class="math inline">\(K\)</span>
个要求。幼儿园的糖果总是有限的，lxhgww
想知道他至少需要准备多少个糖果，才能使得每个小朋友都能够分到糖果，并且满足小朋友们所有的要求。</p>
<span id="more"></span>
<p>要求分为 <span class="math inline">\(5\)</span> 种，每种要求为 <span
class="math inline">\((X, A, B)\)</span>，含义如下：</p>
<ul>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(1\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须和第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果一样多；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(2\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须少于第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(3\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须不少于第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(4\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须多于第  <span
class="math inline">\(B\)</span>  个小朋友分到的糖果；</p></li>
<li><p>如果  <span class="math inline">\(X\)</span> = <span
class="math inline">\(5\)</span>， 表示第  <span
class="math inline">\(A\)</span>  个小朋友分到的糖果必须不多于第 <span
class="math inline">\(B\)</span> 个小朋友分到的糖果。</p></li>
</ul>
<h1 id="解题思路">解题思路</h1>
<p>很明显这是一道差分约束的题目。如何转化是本题的重点。</p>
<p>首先我们可以将 <span class="math inline">\(5\)</span>
种情况分别转化。</p>
<p><span class="math display">\[
\begin{cases}
A = B &amp; X = 1 \\
A &lt; B &amp; X = 2 \\
A \geq B &amp; X = 3 \\
A &gt; B &amp; X = 4 \\
A \leq B &amp; X = 5
\end{cases}
\]</span></p>
<p>由于差分约束无法处理大于号和小于号，又同时数据只涉及整数，我们可以做如下处理：</p>
<p><span class="math display">\[
x &lt; y (x, y \in \mathbb{Z}) \Leftrightarrow x + 1 \leq y
\]</span></p>
<p>于是我们可以把 <span class="math inline">\(2\)</span> 和 <span
class="math inline">\(4\)</span> 情况加以转化，最终得出以下不等式：</p>
<p><span class="math display">\[
\begin{cases}
A - B \geq 0 \vee B - A \geq 0 &amp; X = 1 \\
B - A \geq 1 &amp; X = 2 \\
A - B \geq 0 &amp; X = 3 \\
A - B \geq 1 &amp; X = 4 \\
A - B \geq 0 &amp; X = 5
\end{cases}
\]</span></p>
<p>由于不等式中都是大于等于号，我们可以用最长路解决。</p>
<p>不用最短路是因为最短路中出现了负权边，毫无关系的两个点的最短路大小关系会受到
<span class="math inline">\(0\)</span>
的影响，若想得到正确答案则需要在除去超级源点的图的弱连通分量中分别寻找答案，码量巨大，及其难写。若使用最长路则不会出现负权边，不会出现该情况。</p>
<p>最终答案就是最终解的和。若解的最小值不等于 <span
class="math inline">\(1\)</span>
，由于差分性质，可以把所有解同时加一个数或减一个数，使最小值等于 <span
class="math inline">\(1\)</span> 后再求和。</p>
<p>同时要注意特判在 <span class="math inline">\(2\)</span> 和 <span
class="math inline">\(4\)</span> 情况下 <span
class="math inline">\(A\)</span> 和 <span
class="math inline">\(B\)</span> 不能相等，否则无解。</p>
<p>最后注意一下由于这道题的图是稀疏图，且数据较大，所以求最长路只能用
<del>已经死了的</del> SPFA，用 Bellman-Ford 会 TLE。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k, cnt[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> dis[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">bool</span> vis[MAXN + <span class="number">1</span>];</span><br><span class="line">std::queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">-0x3f</span>, <span class="built_in">sizeof</span>(dis));</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="literal">false</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in">sizeof</span>(cnt));</span><br><span class="line">    dis[<span class="number">0</span>] = <span class="number">0</span>, vis[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        vis[u] = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[ed.first] &lt; dis[u] + ed.second) &#123;</span><br><span class="line">                dis[ed.first] = dis[u] + ed.second;</span><br><span class="line">                cnt[ed.first] = cnt[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (cnt[ed.first] &gt;= n + <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (!vis[ed.first]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(ed.first);</span><br><span class="line">                    vis[ed.first] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        <span class="type">int</span> x, a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;a, &amp;b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">1</span>) &#123;</span><br><span class="line">            e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">0</span>) );</span><br><span class="line">            e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">0</span>) );</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">1</span>) );</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">3</span>) e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">0</span>) );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> e[b].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(a, <span class="number">1</span>) );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> e[a].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(b, <span class="number">0</span>) );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[<span class="number">0</span>].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(i, <span class="number">0</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SPFA</span>()) &#123;</span><br><span class="line">        <span class="type">int</span> minn = INF;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (minn &gt; dis[i]) minn = dis[i];</span><br><span class="line">            sum += dis[i];</span><br><span class="line">        &#125;</span><br><span class="line">        sum += (<span class="type">long</span> <span class="type">long</span>)n * (<span class="number">1</span> - minn);</span><br><span class="line">        std::cout &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;-1&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>省选</tag>
        <tag>2011</tag>
        <tag>差分约束</tag>
        <tag>SCOI</tag>
      </tags>
  </entry>
  <entry>
    <title>「联合省选 2022」预处理器 - 模拟</title>
    <url>/pro2022-preprocessor/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P8289">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3700">LOJ 链接</a></p>
<p>对于该题，你需要展开 <code>#define</code> 宏定义。本题中的宏定义与
C++ 中的宏定义大致相同，不过有下列特点：</p>
<ul>
<li>可以用 <code>#undef</code> 取消宏定义；</li>
<li>可以进行多次展开。如
<code>#define a b+e</code>，<code>#define b c+d</code>，对于
<code>a</code> 最终展开结果为 <code>c+d+e</code>；</li>
<li>可以进行递归展开，但若待展开的宏名与正在进行展开的某个宏名相同，为了防止无限递归，此时宏名就不再展开。如
<code>#define a b+c</code>，<code>#define b a+a</code>，对于
<code>b</code> 的展开结果即为 <code>b+c+b+c</code>。</li>
</ul>
<p>其他细节详见题面。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><del>一道让 OI 倒退 15 年的题</del></p>
<p>本题是一道细节超多的模拟题。</p>
<p>首先我们需要解决这道题的输入。以分隔符为界，分段读入即可。每个分隔符（包括空格）可以看成单独一个字符串读入即可。</p>
<p>然后我们可以用 <code>std::map&lt;std::string, std::string&gt;</code>
存储 <code>#define</code> 的对应关系。对于
<code>#undef</code>，我们仅需在 <code>map</code> 中删除该项即可。</p>
<p>最后我们需要解决的是字符串展开问题，也是本题中细节最多的部分。</p>
<p>由于本题中涉及了递归展开，我们可以考虑使用递归来编写处理函数
<code>solve</code>。首先考虑在 <code>map</code>
中是否有已经定义的字符串或者是否被打标记，若 <code>map</code>
中没有或被打了标记则直接输出。若有，则进行以下操作：</p>
<ol type="1">
<li>进行标记（在本代码中使用 <code>vis</code> 进行）；</li>
<li>展开当前的字符串；</li>
<li>将字符串分段读入（读入方式见上）；</li>
<li>对于每段字符串分别递归求解；</li>
<li>取消标记。</li>
</ol>
<p>注意 4
步很重要，若直接展开后递归，则无法处理两将要展开的字符串并列的情况。接下来为该情况
Hack 数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">#define a b+c</span><br><span class="line">#define b a+a</span><br><span class="line">b</span><br></pre></td></tr></table></figure>
<p>结果应为 <code>b+c+b+c</code>，但是直接展开后递归的结果会是
<code>b+c+a</code>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::map&lt;std::string, std::string&gt; def;</span><br><span class="line">std::map&lt;std::string, <span class="type">bool</span>&gt; vis;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isID</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((ch &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;Z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;z&#x27;</span>) || (ch &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; ch &lt;= <span class="string">&#x27;9&#x27;</span>) || ch == <span class="string">&#x27;_&#x27;</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// tuple 中第一项代表读到的字符串，第二项表示是否为分隔符，第三项表示结束位置对应 src 的下标</span></span><br><span class="line"><span class="comment">// 建议可以学一下 tuple 的用法</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::tuple&lt;std::string, <span class="type">bool</span>, <span class="type">int</span>&gt; <span class="title">reads</span><span class="params">(std::string src, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isID</span>(src[pos])) &#123;</span><br><span class="line">        std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = src.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">while</span> (pos &lt; len &amp;&amp; <span class="built_in">isID</span>(src[pos])) &#123;</span><br><span class="line">            str += src.<span class="built_in">substr</span>(pos, <span class="number">1</span>);</span><br><span class="line">            pos++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(str, <span class="literal">true</span>, pos);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        str += src.<span class="built_in">substr</span>(pos, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(str, <span class="literal">false</span>, pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个函数专门读 #define</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> std::pair&lt;std::string, <span class="type">int</span>&gt; <span class="title">readDef</span><span class="params">(std::string src, <span class="type">int</span> pos)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = src.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; len &amp;&amp; <span class="built_in">isspace</span>(src[pos])) pos++;</span><br><span class="line">    std::string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (pos &lt; len &amp;&amp; !<span class="built_in">isspace</span>(src[pos])) str += src[pos++];</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_pair</span>(str, pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(std::string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (def.<span class="built_in">count</span>(str) != <span class="number">0</span> &amp;&amp; !vis[str]) &#123;</span><br><span class="line">        vis[str] = <span class="literal">true</span>;</span><br><span class="line">        std::string src = str;  <span class="comment">// 注意要存原先字符串以在取消标记时使用</span></span><br><span class="line">        str = def[str];</span><br><span class="line">        std::tuple&lt;std::string, <span class="type">bool</span>, <span class="type">int</span>&gt; getReads = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line">        std::vector&lt;std::string&gt; vec;</span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) &lt; len) &#123;</span><br><span class="line">            getReads = <span class="built_in">reads</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line">            vec.<span class="built_in">push_back</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (std::string each : vec) <span class="built_in">solve</span>(each);</span><br><span class="line">        vis[src] = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> std::cout &lt;&lt; str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    std::cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XEDEBUG</span></span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;preprocessor.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;preprocessor.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    std::cin.<span class="built_in">ignore</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::string str;</span><br><span class="line">        std::<span class="built_in">getline</span>(std::cin, str);</span><br><span class="line">        std::tuple&lt;std::string, <span class="type">bool</span>, <span class="type">int</span>&gt; getReads = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;&quot;</span>, <span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> len = str.<span class="built_in">length</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) &lt; len) &#123;</span><br><span class="line">            getReads = <span class="built_in">reads</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">1</span>&gt;(getReads)) &#123;</span><br><span class="line">                vis.<span class="built_in">clear</span>();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> each : def) vis[each.first] = <span class="literal">false</span>;</span><br><span class="line">                <span class="built_in">solve</span>(std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads) == <span class="string">&quot;#&quot;</span>) &#123;</span><br><span class="line">                getReads = <span class="built_in">reads</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line">                <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads) == <span class="string">&quot;define&quot;</span>) &#123;</span><br><span class="line">                    std::pair&lt;std::string, <span class="type">int</span>&gt; from = <span class="built_in">readDef</span>(str, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads));</span><br><span class="line">                    std::string to = str.<span class="built_in">substr</span>(from.second + <span class="number">1</span>);</span><br><span class="line">                    def[from.first] = to;</span><br><span class="line">                    getReads = std::<span class="built_in">make_tuple</span>(to, <span class="literal">true</span>, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads) == <span class="string">&quot;undef&quot;</span>) &#123;</span><br><span class="line">                    std::string from = str.<span class="built_in">substr</span>(std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) + <span class="number">1</span>);</span><br><span class="line">                    def.<span class="built_in">erase</span>(from);</span><br><span class="line">                    getReads = std::<span class="built_in">make_tuple</span>(from, <span class="literal">true</span>, len);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    std::cout &lt;&lt; <span class="string">&quot;#&quot;</span>;</span><br><span class="line">                    getReads = std::<span class="built_in">make_tuple</span>(<span class="string">&quot;#&quot;</span>, <span class="literal">false</span>, std::<span class="built_in">get</span>&lt;<span class="number">2</span>&gt;(getReads) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> std::cout &lt;&lt; std::<span class="built_in">get</span>&lt;<span class="number">0</span>&gt;(getReads);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> XEDEBUG</span></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>2022</tag>
        <tag>模拟</tag>
        <tag>省选</tag>
      </tags>
  </entry>
  <entry>
    <title>前缀和学习笔记</title>
    <url>/prefix-sum-notes/</url>
    <content><![CDATA[<h1 id="概念">概念</h1>
<p>前缀和为一种预处理，可理解为数列前 <span
class="math inline">\(n\)</span>
项的和。可降低查询某些信息的所需时间。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前缀和示例</span></span><br><span class="line"><span class="type">int</span> sum[MAXN];</span><br><span class="line">sum[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">    sum[i] = sum[i - <span class="number">1</span>] + a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<h2 id="stl-中的前缀和">STL 中的前缀和</h2>
<p>C++ 标准库中提供了 <code>std::partial_sum</code>
前缀和函数，定义于头文件 <code>&lt;numeric&gt;</code> 中</p>
<p>用法为
<code>partial_sum(InputIt first, InputIt last, OutputIt d_first)</code></p>
<ul>
<li><p><code>first</code> 和 <code>last</code>
表示要求和的元素范围；</p></li>
<li><p><code>d_first</code> 表示目标范围起始；可以等于
<code>first</code>。</p></li>
</ul>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3131">洛谷 P3131
[USACO16JAN]Subsequences Summing to Sevens S</a></p>
<p>本题直接处理前缀和存储余数，在前缀和中取头尾两余数相等的数坐标相减即可。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, maxn = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line">    std::cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum[MAXN + <span class="number">1</span>];</span><br><span class="line">    sum[<span class="number">1</span>] = a[<span class="number">1</span>] % <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        sum[i] = (sum[i - <span class="number">1</span>] + a[i]) % <span class="number">7</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> first[<span class="number">7</span>], last[<span class="number">7</span>];</span><br><span class="line">    <span class="built_in">memset</span>(first, <span class="number">0</span>, <span class="built_in">sizeof</span>(first));</span><br><span class="line">    <span class="built_in">memset</span>(last, <span class="number">0</span>, <span class="built_in">sizeof</span>(last));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; j++)</span><br><span class="line">            <span class="keyword">if</span> (sum[j] == i) &#123;</span><br><span class="line">                first[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = n; j &gt;= <span class="number">1</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (sum[j] == i) &#123;</span><br><span class="line">                last[i] = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    maxn = last[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (last[i] - first[i] &gt; maxn) &#123;</span><br><span class="line">            maxn = last[i] - first[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; maxn &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="二维多维前缀和">二维/多维前缀和</h1>
<p>RT</p>
<h2 id="例题-1">例题</h2>
<p><a href="https://www.luogu.com.cn/problem/P1387">洛谷 P1387
最大正方形</a></p>
<p>本题可通过前缀和处理矩形，利用 <code>sum</code>
数组存储可组成正方形的最大值。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> squ[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            std::cin &gt;&gt; squ[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> sum[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(sum, <span class="number">0</span>, <span class="built_in">sizeof</span>(sum));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (squ[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                sum[i][j] = std::<span class="built_in">min</span>(std::<span class="built_in">min</span>(sum[i - <span class="number">1</span>][j] , sum[i][j - <span class="number">1</span>]), sum[i - <span class="number">1</span>][j - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (sum[i][j] &gt; ans) &#123;</span><br><span class="line">                    ans = sum[i][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2010」股票交易 - 背包 DP + 单调队列</title>
    <url>/scoi2010-trade/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2569">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10183">LOJ 链接</a></p>
<p>最近 <span class="math inline">\(\text{lxhgww}\)</span>
又迷上了投资股票，通过一段时间的观察和学习，他总结出了股票行情的一些规律。</p>
<p>通过一段时间的观察，<span
class="math inline">\(\text{lxhgww}\)</span> 预测到了未来 <span
class="math inline">\(T\)</span> 天内某只股票的走势，第 <span
class="math inline">\(i\)</span> 天的股票买入价为每股 <span
class="math inline">\(AP_i\)</span>，第 <span
class="math inline">\(i\)</span> 天的股票卖出价为每股 <span
class="math inline">\(BP_i\)</span>（数据保证对于每个 <span
class="math inline">\(i\)</span>，都有 <span class="math inline">\(AP_i
\geq BP_i\)</span>），但是每天不能无限制地交易，于是股票交易所规定第
<span class="math inline">\(i\)</span> 天的一次买入至多只能购买 <span
class="math inline">\(AS_i\)</span> 股，一次卖出至多只能卖出 <span
class="math inline">\(BS_i\)</span> 股。</p>
<p>另外，股票交易所还制定了两个规定。为了避免大家疯狂交易，股票交易所规定在两次交易（某一天的买入或者卖出均算是一次交易）之间，至少要间隔
<span class="math inline">\(W\)</span> 天，也就是说如果在第 <span
class="math inline">\(i\)</span> 天发生了交易，那么从第 <span
class="math inline">\(i+1\)</span> 天到第 <span
class="math inline">\(i+W\)</span>
天，均不能发生交易。同时，为了避免垄断，股票交易所还规定在任何时间，一个人的手里的股票数不能超过
<span class="math inline">\(\text{MaxP}\)</span>。</p>
<p>在第 <span class="math inline">\(1\)</span> 天之前，<span
class="math inline">\(\text{lxhgww}\)</span>
手里有一大笔钱（可以认为钱的数目无限），但是没有任何股票，当然，<span
class="math inline">\(T\)</span> 天以后，<span
class="math inline">\(\text{lxhgww}\)</span>
想要赚到最多的钱，聪明的程序员们，你们能帮助他吗？</p>
<p><span class="math inline">\(0\leq W&lt;T\leq
2000,1\leq\text{MaxP}\leq2000,1\leq BP_i\leq AP_i\leq 1000,1\leq
AS_i,BS_i\leq\text{MaxP}\)</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题可通过背包 DP 解决。</p>
<p>显然我们可以定义状态 <span class="math inline">\(f_{i,
j}\)</span>，表示在第 <span class="math inline">\(i\)</span> 天有 <span
class="math inline">\(j\)</span> 张股票所拥有的最多钱数。</p>
<p>于是我们可以有下列 <span class="math inline">\(3\)</span>
中情况：</p>
<ol type="1">
<li>不买不卖：<span class="math inline">\(f_{i, j} = \max\{f_{i, j},
f_{i - 1, j}\}\)</span></li>
<li>买股票：<span class="math inline">\(f_{i, j} = \max\{f_{i, j}, f_{i
- w - 1, k} + \text{ap}_i * (k - j)\} \quad k \in [j - \text{as}_i,
j)\)</span></li>
<li>卖股票：<span class="math inline">\(f_{i, j} = \max\{f_{i, j}, f_{i
- w - 1, k} + \text{bp}_i * (k - j)\} \quad k \in (j, j +
\text{bs}_i]\)</span></li>
</ol>
<p>初始状态为下列两种：</p>
<ol type="1">
<li>直接买：<span class="math inline">\(f_{i, j} = -\text{ap}_i \times j
\quad j \in [0, \text{as}_i]\)</span></li>
<li>不买：除直接买外情况外 <span class="math inline">\(f_{i, j} =
-\infty\)</span></li>
</ol>
<p>但直接进行 DP 时间复杂度为 <span
class="math inline">\(O(n^3)\)</span>，肯定无法通过本题。</p>
<p>观察状态转移方程，我们可以发现该方程可用单调队列优化。</p>
<p>对于状态转移方程：</p>
<p><span class="math display">\[
f_{i, j} = \max
\begin{cases}
f_{i - 1, j} \\
\max\{f_{i - w - 1, k} + \text{ap}_i * (k - j)\} &amp; k \in [j -
\text{as}_i, j) \\
\max\{f_{i - w - 1, k} + \text{bp}_i * (k - j)\} &amp; k \in (j, j +
\text{bs}_i]
\end{cases}
\]</span></p>
<p>通过简单代数变化可转化为：</p>
<p><span class="math display">\[
f_{i, j} = \max
\begin{cases}
f_{i - 1, j} \\
\max\{f_{i - w - 1, k} + \text{ap}_i * k\} - \text{ap}_i * j &amp; k \in
[j - \text{as}_i, j) \\
\max\{f_{i - w - 1, k} + \text{bp}_i * k\} - \text{bp}_i * j &amp; k \in
(j, j + \text{bs}_i]
\end{cases}
\]</span></p>
<p>由于 <span class="math inline">\(\max\{f_{i - w - 1, k} + \text{ap}_i
* k\}\)</span> 和 <span class="math inline">\(\max\{f_{i - w - 1, k} +
\text{bp}_i * k\}\)</span> 与 <span class="math inline">\(j\)</span>
无关，故对于任何 <span
class="math inline">\(j\)</span>，该式解出的值相等。于是我们可以用单调队列预处理该式。优化掉
<span class="math inline">\(k\)</span> 这个维度，于是将复杂度优化到
<span class="math inline">\(O(n^2)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2000</span>, INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MonotoneQueue</span> &#123;</span><br><span class="line">    std::deque&lt;T&gt; q, m;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;x)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="keyword">while</span> (!m.<span class="built_in">empty</span>() &amp;&amp; m.<span class="built_in">back</span>() &lt; x) m.<span class="built_in">pop_back</span>();</span><br><span class="line">        m.<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        T x = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop_front</span>();</span><br><span class="line">        <span class="keyword">if</span> (x == m.<span class="built_in">front</span>()) m.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t, maxp, w;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ap[MAXN + <span class="number">1</span>], bp[MAXN + <span class="number">1</span>], as[MAXN + <span class="number">1</span>], bs[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d&quot;</span>, &amp;t, &amp;maxp, &amp;w);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;ap[i], &amp;bp[i], &amp;as[i], &amp;bs[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[MAXN + <span class="number">1</span>][MAXN + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0xcf</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= as[i]; j++) f[i][j] = -ap[i] * j;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= maxp; j++) f[i][j] = std::<span class="built_in">max</span>(f[i][j], f[i - <span class="number">1</span>][j]);</span><br><span class="line"></span><br><span class="line">        MonotoneQueue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; buy, sell;</span><br><span class="line">        <span class="keyword">while</span> (!buy.<span class="built_in">empty</span>()) buy.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!sell.<span class="built_in">empty</span>()) sell.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (i - w - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt;= maxp; j++) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!buy.<span class="built_in">empty</span>() &amp;&amp; buy.<span class="built_in">top</span>().second &lt; j - as[i]) buy.<span class="built_in">pop</span>();</span><br><span class="line">                buy.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(f[i - w - <span class="number">1</span>][j] + j * ap[i], j) );</span><br><span class="line">                f[i][j] = std::<span class="built_in">max</span>(f[i][j], buy.<span class="built_in">top</span>().first - j * ap[i]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = maxp; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!sell.<span class="built_in">empty</span>() &amp;&amp; sell.<span class="built_in">top</span>().second &gt; j + bs[i]) sell.<span class="built_in">pop</span>();</span><br><span class="line">                sell.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(f[i - w - <span class="number">1</span>][j] + j * bp[i], j) );</span><br><span class="line">                f[i][j] = std::<span class="built_in">max</span>(f[i][j], sell.<span class="built_in">top</span>().first - j * bp[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = -INF;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= maxp; i++) ans = std::<span class="built_in">max</span>(ans, f[t][i]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>省选</tag>
        <tag>2010</tag>
        <tag>SCOI</tag>
        <tag>背包 DP</tag>
        <tag>单调队列</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDIO2015」约数个数和 - 莫比乌斯反演</title>
    <url>/sdoi2015-divisor/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P3327">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2185">LOJ 链接</a></p>
<p>设 <span class="math inline">\(d(x)\)</span> 为 <span
class="math inline">\(x\)</span> 的约数个数，给定 <span
class="math inline">\(n, m\)</span>，求</p>
<p><span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m d(ij)
\]</span></p>
<p>对于所有的数据，<span class="math inline">\(1 \leq N, M \leq 50000,\
1 \leq T \leq 50000\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<h2 id="约数个数的变换">约数个数的变换</h2>
<p>对这个式子，我们首先要解决的是 <span
class="math inline">\(d(ij)\)</span>。对于 <span
class="math inline">\(d(ij)\)</span>，我们有以下结论：</p>
<p><span class="math display">\[
d(ij) = \sum_{x | i}\sum_{y | j}[\gcd(x, y) = 1]
\]</span></p>
<p>证明：我们可以对 <span class="math inline">\(i\)</span>，<span
class="math inline">\(j\)</span> 分解质因数：<span
class="math inline">\(i = \prod{ p_i^{a_i} }\)</span>，<span
class="math inline">\(j = \prod{ p_i^{b_i} }\)</span>，故 <span
class="math inline">\(ij = \prod{ p_i^{c_i = a_i + b_i} }\)</span>。对于
<span class="math inline">\(ij\)</span> 的每个约数中的 <span
class="math inline">\(p_i\)</span>，我们总可以找到一个 <span
class="math inline">\(d_i (d_i \le c_i)\)</span> 进行对应。而对于每个
<span class="math inline">\(d_i\)</span>，我们分为两种情况：</p>
<ol type="1">
<li><span class="math inline">\(d_i &lt;= a_i\)</span>，则 <span
class="math inline">\(p_i\)</span> 全部在 <span
class="math inline">\(i\)</span> 中取；</li>
<li><span class="math inline">\(a_i &lt; d_i \le a_i + b_i\)</span>，则
<span class="math inline">\(p_i\)</span> 在 <span
class="math inline">\(i\)</span> 中取完后再在 <span
class="math inline">\(b_i\)</span> 中补充。</li>
</ol>
<p>我们可以发现，<strong>对于每一种 <span
class="math inline">\(d_i\)</span>，用上述方法我们总可以找到唯一一种用
<span class="math inline">\(a_i\)</span>、<span
class="math inline">\(b_i\)</span> 对应的方法；所以对应每一种 <span
class="math inline">\(ij\)</span>
的约数，用上述方法我们总可以找到对应且为唯一对应。</strong></p>
<p>于是我们可以利用 <span class="math inline">\(i\)</span>、<span
class="math inline">\(j\)</span> 的约数进行统计。令 <span
class="math inline">\(x | i\)</span>，<span class="math inline">\(y |
j\)</span>；当 <span class="math inline">\(\gcd(i, j) = 1\)</span>
时，对于 <span class="math inline">\(p_i\)</span>，<span
class="math inline">\(i\)</span>、<span class="math inline">\(j\)</span>
中仅有一个含有 <span class="math inline">\(p_i\)</span>：</p>
<ul>
<li>当仅有 <span class="math inline">\(x\)</span> 含有 <span
class="math inline">\(p_i\)</span> 时，对应上述方法 <span
class="math inline">\(1\)</span>；</li>
<li>当仅有 <span class="math inline">\(y\)</span> 含有 <span
class="math inline">\(p_i\)</span> 时，其中「<span
class="math inline">\(x\)</span> 不含有 <span
class="math inline">\(p_i\)</span>，<span
class="math inline">\(y\)</span> 含有 <span
class="math inline">\(p_i\)</span>」所含情况数和「<span
class="math inline">\(i\)</span> 中的 <span
class="math inline">\(p_i\)</span> 被取完，<span
class="math inline">\(y\)</span> 含有 <span
class="math inline">\(p_i\)</span>」相同，对于 <span
class="math inline">\(d(ij)\)</span>
只统计个数来说是等价的。所以对应上述方法 <span
class="math inline">\(2\)</span>。</li>
</ul>
<p>综上，我们仅需统计满足 <span class="math inline">\(\gcd(i, j) =
1\)</span> 的 <span class="math inline">\((i, j)\)</span> 的个数即可。即
<span class="math inline">\(d(ij) = \sum_{x | i}\sum_{y | j}[\gcd(x, y)
= 1]\)</span>。</p>
<h2 id="莫比乌斯反演">莫比乌斯反演</h2>
<p>接下来原式就变成了下列形式：</p>
<p><span class="math display">\[
\sum_{i = 1}^n\sum_{j = 1}^m\sum_{x | i}\sum_{y | j}[\gcd(x, y) = 1]
\]</span></p>
<p>我们设 <span class="math inline">\(A(n, m) = \sum_{i = 1}^n \sum_{j =
1}^m\sum_{x | i}\sum_{y | j}[\gcd(x, y) = 1]\)</span>，显然 <span
class="math inline">\(A(n, m)\)</span> 即为答案。</p>
<p>对于 <span class="math inline">\([\gcd(x, y) = 1]\)</span> 其中的
<span class="math inline">\(1\)</span>
不好化简，于是我们可以设下列函数：</p>
<p><span class="math display">\[
\begin{align*}
f(a) &amp;= \sum_{i = 1}^n\sum_{j = 1}^m\sum_{x | i}\sum_{y | j}[\gcd(x,
y) = a] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [\gcd(x, y) = a]
\end{align*}
\]</span></p>
<p>显然 <span class="math inline">\(A(n, m) =
f(1)\)</span>。接下来我们要化简 <span
class="math inline">\(f(a)\)</span>。我们设下列函数：</p>
<p><span class="math display">\[
\begin{align*}
F(b) &amp;= \sum_{b | a}f(a) \\
&amp;= \sum_{b | a}\sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x}
\rfloor \lfloor \frac{m}{y} \rfloor [\gcd(x, y) = a] \\
&amp;= \sum_{t = 1}^{ \min\{ \lfloor \frac{n}{a} \rfloor \lfloor
\frac{m}{a} \rfloor \} }\sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x}
\rfloor \lfloor \frac{m}{y} \rfloor [\gcd(x, y) = a] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [b | \gcd(x, y)] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [b | x][b | y] \\
&amp;= \sum_{x = 1}^n\sum_{y = 1}^m \lfloor \frac{n}{x} \rfloor \lfloor
\frac{m}{y} \rfloor [b | x][b | y] \\
&amp;= \sum_{i = 1}^{ \lfloor\frac{n}{b}\rfloor }\sum_{j = 1}^{
\lfloor\frac{m}{b}\rfloor }
\lfloor\frac{n}{bi}\rfloor\lfloor\frac{m}{bj}\rfloor \\
\end{align*}
\]</span></p>
<p>由于 <span class="math inline">\(F(b) = \sum_{b |
a}f(a)\)</span>，我们可以进行莫比乌斯反演：</p>
<p><span class="math display">\[
f(a) = \sum_{a | b}\mu(\frac{b}{a})F(b)
\]</span></p>
<p>接下来可以带入 <span class="math inline">\(A(n, m)\)</span>：</p>
<p><span class="math display">\[
\begin{align*}
A(n, m) &amp;= f(1) \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)F(b) \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)\sum_{i = 1}^{
\lfloor\frac{n}{b}\rfloor }\sum_{j = 1}^{ \lfloor\frac{m}{b}\rfloor }
\lfloor\frac{n}{bi}\rfloor\lfloor\frac{m}{bj}\rfloor \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)(\sum_{i = 1}^{
\lfloor\frac{n}{b}\rfloor }\lfloor\frac{n}{bi}\rfloor)(\sum_{j = 1}^{
\lfloor\frac{m}{b}\rfloor } \lfloor\frac{m}{bj}\rfloor) \\
&amp;= \sum_{b}^{ \min\{n, m\} }\mu(b)(\sum_{i = 1}^{
\lfloor\frac{n}{b}\rfloor
}\lfloor\frac{\lfloor\frac{n}{b}\rfloor}{i}\rfloor)(\sum_{j = 1}^{
\lfloor\frac{m}{b}\rfloor
}\lfloor\frac{\lfloor\frac{m}{b}\rfloor}{j}\rfloor)
\end{align*}
\]</span></p>
<p>接下来预处理一下 <span class="math inline">\(\mu(n)\)</span>
的前缀和与 <span class="math inline">\(\sum_{i =
1}^n\lfloor\frac{n}{i}\rfloor\)</span> 的前缀和，在询问时用数论分块求
<span class="math inline">\(A(n, m)\)</span> 即可。预处理复杂度 <span
class="math inline">\(O(n\sqrt{n})\)</span>，单次询问复杂度 <span
class="math inline">\(O(\sqrt{n})\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">5e4</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> isNotPrime[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> mu[MAXN + <span class="number">1</span>], primes[MAXN + <span class="number">1</span>], cnt;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> sumMu[MAXN + <span class="number">1</span>], sum[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">getPrimes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    isNotPrime[<span class="number">0</span>] = isNotPrime[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">    mu[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isNotPrime[i]) &#123;</span><br><span class="line">            primes[++cnt] = i;</span><br><span class="line">            mu[i] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= cnt; j++) &#123;</span><br><span class="line">            <span class="type">int</span> t = i * primes[j];</span><br><span class="line">            <span class="keyword">if</span> (t &gt; MAXN) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            isNotPrime[t] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i % primes[j] == <span class="number">0</span>) &#123;</span><br><span class="line">                mu[t] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> mu[t] = -mu[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sumMu[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) sumMu[i] = sumMu[i - <span class="number">1</span>] + mu[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= i; l = r + <span class="number">1</span>) &#123;</span><br><span class="line">            r = i / (i / l);</span><br><span class="line">            sum[i] += (<span class="type">long</span> <span class="type">long</span>)(r - l + <span class="number">1</span>) * (i / l);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>; l &lt;= std::<span class="built_in">min</span>(n, m); l = r + <span class="number">1</span>) &#123;</span><br><span class="line">        r = std::<span class="built_in">min</span>(n / (n / l), m / (m / l));</span><br><span class="line">        ans += (sumMu[r] - sumMu[l - <span class="number">1</span>]) * sum[n / l] * sum[m / l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">getPrimes</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">f</span>(n, m));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>省选</tag>
        <tag>数论</tag>
        <tag>线性筛</tag>
        <tag>莫比乌斯反演</tag>
        <tag>SDOI</tag>
        <tag>2015</tag>
      </tags>
  </entry>
  <entry>
    <title>「SPOJ 4354」Snowflakes - Hash</title>
    <url>/spoj-4354/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.spoj.com/problems/TWINSNOW/">SPOJ 链接</a></p>
<p>有 <span class="math inline">\(n (n \le 10^5)\)</span>
个雪花。每个雪花是 <span class="math inline">\(6\)</span>
个数组成的一个环。若两个环经过旋转（也可不旋转）后环上数字相等，则两个雪花相同。若两个环顺时针和逆时针数字相同则两个环也相同。判断是否有相同的雪花。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题我们可以利用 Hash 判断两个环是否相等。由于一个雪花的 <span
class="math inline">\(6\)</span> 个数有顺序，我们可以先生成 <span
class="math inline">\(6\)</span> 个 Hash 值 <span
class="math inline">\(\text{list}_i\)</span> 表示顺序。每个雪花的 Hash
值为 <span class="math inline">\(\sum_{i = 1}^n{\text{list}_i
a_i}\)</span>。对于每个雪花，我们将其的顺时针和逆时针两种情况旋转 <span
class="math inline">\(6\)</span> 次，每个雪花用
<code>unordered_map</code> 存下 <span class="math inline">\(12\)</span>
个 Hash 值，然后直接利用 <code>unordered_map</code>
判重即可。时间复杂度为 <span class="math inline">\(O(n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXL = <span class="number">1e7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::mt19937 <span class="title">rng</span><span class="params">(std::random_device&#123;&#125;())</span></span>;</span><br><span class="line">    <span class="keyword">auto</span> rand = [&amp;]() -&gt; <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> &#123; <span class="built_in">return</span> (<span class="number">1ull</span> &lt;&lt; (<span class="built_in">rng</span>() % <span class="number">31</span>)) ^ <span class="built_in">rng</span>(); &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">hash</span><span class="params">(MAXL + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= MAXL; i++) hash[i] = <span class="built_in">rand</span>();</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt; <span class="title">list</span><span class="params">(<span class="number">6</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) list[i] = <span class="built_in">rand</span>();</span><br><span class="line"></span><br><span class="line">    std::unordered_map&lt;<span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>, <span class="type">bool</span>&gt; vis;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="function">std::vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">            a[i + <span class="number">6</span>] = a[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) res += hash[a[j + k]] * list[k];</span><br><span class="line">            <span class="keyword">if</span> (vis[res]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Twin snowflakes found.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) vis[res] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++) &#123;</span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++) res += hash[a[j + <span class="number">5</span> - k]] * list[k];</span><br><span class="line">            <span class="keyword">if</span> (vis[res]) &#123;</span><br><span class="line">                <span class="built_in">puts</span>(<span class="string">&quot;Twin snowflakes found.&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) vis[res] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;No two snowflakes are alike.&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>Hash</tag>
        <tag>SPOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2005」互不侵犯 - 状压 DP</title>
    <url>/scoi2005-king/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P1896">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2153">LOJ 链接</a></p>
<p>在 <span class="math inline">\(N \times N\)</span> 的棋盘里面放 <span
class="math inline">\(K\)</span>
个国王，使他们互不攻击，共有多少种摆放方案。国王能攻击到它上下左右，以及左上左下右上右下八个方向上附近的各一个格子，共
<span class="math inline">\(8\)</span> 个格子。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>很明显这是一道状压 DP 的题目。我们可以定义数组 <span
class="math inline">\(f_{i, j, l}\)</span>，状态表示中 <span
class="math inline">\(i\)</span> 表示行数，<span
class="math inline">\(j\)</span> 表示已经放下的国王数，<span
class="math inline">\(l\)</span> 表示当前这行的国王放置状态。其中 <span
class="math inline">\(l\)</span> 使用二进制表示子集存储，<span
class="math inline">\(1\)</span> 表示放置国王。整个 <span
class="math inline">\(f\)</span> 表示当前状态的可能数。</p>
<p>显然我们可以推出下列状态转移方程（<span
class="math inline">\(\text{cnt}_x\)</span> 表示 <span
class="math inline">\(x\)</span> 状态下当前行的国王数，<span
class="math inline">\(\text{reach}\)</span> 代表添加一行可达到 <span
class="math inline">\(l\)</span> 的情况的集合）：</p>
<p><span class="math display">\[
f_{i, j + \text{cnt}_m, l} = \sum_{\text{reach}} f_{i - 1, j, m} \quad j
\in [\text{cnt}_l, k - \text{cnt}_j]
\]</span></p>
<p>对于 <span class="math inline">\(f\)</span>
的初始化，我们仅需要做的是将 <span class="math inline">\(i = 1\)</span>
的所有合法的序列赋值为 <span class="math inline">\(1\)</span> 即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> f[MAXN + <span class="number">1</span>][MAXN * MAXN + <span class="number">1</span>][<span class="number">1</span> &lt;&lt; MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">counts</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; (<span class="number">1</span> &lt;&lt; i) &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((x &gt;&gt; i) &amp; <span class="number">1</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="built_in">sizeof</span>(f));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">1</span>; each &lt; n - <span class="number">1</span>; each++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((i &gt;&gt; each) &amp; <span class="number">1</span>) &amp;&amp; (((i &gt;&gt; (each - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((i &gt;&gt; (each + <span class="number">1</span>)) &amp; <span class="number">1</span>))) &#123;</span><br><span class="line">                con = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = <span class="built_in">counts</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (con &amp;&amp; cnt &lt;= k) f[<span class="number">1</span>][cnt][i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">dp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; (<span class="number">1</span> &lt;&lt; n); j++) &#123;</span><br><span class="line">            <span class="type">bool</span> con = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">1</span>; each &lt; n - <span class="number">1</span>; each++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (((j &gt;&gt; each) &amp; <span class="number">1</span>) &amp; (((j &gt;&gt; (each - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((j &gt;&gt; (each + <span class="number">1</span>)) &amp; <span class="number">1</span>))) &#123;</span><br><span class="line">                    con = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> cntJ = <span class="built_in">counts</span>(j);</span><br><span class="line">            <span class="keyword">if</span> (con &amp;&amp; cntJ &lt;= k) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">0</span>; l &lt; (<span class="number">1</span> &lt;&lt; n); l++) &#123;</span><br><span class="line">                    con = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> ((j &amp; <span class="number">1</span>) &amp;&amp; ((l &amp; <span class="number">1</span>) || ((l &gt;&gt; <span class="number">1</span>) &amp; <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">if</span> (((j &gt;&gt; (n - <span class="number">1</span>)) &amp; <span class="number">1</span>) &amp;&amp; (((l &gt;&gt; (n - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((l &gt;&gt; (n - <span class="number">2</span>)) &amp; <span class="number">1</span>))) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> each = <span class="number">1</span>; each &lt; n - <span class="number">1</span>; each++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (((j &gt;&gt; each) &amp; <span class="number">1</span>) &amp;&amp; (((l &gt;&gt; each) &amp; <span class="number">1</span>) || ((l &gt;&gt; (each - <span class="number">1</span>)) &amp; <span class="number">1</span>) || ((l &gt;&gt; (each + <span class="number">1</span>)) &amp; <span class="number">1</span>))) &#123;</span><br><span class="line">                            con = <span class="literal">false</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="type">int</span> cntL = <span class="built_in">counts</span>(l);</span><br><span class="line">                    <span class="keyword">if</span> (con &amp;&amp; cntJ + cntL &lt;= k) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="type">int</span> m = cntL; m &lt;= k - cntJ; m++) &#123;</span><br><span class="line">                            f[i][m + cntJ][j] += f[i - <span class="number">1</span>][m][l];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">getAns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">        ans += f[n][k][i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dp</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">getAns</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>DP</tag>
        <tag>省选</tag>
        <tag>状压 DP</tag>
        <tag>SCOI</tag>
        <tag>2005</tag>
      </tags>
  </entry>
  <entry>
    <title>「SDIO2010」古代猪文 - 数论 + Lucas 定理</title>
    <url>/sdoi2010-ancient/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2480">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10229">LOJ 链接</a></p>
<p>给定整数 <span class="math inline">\(g\)</span>，<span
class="math inline">\(n\)</span>（<span class="math inline">\(1 \leq q,
n \leq 10^9\)</span>），计算：</p>
<p><span class="math display">\[
g^{\sum_{d|n}{C_{n}^{d}}} \operatorname{mod} 999911659
\]</span></p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><span class="math inline">\(999911659\)</span> 为质数，显然与 <span
class="math inline">\(g\)</span> 互质。</p>
<p>对于该式，我们可以用欧拉定理推论转化为：</p>
<p><span class="math display">\[
g^{\sum_{d|n}{C_{n}^{d}} \bmod \varphi(999911659)} \bmod 999911659 \\
= g^{\sum_{d|n}{C_{n}^{d}} \bmod 999911658} \bmod 999911659
\]</span></p>
<p>于是该题可转化为求出 <span
class="math inline">\(\sum_{d|n}{C_{n}^{d}} \operatorname{mod}
999911658\)</span>。</p>
<p>我们将 <span class="math inline">\(999911658\)</span>
分解质因数，可得 <span class="math inline">\(888811658 = 2 \times 3
\times 4679 \times 35617\)</span>，其中没有相同的质因数。</p>
<p>于是对于方程 <span class="math inline">\(x \equiv
\sum_{d|n}{C_{n}^{d}} \pmod
{999911658}\)</span>，显然对于下列同余方程组：</p>
<p><span class="math display">\[
\begin{cases}
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {2} \\
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {3} \\
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {4679} \\
x \equiv \sum_{d|n}{C_{n}^{d}} \pmod {35617}
\end{cases}
\]</span></p>
<p>其中 <span class="math inline">\(x\)</span> 的解即为方程 <span
class="math inline">\(x \equiv \sum_{d|n}{C_{n}^{d}} \pmod
{999911658}\)</span> 的解。</p>
<p>我们先对 <span class="math inline">\(n\)</span>
分解质因数，再用中国剩余定理求出该方程组的解，用 Lucas
定理和预处理阶乘及逆元优化求解 <span class="math inline">\(C_{n}^{d}
\bmod p\)</span>。最终利用快速幂求出 <span class="math inline">\(g^x
\bmod 999911659\)</span> 即得出答案。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">35617</span>, MOD = <span class="number">999911659</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">long</span> <span class="type">long</span> fact[MAXN + <span class="number">1</span>], inv[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">power</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> re = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (y) &#123;</span><br><span class="line">        <span class="keyword">if</span> (y &amp; <span class="number">1</span>) re = (re * x) % p;</span><br><span class="line">        x = (x * x) % p;</span><br><span class="line">        y &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">C</span><span class="params">(<span class="type">long</span> <span class="type">long</span> x, <span class="type">long</span> <span class="type">long</span> y, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ((fact[x] * inv[y]) % p * inv[x - y]) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lucas</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n, <span class="type">long</span> <span class="type">long</span> m, <span class="type">long</span> <span class="type">long</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; m) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!n) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">lucas</span>(n / p, m / p, p) * <span class="built_in">C</span>(n % p, m % p, p)) % p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b, <span class="type">long</span> <span class="type">long</span> &amp;x, <span class="type">long</span> <span class="type">long</span> &amp;y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">        x = <span class="number">1</span>;</span><br><span class="line">        y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> t = x;</span><br><span class="line">    x = y;</span><br><span class="line">    y = t - (a / b) * y;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">crt</span><span class="params">(<span class="type">int</span> k, <span class="type">long</span> <span class="type">long</span>* a, <span class="type">long</span> <span class="type">long</span>* r)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n = <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) n = n * r[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = n / r[i], b, y;</span><br><span class="line">        <span class="built_in">exgcd</span>(m, r[i], b, y);</span><br><span class="line">        ans = (ans + a[i] * m * b % n) % n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (ans % n + n) % n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> p)</span> </span>&#123;</span><br><span class="line">    fact[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = <span class="number">1</span>; i &lt;= p; i++) &#123;</span><br><span class="line">        fact[i] = (fact[i - <span class="number">1</span>] * i) % p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    inv[p - <span class="number">1</span>] = <span class="built_in">power</span>(fact[p - <span class="number">1</span>], p - <span class="number">2</span>, p);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> i = p - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        inv[i] = (inv[i + <span class="number">1</span>] * (i + <span class="number">1</span>)) % p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> n, g;</span><br><span class="line"></span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; g;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (g == MOD) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> f[<span class="number">5</span>] = &#123; <span class="number">-1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4679</span>, <span class="number">35617</span> &#125;, a[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">init</span>(f[i]);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="type">long</span> d = <span class="number">1</span>; d * d &lt;= n; d++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % d == <span class="number">0</span>) &#123;</span><br><span class="line">                a[i] = (a[i] + <span class="built_in">lucas</span>(n, d, f[i])) % f[i];</span><br><span class="line">                <span class="keyword">if</span> (d * d != n) &#123;</span><br><span class="line">                    a[i] = (a[i] + <span class="built_in">lucas</span>(n, n / d, f[i])) % f[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">power</span>(g, <span class="built_in">crt</span>(<span class="number">4</span>, a, f), MOD) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>数学</tag>
        <tag>组合数学</tag>
        <tag>省选</tag>
        <tag>数论</tag>
        <tag>2010</tag>
        <tag>SDOI</tag>
        <tag>Lucas 定理</tag>
      </tags>
  </entry>
  <entry>
    <title>「SCOI2010」传送带 - 三分</title>
    <url>/scoi2010-walk/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P2571">洛谷链接</a></p>
<p><a href="https://loj.ac/p/10017">LOJ 链接</a></p>
<p>在一个 <span class="math inline">\(2\)</span>
维平面上有两条传送带，每一条传送带可以看成是一条线段。两条传送带分别为线段
<span class="math inline">\(\text{AB}\)</span> 和线段 <span
class="math inline">\(\text{CD}\)</span>。lxhgww 在 <span
class="math inline">\(\text{AB}\)</span> 上的移动速度为 <span
class="math inline">\(P\)</span>，在 <span
class="math inline">\(CD\)</span> 上的移动速度为 <span
class="math inline">\(Q\)</span>，在平面上的移动速度 <span
class="math inline">\(R\)</span>。现在 lxhgww 想从 <span
class="math inline">\(\text A\)</span> 点走到 <span
class="math inline">\(\text D\)</span>
点，他想知道最少需要走多长时间。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们先忽略 <span class="math inline">\(\text{CD}\)</span>
线段，很明显我们在 <span class="math inline">\(\text{AB}\)</span>
上行走的距离与时间呈现一个单谷函数，故我们可以使用三分解决该问题。</p>
<p>接下来我们考虑 <span class="math inline">\(\text{CD}\)</span>
线段，这时候我们可以用三分套三分来解决该问题。第一个三分解决在哪个位置从
<span class="math inline">\(\text{AB}\)</span>
下来，下来后的坐标可利用第二个三分求从该坐标出发到 <span
class="math inline">\(\text D\)</span> 的最短时间，即在哪从地面上到
<span class="math inline">\(\text{CD}\)</span>。时间复杂度为 <span
class="math inline">\(O(\log_3^2 n)\)</span></p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">double</span> ax, ay, bx, by;</span><br><span class="line"><span class="type">double</span> cx, cy, dx, dy;</span><br><span class="line"><span class="type">double</span> p, q, rr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">dis</span><span class="params">(std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; a, std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(a.first - b.first, <span class="number">2</span>) + <span class="built_in">pow</span>(a.second - b.second, <span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solveCD</span><span class="params">(<span class="type">double</span> x, <span class="type">double</span> y)</span> </span>&#123;</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; l = std::<span class="built_in">make_pair</span>(cx, cy), r = std::<span class="built_in">make_pair</span>(dx, dy);</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; lMid, rMid;</span><br><span class="line">    <span class="type">double</span> lVal = <span class="number">-100</span>, rVal = <span class="built_in">dis</span>(std::<span class="built_in">make_pair</span>(ax, ay), std::<span class="built_in">make_pair</span>(dx, dy)) / rr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">abs</span>(rVal - lVal) &gt;= <span class="number">0.000001</span>) &#123;</span><br><span class="line">        lMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">3.0</span>, l.second + (r.second - l.second) / <span class="number">3.0</span>);</span><br><span class="line">        rMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">1.5</span>, l.second + (r.second - l.second) / <span class="number">1.5</span>);</span><br><span class="line">        lVal = <span class="built_in">dis</span>(lMid, std::<span class="built_in">make_pair</span>(x, y)) / rr + <span class="built_in">dis</span>(lMid, std::<span class="built_in">make_pair</span>(dx, dy)) / q;</span><br><span class="line">        rVal = <span class="built_in">dis</span>(rMid, std::<span class="built_in">make_pair</span>(x, y)) / rr + <span class="built_in">dis</span>(rMid, std::<span class="built_in">make_pair</span>(dx, dy)) / q;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lVal &gt; rVal) l = lMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal &lt; rVal) r = rMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal == rVal) l = lMid, r = rMid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">solveAB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; l = std::<span class="built_in">make_pair</span>(ax, ay), r = std::<span class="built_in">make_pair</span>(bx, by);</span><br><span class="line">    std::pair&lt;<span class="type">double</span>, <span class="type">double</span>&gt; lMid, rMid;</span><br><span class="line">    <span class="type">double</span> lVal = <span class="number">-100</span>, rVal = <span class="built_in">dis</span>(std::<span class="built_in">make_pair</span>(ax, ay), std::<span class="built_in">make_pair</span>(bx, by)) / p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (std::<span class="built_in">abs</span>(rVal - lVal) &gt;= <span class="number">0.000001</span>) &#123;</span><br><span class="line">        lMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">3.0</span>, l.second + (r.second - l.second) / <span class="number">3.0</span>);</span><br><span class="line">        rMid = std::<span class="built_in">make_pair</span>(l.first + (r.first - l.first) / <span class="number">1.5</span>, l.second + (r.second - l.second) / <span class="number">1.5</span>);</span><br><span class="line">        lVal = <span class="built_in">dis</span>(lMid, std::<span class="built_in">make_pair</span>(ax, ay)) / p + <span class="built_in">solveCD</span>(lMid.first, lMid.second);</span><br><span class="line">        rVal = <span class="built_in">dis</span>(rMid, std::<span class="built_in">make_pair</span>(ax, ay)) / p + <span class="built_in">solveCD</span>(rMid.first, rMid.second);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (lVal &gt; rVal) l = lMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal &lt; rVal) r = rMid;</span><br><span class="line">        <span class="keyword">if</span> (lVal == rVal) l = lMid, r = rMid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; ax &gt;&gt; ay &gt;&gt; bx &gt;&gt; by;</span><br><span class="line">    std::cin &gt;&gt; cx &gt;&gt; cy &gt;&gt; dx &gt;&gt; dy;</span><br><span class="line">    std::cin &gt;&gt; p &gt;&gt; q &gt;&gt; rr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, <span class="built_in">solveAB</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>省选</tag>
        <tag>2010</tag>
        <tag>SCOI</tag>
        <tag>三分</tag>
      </tags>
  </entry>
  <entry>
    <title>「UVa 1599」Ideal Path - 最短路 + BFS</title>
    <url>/uva-1599/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=448&amp;page=show_problem&amp;problem=4474">UVa
链接</a></p>
<p>给定一个 <span class="math inline">\(n\)</span> 个点 <span
class="math inline">\(m\)</span> 条边的无向图，每条边上都涂有 <span
class="math inline">\(1\)</span> 种颜色。求点 <span
class="math inline">\(1\)</span> 到点 <span
class="math inline">\(n\)</span>
的一条路径，使得经过的边数最少，在此前提下，经过边的颜色序列最小。可能有自环与重边。输入保证至少存在一条连接
<span class="math inline">\(1\)</span> 和 <span
class="math inline">\(n\)</span> 的道路。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题为求图论最短路，由于不需要考虑边权，可使用 BFS。</p>
<p>这道题在路径最短的情况下使得颜色所组成的字典序最小，可以分开解决。</p>
<p>首先解决最短路问题，求出所有的从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的最短路路径。这一步可通过记录从 <span
class="math inline">\(n\)</span> 到 <span
class="math inline">\(1\)</span> 可到达所有点的步数即可。利用该方法可从
<span class="math inline">\(1\)</span>
遍历可达路径，只要满足在记录中将达到的点的步数为之前的点的步数减一即为从
<span class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的最短路或最短路的一部分，这一步可通过
BFS 解决，代码中对应的是 <code>bfsK</code> 函数。</p>
<p>接下来就要解决字典序最小。我们需要再一次使用 BFS
以求出在所有最短路中字典序最小的一条。由于最终长度相同，我们始终仅需选择字典序最小的节点。若两节点字典序相同，则都存入考虑范围。由于该次
BFS
无需进行队列弹出操作，且存入的节点同一层可能有多个，存储全部队列空间可能会爆，所以我们需要将队列改写滚动样式，仅存储最上层和次上层即可。代码中对应的是
<code>bfsCol</code> 函数。</p>
<p>注意在 <code>bfsCol</code>
函数中合理处理最短路步数的标记。同时注意应在全部字典序的节点都压入队列时再进行滚动操作。</p>
<h1 id="代码演示">代码演示</h1>
<p>这次 AC 代码有点丑，请见谅 ≧ ﹏ ≦</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>, INF = <span class="number">200000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> vis[MAXN + <span class="number">1</span>], ans;</span><br><span class="line"><span class="type">int</span> col[INF + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsK</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::queue&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; qK;</span><br><span class="line">    <span class="built_in">memset</span>(vis, <span class="number">-1</span>, <span class="built_in">sizeof</span>(vis));</span><br><span class="line">    qK.<span class="built_in">push</span>( std::<span class="built_in">make_pair</span>(n, <span class="number">0</span>) );</span><br><span class="line">    vis[n] = <span class="number">0</span>, ans = INF;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!qK.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">auto</span> u = qK.<span class="built_in">front</span>();</span><br><span class="line">        qK.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (u.first == <span class="number">1</span> &amp;&amp; u.second &lt; ans) ans = u.second;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u.first]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vis[ed.first] == <span class="number">-1</span>) &#123;</span><br><span class="line">                vis[ed.first] = u.second + <span class="number">1</span>;</span><br><span class="line">                qK.<span class="built_in">push</span>(std::<span class="built_in">make_pair</span>(ed.first, u.second + <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsCol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; qCol;</span><br><span class="line">    <span class="type">static</span> <span class="type">bool</span> mk[MAXN + <span class="number">1</span>];  <span class="comment">// 此为已访问节点的标记</span></span><br><span class="line">    <span class="built_in">memset</span>(col, <span class="number">0x3f</span>, <span class="built_in">sizeof</span>(col));</span><br><span class="line">    <span class="built_in">memset</span>(mk, <span class="literal">false</span>, <span class="built_in">sizeof</span>(mk));</span><br><span class="line">    qCol.<span class="built_in">clear</span>();</span><br><span class="line">    qCol.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = ans - <span class="number">1</span>;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">static</span> std::vector&lt;<span class="type">int</span>&gt; uSet;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 注意滚动的时机</span></span><br><span class="line">            uSet.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> each : qCol) uSet.<span class="built_in">push_back</span>(each);</span><br><span class="line">            qCol.<span class="built_in">clear</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> u : uSet) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (vis[ed.first] == cnt) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!mk[ed.first]) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (col[cnt] &gt;= ed.second) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (col[cnt] &gt; ed.second) qCol.<span class="built_in">clear</span>();</span><br><span class="line">                            col[cnt] = ed.second;</span><br><span class="line">                            mk[ed.first] = <span class="literal">true</span>;</span><br><span class="line">                            flag = <span class="literal">false</span>;</span><br><span class="line">                            qCol.<span class="built_in">push_back</span>(ed.first);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[cnt] &gt; ed.second) col[cnt] = ed.second;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;  <span class="comment">// 若无符合条件的节点，说明已遍历完。最短路步数加一。</span></span><br><span class="line">            cnt--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> u : uSet) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> ed : e[u]) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (vis[ed.first] == cnt) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!mk[ed.first]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (col[cnt] &gt;= ed.second) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (col[cnt] &gt; ed.second) qCol.<span class="built_in">clear</span>();</span><br><span class="line">                                col[cnt] = ed.second;</span><br><span class="line">                                mk[ed.first] = <span class="literal">true</span>;</span><br><span class="line">                                flag = <span class="literal">false</span>;</span><br><span class="line">                                qCol.<span class="built_in">push_back</span>(ed.first);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (col[cnt] &gt; ed.second) col[cnt] = ed.second;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (std::cin &gt;&gt; n &gt;&gt; m) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) e[i].<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, x, y, z; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>, &amp;x, &amp;y, &amp;z);</span><br><span class="line">            <span class="keyword">if</span> (x == y) <span class="keyword">continue</span>;</span><br><span class="line">            e[x].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(y, z) );</span><br><span class="line">            e[y].<span class="built_in">push_back</span>( std::<span class="built_in">make_pair</span>(x, z) );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) std::<span class="built_in">sort</span>(e[i].<span class="built_in">begin</span>(), e[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">bfsK</span>();</span><br><span class="line">        <span class="built_in">bfsCol</span>();</span><br><span class="line"></span><br><span class="line">        std::cout &lt;&lt; ans &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// UVA毒瘤！卡我输出格式！</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = ans - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) <span class="built_in">printf</span>(<span class="string">&quot;%d%c&quot;</span>, col[i], i == <span class="number">0</span> ? <span class="string">&#x27;\n&#x27;</span> : <span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>最短路</tag>
        <tag>BFS</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
  <entry>
    <title>Tarjan 强连通分量学习笔记</title>
    <url>/tarjan-scc-notes/</url>
    <content><![CDATA[<p><del>鸽了好久</del></p>
<h1 id="概念">概念</h1>
<p>强连通图：指的是一张有向图，其中从任意一个节点出发，都可达到该图的所有节点。</p>
<p>强连通分量：指的是有向图的一种子图，满足该子图为强连通图，且这个子图是
<strong>极大</strong> 的，即对于一幅图 <span
class="math inline">\(G\)</span> 的强连通分量 <span
class="math inline">\(G_0\)</span>，我们无法找到一副子图 <span
class="math inline">\(G_1\)</span> 为强连通图，且满足 <span
class="math inline">\(G_0 \subsetneqq G_1 \subseteq G\)</span></p>
<span id="more"></span>
<h1 id="tarjan">Tarjan</h1>
<h2 id="时间戳">时间戳</h2>
<p>对于一张图，我们可以使用 Tarjan 算法求出这张图的强连通分量。</p>
<p>Tarjan 算法引入了一个概念：时间戳，即对一张图进行 DFS
时经过每个点的顺序。用 <span class="math inline">\(\text{dfn}_i\)</span>
表示。</p>
<p>对于下面这幅图：</p>
<img src="/tarjan-scc-notes/tarjan-scc-graph.png" class="">
<p>该图对应的时间戳为：</p>
<p><span class="math display">\[
\begin{align}
\text{dfn}_1 = 1 \quad \text{dfn}_2 = 2 \quad \text{dfn}_5 = 3 \quad
\text{dfn}_4 = 4 \\
\text{dfn}_3 = 5 \quad \text{dfn}_7 = 6 \quad \text{dfn}_6 = 7
\end{align}
\]</span></p>
<h2 id="边的分类">边的分类</h2>
<p>我们可以很容易地看出，对于一个环，环中的节点都属于同一个强连通分量。</p>
<p>Tarjan 则是通过改编 DFS 来找“环”的一种算法。</p>
<p>于是我们可以基于时间戳将边分个类。首先我们定义搜索所经过的边构成了一颗搜索树（或森林）。</p>
<p>于是对于有向边 <span class="math inline">\((x, y)\)</span>
我们可以得到下列几种边：</p>
<ul>
<li><p>树枝边：即为搜索时经过的边，反映在搜索树上即为 <span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的父节点；</p></li>
<li><p>前向边：即为在搜索树中祖先节点指向孙子节点，即 <span
class="math inline">\(x\)</span> 为 <span
class="math inline">\(y\)</span> 的祖先；</p></li>
<li><p>后向边：即为在搜索树中孙子节点指向祖先节点，即 <span
class="math inline">\(y\)</span> 为 <span
class="math inline">\(x\)</span> 的祖先；</p></li>
<li><p>横插边：即为除了上述三种情况的边，此时必满足 <span
class="math inline">\(\text{dfn}_y &lt; \text{dfn}_x\)</span>。</p></li>
</ul>
<p>下面这幅图很好地阐释了四种边的类型（摘自《算法竞赛进阶指南》）。加粗的边为树枝边，其余边则取第一个汉字：</p>
<img src="/tarjan-scc-notes/tarjan-scc-edges.png" class="">
<h2 id="求解强连通分量">求解强连通分量</h2>
<h3 id="对环的理解">对“环”的理解</h3>
<p>对于“环”有影响的有两种边：后向边和横插边。</p>
<p>为了求后向边和横插边，我们可以维护一个栈，在访问 <span
class="math inline">\(x\)</span> 节点时，存储以下信息：</p>
<ul>
<li><p>搜索树上 <span class="math inline">\(x\)</span>
的祖先节点；</p></li>
<li><p>已经访问过的，且可通过一条路径就到达 <span
class="math inline">\(x\)</span> 祖先节点的节点。</p></li>
</ul>
<p>对于节点 <span class="math inline">\(y\)</span>，只要 <span
class="math inline">\(y\)</span> 有一条路径到 <span
class="math inline">\(x\)</span> 的祖先，且存在一条 <span
class="math inline">\(x \rightarrow y\)</span> 的横插边，显然 <span
class="math inline">\(x\)</span>、<span class="math inline">\(x\)</span>
的祖先和 <span class="math inline">\(y\)</span>
形成了一个环，属于同一个强连通分量。</p>
<h3 id="追溯值">追溯值</h3>
<p>接下来我们需要看怎么求树枝边和横插边。</p>
<p>这时我们可以引入一个追溯值 <span
class="math inline">\(\text{low}_i\)</span>，表示由节点 <span
class="math inline">\(i\)</span> 开始搜索所能到达的点中，在搜索树上是
<span class="math inline">\(i\)</span> 的祖先的节点中最小的时间戳。</p>
<p>于是我们可以对节点 <span class="math inline">\(x\)</span>
进行下列操作：</p>
<ol type="1">
<li><p>当节点 <span class="math inline">\(x\)</span> 第一次被访问时，把
<span class="math inline">\(x\)</span> 入栈，初始化 <span
class="math inline">\(\text{low}_x = \text{dfn}_x\)</span>；</p></li>
<li><p>扫描从 <span class="math inline">\(x\)</span> 出发的边 <span
class="math inline">\(x \rightarrow y\)</span>：</p>
<ol type="1">
<li><p>若 <span class="math inline">\(y\)</span> 没访问过，则说明 <span
class="math inline">\(y\)</span> 是 <span
class="math inline">\(x\)</span> 的树枝边，递归访问 <span
class="math inline">\(y\)</span>，从 <span
class="math inline">\(y\)</span> 回溯后，令 <span
class="math inline">\(\text{low}_x = \min \{ \text{low}_x, \text{low}_y
\}\)</span>；</p></li>
<li><p>若 <span class="math inline">\(y\)</span> 被访问过并且 <span
class="math inline">\(y\)</span> 在栈中，则令 <span
class="math inline">\(\text{low}_x = \min \{ \text{low}_x, \text{dfn}_y
\}\)</span>。</p></li>
</ol></li>
<li><p>从 <span class="math inline">\(x\)</span> 回溯之前，判断是否有
<span class="math inline">\(\text{low}_x =
\text{dfn}_x\)</span>。若成立，则不断从栈中弹出节点，直至 <span
class="math inline">\(x\)</span> 出栈。</p></li>
</ol>
<p>显然在第三步中当 <span class="math inline">\(\text{low}_x =
\text{dfn}_x\)</span> 时，栈顶到栈中 <span
class="math inline">\(x\)</span> 之间必有节点都通过树枝边或横插边连向
<span
class="math inline">\(x\)</span>，且其中的其余节点有至少一条路径连线该节点。即这些节点构成一个环，属于同一个强连通分量。此时只需在出栈的时候记录其中节点属于同一强连通分量即可。</p>
<p>Tarjan 的时间复杂度为 <span class="math inline">\(O(n +
m)\)</span>，是一个非常高效的算法。</p>
<h3 id="代码模板">代码模板</h3>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    sta.<span class="built_in">push</span>(x);</span><br><span class="line">    ins[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[each]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(each);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[each]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[each]) &#123;</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            ins[y] = <span class="number">0</span>;</span><br><span class="line">            c[y] = cnt, scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缩点">缩点</h2>
<p>求解完强连通分量可选择将强连通分量缩成一个点以便计算。</p>
<p>代码模板见下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[i]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c[i] == c[each]) <span class="keyword">continue</span>;</span><br><span class="line">        ec[c[i]].<span class="built_in">push_back</span>(c[each]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P2341">洛谷 P2341
[USACO03FALL / HAOI2006] 受欢迎的牛 G</a></p>
<p>本题仅需要将强连通分量缩点，统计出出度为 <span
class="math inline">\(0\)</span> 的点的个数。若个数为 <span
class="math inline">\(1\)</span>，答案则为该连通分量内节点个数，否则没有明星牛。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; e[MAXN + <span class="number">1</span>];</span><br><span class="line"><span class="type">int</span> dfn[MAXN + <span class="number">1</span>], low[MAXN + <span class="number">1</span>], num = <span class="number">0</span>, cnt = <span class="number">0</span>;</span><br><span class="line">std::stack&lt;<span class="type">int</span>&gt; sta;</span><br><span class="line"><span class="type">int</span> ins[MAXN + <span class="number">1</span>], c[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; scc[MAXN + <span class="number">1</span>];</span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ec[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tarjan</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">    dfn[x] = low[x] = ++num;</span><br><span class="line">    sta.<span class="built_in">push</span>(x);</span><br><span class="line">    ins[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> each : e[x]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!dfn[each]) &#123;</span><br><span class="line">            <span class="built_in">tarjan</span>(each);</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], low[each]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ins[each]) &#123;</span><br><span class="line">            low[x] = std::<span class="built_in">min</span>(low[x], dfn[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (dfn[x] == low[x]) &#123;</span><br><span class="line">        cnt++;</span><br><span class="line">        <span class="type">int</span> y;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            y = sta.<span class="built_in">top</span>();</span><br><span class="line">            sta.<span class="built_in">pop</span>();</span><br><span class="line">            ins[y] = <span class="number">0</span>;</span><br><span class="line">            c[y] = cnt, scc[cnt].<span class="built_in">push_back</span>(y);</span><br><span class="line">        &#125; <span class="keyword">while</span> (x != y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, a, b; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(dfn, <span class="number">0</span>, <span class="built_in">sizeof</span>(dfn));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!dfn[i]) <span class="built_in">tarjan</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> each : e[i]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c[i] == c[each]) <span class="keyword">continue</span>;</span><br><span class="line">            ec[c[i]].<span class="built_in">push_back</span>(c[each]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> counts = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ec[i].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            counts++;</span><br><span class="line">            pos = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (counts == <span class="number">1</span>) std::cout &lt;&lt; scc[pos].<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">else</span> std::cout &lt;&lt; <span class="string">&quot;0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>图论</tag>
        <tag>Tarjan</tag>
        <tag>强连通分量</tag>
      </tags>
  </entry>
  <entry>
    <title>「TJOI2018」数学计算 - 线段树</title>
    <url>/tjoi2018-cal/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P4588">洛谷链接</a></p>
<p><a href="https://loj.ac/p/2573">LOJ 链接</a></p>
<p>小豆现在有一个数 <span class="math inline">\(x\)</span> ，初始值为
<span class="math inline">\(1\)</span> 。 小豆有 <span
class="math inline">\(Q\)</span> 次操作，操作有两种类型:</p>
<ul>
<li><p><code>1 m</code>： <span class="math inline">\(x = x \times
m\)</span> ，输出 <span class="math inline">\(x \bmod M\)</span>
；</p></li>
<li><p><code>2 pos</code>： <span class="math inline">\(x = x /\)</span>
第 <span class="math inline">\(pos\)</span> 次操作所乘的数（保证第 <span
class="math inline">\(pos\)</span> 次操作一定为类型 1，对于每一个类型 1
的操作至多会被除一次），输出 <span class="math inline">\(x\bmod
M\)</span> 。</p></li>
</ul>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>这道题由于 <span class="math inline">\(M\)</span>
不一定是质数，我们无法用逆元解。于是我们可以将乘的数都存起来。</p>
<p>我们可以开一颗线段树，对于第 <span class="math inline">\(i\)</span>
次询问：</p>
<ul>
<li>类型 <span class="math inline">\(1\)</span>：在线段树第 <span
class="math inline">\(i\)</span> 点赋值为 <span
class="math inline">\(m\)</span>；</li>
<li>类型 <span class="math inline">\(2\)</span>：在线段树第 <span
class="math inline">\(\text{pos}\)</span> 点赋值为 <span
class="math inline">\(1\)</span>。</li>
</ul>
<p>线段树维护区间乘积，每次操作输出整颗线段树的乘积即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">1e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Q, M;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> pos, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt; <span class="keyword">this</span>-&gt;r || pos &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos == <span class="keyword">this</span>-&gt;l &amp;&amp; pos == <span class="keyword">this</span>-&gt;r) val = delta;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            lc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            rc-&gt;<span class="built_in">update</span>(pos, delta);</span><br><span class="line">            val = lc-&gt;val * rc-&gt;val % M;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> lc-&gt;<span class="built_in">query</span>(l, r) * rc-&gt;<span class="built_in">query</span>(l, r) % M;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="built_in">build</span>(l, mid), <span class="built_in">build</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;Q, &amp;M);</span><br><span class="line"></span><br><span class="line">        segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, Q);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= Q; i++) &#123;</span><br><span class="line">            <span class="type">int</span> op;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> m;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;op, &amp;m);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (op == <span class="number">1</span>) segment-&gt;<span class="built_in">update</span>(i, m);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) segment-&gt;<span class="built_in">update</span>(m, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, segment-&gt;<span class="built_in">query</span>(<span class="number">1</span>, Q));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>数据结构</tag>
        <tag>题解</tag>
        <tag>线段树</tag>
        <tag>省选</tag>
        <tag>TJOI</tag>
        <tag>2018</tag>
      </tags>
  </entry>
  <entry>
    <title>树链剖分学习笔记</title>
    <url>/tree-chain-split-notes/</url>
    <content><![CDATA[<p>树链剖分是一个很常见的处理树上问题的算法，但之前一直没学
/kk，现在终于把这个坑补了。</p>
<p>这里只讲了重链剖分，不涉及其他剖分方式。</p>
<h1 id="概念">概念</h1>
<p>树链剖分是一种把树上问题转化为序列问题的算法。它可以将树上的一条路径所经过的点用序列中的若干条区间表示。</p>
<p>首先我们需要知道几个概念：重儿子、轻儿子、重边、轻边。我们定义对于一个节点
<span class="math inline">\(u\)</span> 的儿子为 <span
class="math inline">\(v\)</span>，我们定义以 <span
class="math inline">\(v\)</span> 为根的子树中节点最多的子树所对应的
<span class="math inline">\(v\)</span> 为重儿子，其余的 <span
class="math inline">\(v\)</span>
为轻儿子。父亲连向重儿子的边为重边，父亲连向轻儿子的边为轻边。如果同时有多个以
<span class="math inline">\(v\)</span>
为根的子树节点数相同且最大，则选取任意一个 <span
class="math inline">\(v\)</span>
为重儿子，其余为轻儿子。这样对于每个非叶节点，我们都有一个重儿子和一个重边。</p>
<span id="more"></span>
<p>接下来以下列的图举例（图片引用自 OI Wiki）：</p>
<p><img src="https://oi-wiki.org/graph/images/hld.png" /></p>
<h2 id="重链及其性质">重链及其性质</h2>
<p>同时我们定义重链为由重边组成的极大的链，即以一条重边延伸出只有重边且最大的链。如上图中绿框所示。我们可以很容易地得出树上每个点属于且仅属于一条重链。于是我们可以将树上问题转化成重链上的问题。</p>
<p>我们可以发现，对于每个轻儿子，其子树大小至多为父亲的 <span
class="math inline">\(\frac{1}{2}\)</span>。又通过 LCA
的思想，我们可以得出重链的一个性质：对于树上任意一条路径，所经过的点可被拆分成不超过
<span class="math inline">\(\log n\)</span>
条重链（头尾的重链可不完整）。于是我们可以将路径问题转化为 <span
class="math inline">\(\log n\)</span> 条序列上的问题。</p>
<p>接下来我们需要将数转化为序列，这里我们可以使用 DFS
序，<strong>且遍历时优先遍历重儿子</strong>，这样每条重链就可保证在序列中是连续的。</p>
<h1 id="实现方式">实现方式</h1>
<p>我们将求出树上所有重链的操作叫做剖分。</p>
<h2 id="节点定义">节点定义</h2>
<p>首先对于每个节点，我们需要维护它的子树大小，DFS
序，深度以及所在的重链、父节点和重儿子。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chain</span> *chain;</span><br><span class="line">    <span class="type">int</span> size, dfn, depth;</span><br><span class="line">    Node *fa, *ch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="剖分">剖分</h2>
<p>对于树链剖分问题，我们可以先将这棵树进行两次 DFS 以进行剖分。第一次
DFS 求出每颗子树的大小，第二次 DFS
则求出每个点的重儿子。由于我们可以得出每个轻儿子必为重链的开头，于是我们存重链时仅需存储其深度最小的节点，且每遍历到一个轻节点就新建重链，每遍历到一个重节点就将其归入父亲的重链。于是我们可以在第二次
DFS 时同时将树进行剖分。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Chain</span>(Node *top) : <span class="built_in">top</span>(top) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        e.t-&gt;fa = v;</span><br><span class="line">        e.t-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.t, v);</span><br><span class="line">        v-&gt;size += e.t-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;ch || v-&gt;ch-&gt;size &lt; e.t-&gt;size) v-&gt;ch = e.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ts = <span class="number">0</span>;</span><br><span class="line">    v-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v-&gt;fa || v != v-&gt;fa-&gt;ch) v-&gt;chain = <span class="keyword">new</span> <span class="built_in">Chain</span>(v);</span><br><span class="line">    <span class="keyword">else</span> v-&gt;chain = v-&gt;fa-&gt;chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ch) <span class="built_in">dfs2</span>(v-&gt;ch);</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;fa == v &amp;&amp; e.t != v-&gt;ch) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    v-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v);</span><br><span class="line">    <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="维护序列">维护序列</h2>
<p>接下来我们就可在 DFS 序上操作了。对于每个点 <span
class="math inline">\(u\)</span>，在序列 <span
class="math inline">\(a\)</span> 上对应的是 <span
class="math inline">\(a_{\text{dfn}_u}\)</span>（<span
class="math inline">\(\text{dfn}_u\)</span> 为 <span
class="math inline">\(u\)</span> 的 DFS
序）。我们这里可以选择线段树维护（实际上选择其它任意数据结构均可）。</p>
<p>这时我们求路径的时候可以使用类似于倍增求 LCA
的思想：看两个重链开头的深度，然后更深的往上跳到父亲的重链，同时将这条重链纳入统计。最后跳到同一重链后将两点之间路径纳入统计即可。时间复杂度为
<span class="math inline">\(O(n \log n)\)</span>。代码演示如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Node *u, Node *v, <span class="type">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        segment-&gt;<span class="built_in">update</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn, w);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    segment-&gt;<span class="built_in">update</span>(u-&gt;dfn, v-&gt;dfn, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">query</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        res += segment-&gt;<span class="built_in">query</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    res += segment-&gt;<span class="built_in">query</span>(u-&gt;dfn, v-&gt;dfn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="求-lca">求 LCA</h2>
<p>用树链剖分也可以求 LCA，且比倍增求 LCA
更快，常数小。方法和上述维护序列类似，这就不赘述了。</p>
<h1 id="例题">例题</h1>
<p><a href="https://www.luogu.com.cn/problem/P3384">洛谷
P3384「模板」轻重链剖分/树链剖分</a></p>
<p>这道题是树链剖分模板，同时加了子树操作。在 DFS
序中子树中所有节点是连续的，且开头必为根节点，所以我们只需要查询或修改线段树中的子树所在区间即可。即为
<code>segment-&gt;query(nodes[v].dfn, nodes[v].dfn + nodes[v].size - 1)</code>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; e;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Chain</span> *chain;</span><br><span class="line">    <span class="type">int</span> size, dfn, depth;</span><br><span class="line">    Node *fa, *ch;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Chain</span> &#123;</span><br><span class="line">    Node *top;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Chain</span>(Node *top) : <span class="built_in">top</span>(top) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    v-&gt;e.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(Node *v, Node *fa = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    v-&gt;size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == fa) <span class="keyword">continue</span>;</span><br><span class="line">        e.t-&gt;fa = v;</span><br><span class="line">        e.t-&gt;depth = v-&gt;depth + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs1</span>(e.t, v);</span><br><span class="line">        v-&gt;size += e.t-&gt;size;</span><br><span class="line">        <span class="keyword">if</span> (!v-&gt;ch || v-&gt;ch-&gt;size &lt; e.t-&gt;size) v-&gt;ch = e.t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> ts = <span class="number">0</span>;</span><br><span class="line">    v-&gt;dfn = ++ts;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!v-&gt;fa || v != v-&gt;fa-&gt;ch) v-&gt;chain = <span class="keyword">new</span> <span class="built_in">Chain</span>(v);</span><br><span class="line">    <span class="keyword">else</span> v-&gt;chain = v-&gt;fa-&gt;chain;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ch) <span class="built_in">dfs2</span>(v-&gt;ch);</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : v-&gt;e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;fa == v &amp;&amp; e.t != v-&gt;ch) &#123;</span><br><span class="line">            <span class="built_in">dfs2</span>(e.t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">split</span><span class="params">(Node *v)</span> </span>&#123;</span><br><span class="line">    v-&gt;depth = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(v);</span><br><span class="line">    <span class="built_in">dfs2</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">SegT</span> &#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    SegT *lc, *rc;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> val, tag;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SegT</span>(<span class="type">int</span> l, <span class="type">int</span> r, SegT *lc, SegT *rc) : <span class="built_in">l</span>(l), <span class="built_in">r</span>(r), <span class="built_in">lc</span>(lc), <span class="built_in">rc</span>(rc), <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">tag</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">cover</span><span class="params">(<span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        val += (r - l + <span class="number">1</span>) * delta;</span><br><span class="line">        tag += delta;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pushDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tag) &#123;</span><br><span class="line">            lc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            rc-&gt;<span class="built_in">cover</span>(tag);</span><br><span class="line">            tag = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r, <span class="type">const</span> <span class="type">long</span> <span class="type">long</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="built_in">cover</span>(delta);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">pushDown</span>();</span><br><span class="line">            lc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            rc-&gt;<span class="built_in">update</span>(l, r, delta);</span><br><span class="line">            val = lc-&gt;val + rc-&gt;val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; <span class="keyword">this</span>-&gt;r || r &lt; <span class="keyword">this</span>-&gt;l) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l &lt;= <span class="keyword">this</span>-&gt;l &amp;&amp; r &gt;= <span class="keyword">this</span>-&gt;r) <span class="keyword">return</span> val;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">pushDown</span>();</span><br><span class="line">            <span class="keyword">return</span> lc-&gt;<span class="built_in">query</span>(l, r) + rc-&gt;<span class="built_in">query</span>(l, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> SegT *<span class="title">build</span><span class="params">(<span class="type">const</span> <span class="type">int</span> l, <span class="type">const</span> <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="literal">nullptr</span>, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">const</span> <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">SegT</span>(l, r, <span class="built_in">build</span>(l, mid), <span class="built_in">build</span>(mid + <span class="number">1</span>, r));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; *segment;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">update</span><span class="params">(Node *u, Node *v, <span class="type">long</span> <span class="type">long</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        segment-&gt;<span class="built_in">update</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn, w);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    segment-&gt;<span class="built_in">update</span>(u-&gt;dfn, v-&gt;dfn, w);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">long</span> <span class="type">long</span> <span class="title">query</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (u-&gt;chain != v-&gt;chain) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;chain-&gt;top-&gt;depth &lt; v-&gt;chain-&gt;top-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">        res += segment-&gt;<span class="built_in">query</span>(u-&gt;chain-&gt;top-&gt;dfn, u-&gt;dfn);</span><br><span class="line">        u = u-&gt;chain-&gt;top-&gt;fa;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;depth &gt; v-&gt;depth) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    res += segment-&gt;<span class="built_in">query</span>(u-&gt;dfn, v-&gt;dfn);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, r, p;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %d %d&quot;</span>, &amp;n, &amp;m, &amp;r, &amp;p);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">val</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[u], &amp;nodes[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">split</span>(&amp;nodes[r]);</span><br><span class="line"></span><br><span class="line">    segment = SegT::<span class="built_in">build</span>(<span class="number">1</span>, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) segment-&gt;<span class="built_in">update</span>(nodes[i].dfn, nodes[i].dfn, val[i]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;op);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d %lld&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line">            <span class="built_in">update</span>(&amp;nodes[u], &amp;nodes[v], w);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="type">int</span> u, v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">query</span>(&amp;nodes[u], &amp;nodes[v]) % p);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> w;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d %lld&quot;</span>, &amp;v, &amp;w);</span><br><span class="line">            segment-&gt;<span class="built_in">update</span>(nodes[v].dfn, nodes[v].dfn + nodes[v].size - <span class="number">1</span>, w);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="type">int</span> v;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;v);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, segment-&gt;<span class="built_in">query</span>(nodes[v].dfn, nodes[v].dfn + nodes[v].size - <span class="number">1</span>) % p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>学习笔记</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
        <tag>线段树</tag>
        <tag>树链剖分</tag>
      </tags>
  </entry>
  <entry>
    <title>「YbtOJ CSP-S 模拟赛」砍苹果树 - 树上差分</title>
    <url>/ybtoj723-tee/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="http://noip.ybtoj.com.cn/contest/723/problem/1">YbtOJ
链接（需付费）</a></p>
<p>小 K 有一棵 <span class="math inline">\(n\)</span> 个点，<span
class="math inline">\(n - 1\)</span> 条边的苹果树，将树上的边称为 A
类边。</p>
<p>小 K 还往这棵树上加上了 <span class="math inline">\(m\)</span>
条边，称加上的边为 B 类边。</p>
<p>作为小 K 的好朋友，你想要砍掉小 K
的苹果树，但是你发现砍掉一条边不一定能使苹果树不连通，于是你需要求出：有多少选取
<strong>恰好一条 A 类边和恰好一条 B 类边</strong>
的方案，使得这两条边删去之后，原图不连通。</p>
<p>两种方案不同当且仅当一条边在第一种方案中被删除了但在第二种方案中没有被删除。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>我们可以使用类似于树形 DP 的思想考虑这个题。我们只使用 A
类边构成一颗树，显然我们可以发现，对于一条 A 类边 <span
class="math inline">\(u \rightarrow v\)</span>，对于以 <span
class="math inline">\(v\)</span> 为根的子树，该颗子树内有 <span
class="math inline">\(k\)</span> 条通往子树外的 B
类边，可分一下情况讨论：</p>
<ul>
<li><span class="math inline">\(k = 0\)</span>：显然删除 <span
class="math inline">\(u \rightarrow v\)</span> 与任意 B
类边均满足情况，答案增加 <span class="math inline">\(m\)</span>；</li>
<li><span class="math inline">\(k = 1\)</span>：显然删除 <span
class="math inline">\(u \rightarrow v\)</span> 与通往子树外的那一条 B
类边满足情况，答案增加 <span class="math inline">\(1\)</span>；</li>
<li><span class="math inline">\(k &gt; 1\)</span>：无解。</li>
</ul>
<p>于是我们可以用树上差分，对点统计向外连边的个数，然后 DFS
一遍即可。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">3e5</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> LOG_MAXN = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="type">int</span> id;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    std::vector&lt;<span class="keyword">struct</span> Edge&gt; adj;</span><br><span class="line">    Node *f[LOG_MAXN + <span class="number">1</span>], *p;</span><br><span class="line">    <span class="type">int</span> d, cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span> &#123;</span><br><span class="line">    Node *s, *t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Edge</span>(Node *s, Node *t) : <span class="built_in">s</span>(s), <span class="built_in">t</span>(t) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addEdge</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    u-&gt;adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(u, v));</span><br><span class="line">    v-&gt;adj.<span class="built_in">push_back</span>(<span class="built_in">Edge</span>(v, u));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prepare</span><span class="params">(Node *u, Node *f = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    u-&gt;f[<span class="number">0</span>] = u-&gt;p = f;</span><br><span class="line">    u-&gt;d = (f ? f-&gt;d : <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= LOG_MAXN; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (u-&gt;f[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            u-&gt;f[i] = u-&gt;f[i - <span class="number">1</span>]-&gt;f[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : u-&gt;adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == f) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">prepare</span>(e.t, u);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Node *<span class="title">lca</span><span class="params">(Node *u, Node *v)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d &lt; v-&gt;d) std::<span class="built_in">swap</span>(u, v);</span><br><span class="line">    <span class="keyword">if</span> (u-&gt;d != v-&gt;d) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] &amp;&amp; u-&gt;f[i]-&gt;d &gt;= v-&gt;d) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (u != v) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = LOG_MAXN; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u-&gt;f[i] != v-&gt;f[i]) &#123;</span><br><span class="line">                u = u-&gt;f[i];</span><br><span class="line">                v = v-&gt;f[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> u-&gt;p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">dfs</span><span class="params">(Node *u, <span class="type">int</span> m, Node *f = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Edge &amp;e : u-&gt;adj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (e.t == f) <span class="keyword">continue</span>;</span><br><span class="line">        ans += <span class="built_in">dfs</span>(e.t, m, u);</span><br><span class="line">        <span class="keyword">if</span> (e.t-&gt;cnt == <span class="number">0</span>) ans += m;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e.t-&gt;cnt == <span class="number">1</span>) ans++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;p) u-&gt;p-&gt;cnt += u-&gt;cnt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%d]: %lld %d\n&quot;</span>, u-&gt;id, ans, u-&gt;cnt);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;tree.in&quot;</span>, <span class="string">&quot;r&quot;</span>, stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;tree.out&quot;</span>, <span class="string">&quot;w&quot;</span>, stdout);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);</span><br><span class="line"></span><br><span class="line">    <span class="function">std::vector&lt;Node&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) nodes[i].id = i;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="type">int</span> u, v;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);</span><br><span class="line">        <span class="built_in">addEdge</span>(&amp;nodes[u], &amp;nodes[v]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">prepare</span>(&amp;nodes[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>, &amp;a, &amp;b);</span><br><span class="line">        Node *u = &amp;nodes[a], *v = &amp;nodes[b];</span><br><span class="line">        Node *f = <span class="built_in">lca</span>(u, v);</span><br><span class="line">        u-&gt;cnt++, v-&gt;cnt++, f-&gt;cnt -= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DBG</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, nodes[i].cnt);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, <span class="built_in">dfs</span>(&amp;nodes[<span class="number">1</span>], m));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fclose</span>(stdin);</span><br><span class="line">    <span class="built_in">fclose</span>(stdout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>图论</tag>
        <tag>树</tag>
        <tag>2022</tag>
        <tag>树上差分</tag>
        <tag>YbtOJ</tag>
      </tags>
  </entry>
  <entry>
    <title>「ZJOI2020」序列 - 贪心</title>
    <url>/zjoi2020-seq/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a href="https://www.luogu.com.cn/problem/P6631">洛谷链接</a></p>
<p><a href="https://loj.ac/p/3313">LOJ 链接</a></p>
<p>Bob 喜欢序列。</p>
<p>有一个长度为 <span class="math inline">\(n\)</span> 的非负整数序列
<span class="math inline">\(a_1, a_2,\cdots,
a_n\)</span>。每一步你可以从以下三种操作中选择一种执行：</p>
<ul>
<li>选择一个区间 <span class="math inline">\([l,
r]\)</span>，将下标在这个区间里的所有数都减 <span
class="math inline">\(1\)</span>。</li>
<li>选择一个区间 <span class="math inline">\([l,
r]\)</span>，将下标在这个区间里且下标为奇数的所有数都减 <span
class="math inline">\(1\)</span>。</li>
<li>选择一个区间 <span class="math inline">\([l,
r]\)</span>，将下标在这个区间里且下标为偶数的所有数都减 <span
class="math inline">\(1\)</span>。</li>
</ul>
<p>求最少需要多少步才能将序列中的所有数都变成 <span
class="math inline">\(0\)</span>。</p>
<p>对于所有的数据，<span class="math inline">\(1 \leq n \leq 100000, 0
\leq a_i \leq 10^9, 1 \leq T \leq 10\)</span>。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p><del>我甚至菜到这是我做得第一道黑题</del></p>
<h2 id="模型构建">模型构建</h2>
<p>对于这道题，我们可以用基于贪心的思想解决。</p>
<p>首先明确两个概念：</p>
<ol type="1">
<li>对于第一种情况，由于在区间中减去的数是连续的，我们可以将其形象地称为
<strong>直线</strong>，命名为变量 <span
class="math inline">\(\text{line}_i\)</span>；</li>
<li>对于第二种情况，由于在区间中减去的数是不连续且有规律的间隔的，我们可以将其形象地称为
<strong>跳线</strong>，命名为变量 <span
class="math inline">\(\text{dance}_i\)</span>。</li>
</ol>
<p>基于类似于数学归纳法的思想，我们可以设想对于第 <span
class="math inline">\(i\)</span> 个数，前面的 <span
class="math inline">\(i - 1\)</span> 个数中每个数 <span
class="math inline">\(a_j\)</span> 在使用了 <span
class="math inline">\(\text{line}_j\)</span> 个直线和 <span
class="math inline">\(\text{dance}_j\)</span> 个跳线的情况下全部处理为
<span class="math inline">\(0\)</span>。在这种情况下求需要总共 <span
class="math inline">\(\text{line}_i\)</span> 个直线与 <span
class="math inline">\(\text{dance}_i\)</span> 个跳线将前 <span
class="math inline">\(a_i\)</span> 个数全部处理为 <span
class="math inline">\(0\)</span>，同时统计总共使用的线的数量 <span
class="math inline">\(\text{ans}\)</span>。</p>
<p>对于初始化，显然 <span class="math inline">\(\text{line}_0 =
\text{dance}_0 = \text{ans} = 0\)</span>。</p>
<h2 id="情况分析">情况分析</h2>
<p>接下来我们需要分析对于 <span
class="math inline">\(a_i\)</span>，我们使用直线或跳线的情况。</p>
<p>显然这只有下列两种情况：</p>
<ol type="1">
<li>在相邻两项 <span class="math inline">\(\forall i\)</span>，<span
class="math inline">\(a_i &gt;
0\)</span>。我们可以形象地称这个范围是连续的，显然在此时直线和跳线均可使用。在此时
<strong>尽量使用直线</strong> 必定是最优答案的一种。</li>
<li>在相邻两项 <span class="math inline">\(\exists i\)</span>，<span
class="math inline">\(a_i =
0\)</span>。我们可以形象地称这个范围是不连续（跳跃）的，显然此时只能使用跳线。</li>
</ol>
<p>对于情况 <span class="math inline">\(1\)</span>，以下为证明：</p>
<p>我们可以将该区间分为两部分：<span class="math inline">\(a_i = b_i +
c\)</span>，只用跳线处理 <span class="math inline">\(b_i\)</span>。其中
<span class="math inline">\(c \leq \min\limits_{l \leq i \leq
r}\{a_i\}\)</span>。显然对于 <span class="math inline">\(c\)</span>
直接使用直线搞定是最优的。而对于 <span
class="math inline">\(b_i\)</span>
为连续区间的前提下使用直线处理所作用的区间是用跳线的两倍。故要使 <span
class="math inline">\(b_i\)</span> 仅用跳线处理下最优，我们需要让 <span
class="math inline">\(b_i\)</span> 直线可作用区间
<strong>极小</strong>，即不可用直线。此时 <span
class="math inline">\(b_i\)</span> 必定不连续，显然此时 <span
class="math inline">\(c = \min\limits_{l \leq i \leq
r}\{a_i\}\)</span>。故用 <strong>尽量多的直线</strong> 处理掉 <span
class="math inline">\(c\)</span>，剩下的 <strong>不连续</strong> 的
<span class="math inline">\(b\)</span>
用跳线处理。这种操作定是最优答案的一种。</p>
<h2 id="分类讨论">分类讨论</h2>
<p>接下来我们就可以进行分类讨论。我们的目标是将 <span
class="math inline">\(a_i\)</span> 处理为 <span
class="math inline">\(0\)</span>，故遍历到 <span
class="math inline">\(i\)</span> 时，增加的线的数量必定为 <span
class="math inline">\(a_i\)</span>。答案的增量显然是增加线的数量，即
<span class="math inline">\(\text{ans} = \text{ans} +
a_i\)</span>。显然我们只考虑 <span class="math inline">\(a_i\)</span>
无法取到最优，于是我们可以从 <span class="math inline">\(a_{i +
1}\)</span> 入手。</p>
<ol type="1">
<li><p><span class="math inline">\(\text{line}_{i - 1} + \text{dance}_{i
- 1} \leq a_{i + 1}\)</span>：此时已用的线不够为 <span
class="math inline">\(a_{i + 1}\)</span>
作准备，我们需要更多的线来做准备。我们可以先将之前的两种线对 <span
class="math inline">\(a_{i + 1}\)</span> 的作用效果反映出来，即 <span
class="math inline">\(a_{i + 1} = a_{i + 1} - \text{line}_{i - 1} -
\text{dance}_{i - 1}\)</span>，此时 <span class="math inline">\(a_{i +
1} &gt; 0\)</span>。 此时只考虑 <span class="math inline">\(a_{i +
1}\)</span> 是无法做出最优解法的，我们必须同时考虑 <span
class="math inline">\(a_i\)</span>：</p>
<pre><code>1. $a_i \leq a_&#123;i + 1&#125;$：显然全部使用直线即可将 $a_i$ 处理为 $0$。即 $\text&#123;line&#125;_i = \text&#123;line&#125;_&#123;i - 1&#125; + a_i$，$\text&#123;dance&#125;_i = \text&#123;dance&#125;_&#123;i - 2&#125;$，$a_&#123;i + 1&#125; = a_&#123;i + 1&#125; - a_i$，$a_i = 0$；

2. $a_i &gt; a_&#123;i + 1&#125;$：先使用 $a_&#123;i + 1&#125;$ 条直线覆盖，再使用 $a_&#123;i + 1&#125; - a_i$ 条相邻的跳线覆盖，可将 $a_i$ 处理为 $0$。即 $\text&#123;line&#125;_i = \text&#123;line&#125;_&#123;i - 1&#125; + a_&#123;i + 1&#125;$，$\text&#123;dance&#125;_&#123;i + 1&#125; = \text&#123;dance&#125;_&#123;i - 1&#125; + a_i - a_&#123;i + 1&#125;$，$a_i = a_&#123;i + 1&#125; = 0$。</code></pre></li>
<li><p><span class="math inline">\(\text{line}_{i - 1} + \text{dance}_{i
- 1} &gt; a_{i + 1}\)</span>：说明目前我们拥有的线为 <span
class="math inline">\(a_{i + 1}\)</span>
准备过剩了。此时我们就需要考虑停止一些线的作用范围。我们可以记录需要额外停止的数量
<span class="math inline">\(\Delta = \text{line}_{i - 1} +
\text{dance}_{i - 1} - a_{i +
1}\)</span>。由于我们可以发现两种线均与位置有关，故在处理好 <span
class="math inline">\(\Delta\)</span> 后我们需要 <span
class="math inline">\(\text{line}_{i - 1} = \text{line}_{i - 1} -
\Delta\)</span>，<span class="math inline">\(\text{dance}_{i - 1} =
\text{dance}_{i - 1} - \Delta\)</span>。同时记录 <span
class="math inline">\(\text{nxt} = \Delta\)</span>，表示有 <span
class="math inline">\(\Delta\)</span> 条线可从 <span
class="math inline">\(a_{i + 1}\)</span>
恢复出发。这样就可以把该情况转化为情况 <span
class="math inline">\(1\)</span>。处理恢复情况则可在情况 <span
class="math inline">\(1\)</span> 处理后再把 <span
class="math inline">\(\text{nxt}\)</span>
加回去，同时在答案中减去可恢复的线的数量。即 <span
class="math inline">\(a_{i + 1} = a_{i + 1} + \text{nxt}\)</span>，<span
class="math inline">\(\text{ans} = \text{ans} -
\text{nxt}\)</span>。但由于在处理 <span
class="math inline">\(\Delta\)</span> 时 <span
class="math inline">\(\text{line}_{i - 1}\)</span> 和 <span
class="math inline">\(\text{dance}_{i - 1}\)</span>
不能处理为负数，故有下列几种情况特殊考虑：</p>
<ol type="1">
<li><p><span class="math inline">\(\Delta &gt; \text{dance}_{i -
1}\)</span>：这是我们需要直接停止部分的直线，让直线刚好覆盖 <span
class="math inline">\(a_{i + 1}\)</span>。即 <span
class="math inline">\(\text{line}_{i - 1} = a_{i + 1}\)</span>，此时
<span class="math inline">\(\Delta\)</span> 随之变化，即 <span
class="math inline">\(\Delta = \text{dance}_{i - 1}\)</span></p></li>
<li><p><span class="math inline">\(\Delta &gt; \text{line}_{i -
1}\)</span>：这时我们需要直接停止部分的跳线，让跳线刚好覆盖 <span
class="math inline">\(a_{i + 1}\)</span>。即 <span
class="math inline">\(\text{dance}_{i - 1} = a_{i + 1}\)</span>，此时
<span class="math inline">\(\Delta\)</span> 随之变化，即 <span
class="math inline">\(\Delta = \text{line}_{i - 1}\)</span></p></li>
<li><p>情况 <span class="math inline">\(1\)</span>、<span
class="math inline">\(2\)</span> 均不符合，保持现状。</p></li>
</ol></li>
</ol>
<p>最后我们需要解决奇数项和偶数项不同跳线的问题。由于两种跳线可看作作用相同的线，我们可以用两个变量存储两种跳线，然后在遍历
<span class="math inline">\(a_i\)</span>
的跳线不同作用项时不停交换即可，即每遍历到下一项则两种跳线数据交换。</p>
<p>最终时间复杂度为 <span
class="math inline">\(O(n)\)</span>，完全能过。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> a[MAXN + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;a[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> line = <span class="number">0</span>, dance1 = <span class="number">0</span>, dance2 = <span class="number">0</span>, ans = <span class="number">0</span>, nxt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i + <span class="number">1</span>] &lt; dance1 + line) &#123;</span><br><span class="line">                <span class="type">int</span> delta = dance1 + line - a[i + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (delta &gt; dance1) &#123;</span><br><span class="line">                    line = a[i + <span class="number">1</span>];</span><br><span class="line">                    delta = dance1;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (delta &gt; line) &#123;</span><br><span class="line">                    dance1 = a[i + <span class="number">1</span>];</span><br><span class="line">                    delta = line;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                line -= delta;</span><br><span class="line">                dance1 -= delta;</span><br><span class="line">                nxt = delta;</span><br><span class="line">                a[i + <span class="number">1</span>] -= nxt;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a[i + <span class="number">1</span>] -= line + dance1;</span><br><span class="line">            ans += a[i];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a[i] &lt;= a[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                line += a[i];</span><br><span class="line">                a[i + <span class="number">1</span>] -= a[i];</span><br><span class="line">                a[i] = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                line += a[i + <span class="number">1</span>];</span><br><span class="line">                dance2 += a[i] - a[i + <span class="number">1</span>];</span><br><span class="line">                a[i] = a[i + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            a[i + <span class="number">1</span>] += nxt;</span><br><span class="line">            ans -= nxt;</span><br><span class="line">            nxt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            std::<span class="built_in">swap</span>(dance1, dance2);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>省选</tag>
        <tag>ZJOI</tag>
        <tag>2020</tag>
      </tags>
  </entry>
  <entry>
    <title>「UVa 1471」Defense Lines - 贪心</title>
    <url>/uva-1471/</url>
    <content><![CDATA[<h1 id="题意描述">题意描述</h1>
<p><a
href="https://onlinejudge.org/index.php?option=com_onlinejudge&amp;Itemid=8&amp;category=447&amp;page=show_problem&amp;problem=4217">UVa
链接</a></p>
<p>对于一个长度为 <span class="math inline">\(n (n \le 200000)\)</span>
的序列，可删掉其中一段连续子序列。求删掉后序列的最长上升连续子序列。</p>
<span id="more"></span>
<h1 id="解题思路">解题思路</h1>
<p>本题我们可以分解为求两段最长上升连续子序列，且满足前一个序列的最后一项小于后一个序列的第一项。我们可以先预处理出以
<span class="math inline">\(i\)</span> 为开头的最长上升连续子序列的长度
<span class="math inline">\(f_i\)</span> 和以 <span
class="math inline">\(i\)</span> 为结尾的最长上升子序列的长度 <span
class="math inline">\(g_i\)</span>。显然就可以得出答案为 <span
class="math inline">\(\max\limits_{1 \le i \le n}\{ f_i + \max\limits_{1
\le j &lt; i \wedge a_i &gt; a_j} g_j
\}\)</span>。但这种做法时间复杂度为 <span
class="math inline">\(O(n^2)\)</span>，无法通过此题。于是我们需要考虑如何优化。</p>
<p>我们可以发现，对于两数 <span class="math inline">\(i\)</span>、<span
class="math inline">\(j\)</span>，若 <span class="math inline">\(g_i \ge
g_j \wedge a_i &lt; a_j\)</span>，则选 <span
class="math inline">\(g_i\)</span> 始终比选 <span
class="math inline">\(g_j\)</span> 更优，于是 <span
class="math inline">\(g_j\)</span>
不会被最优答案选取。我们可以用单调队列的思想，我们可以在对 <span
class="math inline">\(f_i\)</span> 进行遍历的时候维护一个
<code>set</code> 来存储可用的 <span class="math inline">\(g_j (j &lt;
i)\)</span>。每次在 <code>set</code> 中插入 <span
class="math inline">\(g_i\)</span> 时，就删除所有满足 <span
class="math inline">\(g_i \ge g_j \wedge a_i &lt; a_j\)</span> 条件的
<span class="math inline">\(g_j\)</span>。查询时可用
<code>lower_bound</code> 查询满足小于 <span
class="math inline">\(a_i\)</span>
的最大的一个即可。这时复杂度就优化到了 <span class="math inline">\(O(n
\log n)\)</span>。</p>
<h1 id="代码演示">代码演示</h1>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> MAXN = <span class="number">2e5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> a[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> f[MAXN + <span class="number">1</span>], g[MAXN + <span class="number">1</span>];</span><br><span class="line">    g[<span class="number">1</span>] = f[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt; a[i + <span class="number">1</span>]) f[i] = f[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> f[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i - <span class="number">1</span>] &lt; a[i]) g[i] = g[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> g[i] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="type">static</span> std::set&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt; s;</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    s.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(a[<span class="number">1</span>], g[<span class="number">1</span>]));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        std::set&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;::iterator it = s.<span class="built_in">lower_bound</span>(std::<span class="built_in">make_pair</span>(a[i], <span class="number">0</span>));</span><br><span class="line">        <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (it != s.<span class="built_in">begin</span>()) &#123;</span><br><span class="line">            it--;</span><br><span class="line">            ans = std::<span class="built_in">max</span>(ans, (*it).second + f[i]);</span><br><span class="line">            <span class="keyword">if</span> (g[i] &lt;= (*it).second) flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            std::set&lt; std::pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &gt;::iterator p = it;</span><br><span class="line">            p++;</span><br><span class="line">            <span class="keyword">while</span> (p != s.<span class="built_in">end</span>() &amp;&amp; (*p).first &gt; a[i] &amp;&amp; (*p).second &lt; g[i]) &#123;</span><br><span class="line">                it = p;</span><br><span class="line">                p++;</span><br><span class="line">                s.<span class="built_in">erase</span>(it);</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">insert</span>(std::<span class="built_in">make_pair</span>(a[i], g[i]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;t);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (t--) <span class="built_in">solve</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>OI</category>
        <category>题解</category>
      </categories>
      <tags>
        <tag>OI</tag>
        <tag>题解</tag>
        <tag>贪心</tag>
        <tag>UVa</tag>
      </tags>
  </entry>
</search>
